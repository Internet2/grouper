#
# Copyright 2014 Internet2
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

########################################
## Config chaining hierarchy
## Grouper loader uses Grouper Configuration Overlays (documented on wiki)
## By default the configuration is read from grouper-loader.base.properties
## (which should not be edited), and the grouper-loader.properties overlays
## the base settings.  See the grouper-loader.base.properties for the possible
## settings that can be applied to the grouper.properties
########################################

# comma separated config files that override each other (files on the right override the left)
# each should start with file: or classpath:
# e.g. classpath:grouper-loader.example.properties, file:c:/something/myconfig.properties
# {valueType: "string", required: true, multiple: true}
loader.config.hierarchy = classpath:grouper-loader.base.properties, classpath:grouper-loader.properties, database:grouper

# seconds between checking to see if the config files are updated
# {valueType: "integer", required: true}
loader.config.secondsBetweenUpdateChecks = 600

########################################
## General settings
########################################


# auto-add grouper loader types and attributes when grouper starts up if they are not there
# {valueType: "boolean", required: true}
loader.autoadd.typesAttributes = true

# if a transaction should be used when loading groups.  If not, then
# commits will happen as the group is loaded (and memory usage might be
# less intensive, and caching settings need to be set right)
# {valueType: "boolean", required: true}
loader.use.transactions = false

# if should use threads in the loader for add/remove member
# {valueType: "boolean", required: true}
loader.use.membershipThreads=true

# number of threads to use for each group job (not shared among jobs)
# {valueType: "integer", required: true}
loader.membershipThreadPoolSize=10

# if should use threads in the loader for each group in a group of groups
# {valueType: "boolean", required: true}
loader.use.groupThreads=true

# number of threads to use for each list of groups job (not shared among jobs)
# {valueType: "integer", required: true}
loader.groupThreadPoolSize=20

# if should use threads in incremental loader jobs
# {valueType: "boolean", required: true}
loader.incrementalThreads=true

# number of threads to use in incremental loader jobs (not shared among jobs)
# {valueType: "integer", required: true}
loader.incrementalThreadPoolSize=10

# number of days to retain db logs in table grouperloader_log.  -1 is forever.  default is 7
# {valueType: "integer", required: true}
loader.retain.db.logs.days=7

# number of days to retain db rows in grouper_change_log_entry.  -1 is forever.  default is 14
# {valueType: "integer", required: true}
loader.retain.db.change_log_entry.days=14

# if daemon should remove old values which are multi-assigned if the attribute is single valued
# {valueType: "boolean", required: true}
loader.removeMultiAttributeValuesIfSingleValuedAttribute = true

# if daemon should remove old values which are multi-assigned if the attribute is single valued.
# there are some exceptions (e.g. usdu) which will not be log only
# {valueType: "boolean", required: true}
loader.removeMultiAttributeValuesIfSingleValuedAttributeLogOnly = true

# if daemon should remove old assignments which are multi-assigned if the attribute is single assign
# {valueType: "boolean", required: true}
loader.removeMultiAttributeAssignIfSingleAssignAttribute = true

# if daemon should remove old assignments which are multi-assigned if the attribute is single assign.
# there are some exceptions (e.g. usdu) which will not be log only
# {valueType: "boolean", required: true}
loader.removeMultiAttributeAssignIfSingleAssignAttributeLogOnly = true


# if you want queries which do not specify subject source to come from a certain
# source, specify here (improves performance so it doesnt search through all sources)
# {valueType: "string"}
default.subject.source.id = 

#if using a sql table, and specifying the name like string, then should the group (in addition to memberships)
# be removed if not used anywhere else?
# {valueType: "boolean", required: true}
loader.sqlTable.likeString.removeGroupIfNotUsed = true

# if using a sql table, and specifying the name like string, then should the group be removed even when the group is member of some other group. 
# loader.sqlTable.likeString.removeGroupIfNotUsed has to be true for this to work
# https://bugs.internet2.edu/jira/browse/GRP-1132
# {valueType: "boolean", required: true}
loader.sqlTable.likeString.removeGroupIfMemberOfAnotherGroup = false

# by default the top folder for an ldap group of groups is the folder where the config group lives.
# set to false if you want to be able to provision groups to anywhere
# {valueType: "boolean", required: true}
loader.ldap.requireTopStemAsStemFromConfigGroup = true

# if you dont specify a groupNameExpression, groups will be loaded into this folder
# if this property doesnt exist, it will be groups:    if it is blank, then there is no top level folder
# e.g. loader:groups
# {valueType: "string"}
loader.ldap.defaultGroupFolder = groups:

# Delimiter used in the example edu.internet2.middleware.grouper.app.loader.ldap.LdapResultsTransformationDelimitedValueExample
# {valueType: "string"}
loader.ldap.resultsTransformationDelimitedValueExampleDelimiter = -

# Comma separated list of stems under which the display name changes in stems are allowed.
# eg: loader.allowStemDisplayNameChangesUnderStems=school:courses:english, school:faculty
# {valueType: "stem", multiple: true}
loader.allowStemDisplayNameChangesUnderStems =

# If a job creates or updates a group, and the job parameters do not compute
# a description, true if a blank description is allowed. If false, the description will
# be set to "{groupExtension} auto-created by grouperLoader".
# {valueType: "boolean", required: false}
loader.allowBlankGroupDescriptions = false

# fix include excludes on each run
# {valueType: "boolean", required: true}
loader.fixIncludeExcludes = false

#potentially delete groups that are no longer in the source system
# {valueType: "boolean", required: true}
loader.deleteGroupsNoLongerInSource = false

# if a loader is registered to update the loader log table periodically, do this after this many seconds
# {valueType: "integer", defaultValue: "60"}
loader.otherJobUpdateLoaderLogDbAfterSeconds = 60

# if the loader should log when a subject identifier does not match the grouper
# WARN  GrouperLoaderType.syncOneGroupMembership(3257) -  - Subject xxxxx marked to be 
# added and removed from group a:b:c.  Possible case issue between subject source and loader source.  
# Or loading based on subject identifier and identifier is not cached in Grouper's grouper_members table.
# {valueType: "boolean", required: true}
loader.log.subject.identifier.mismatch = true


############################################
## Auditing lifetimes
############################################

# number of days to retain db rows in grouper_audit_entry with no logged in user (loader, gsh, etc).  -1 is forever.  suggested is 365 or five years: 1825.  Default is -1
# audit entries with no logged in user aren't really all that useful.  There is point in time data still.  So removing these shouldn't be a big deal
# {valueType: "integer", required: true}
loader.retain.db.audit_entry_no_logged_in_user.days=-1

# number of days to retain db rows in grouper_audit_entry.  -1 is forever.  suggested is -1 or ten years: 3650
# Some think its ok to remove all audit entries over 10 (or X) years, but will default this 
# to never since even at large institutions there aren't that many records.  
# These are audits for things people do on the UI or WS generally (as a different to records with no logged in user) 
# {valueType: "integer", required: true}
loader.retain.db.audit_entry.days=-1

# number of days to retain db rows for point in time deleted objects.  -1 is forever.  suggested is 365 or five years: 1825.  Default is -1
# After you delete an object in grouper, it is still in point in time.  So if you want to know who 
# was in a group a year ago, you need this info
# However, after some time it might be ok to let it go.  So the default is 5 years
# {valueType: "integer", required: true}
loader.retain.db.point_in_time_deleted_objects.days=-1

# number of days after a subfolder (directly in a parent folder) is created that it will be obliterated (deleted) 
# and point in time will be deleted too. 
# "courses" or "anotherLabel" are variables you make up in these examples
# This is optional.  You can automatically obliterate folders *directly in a parent folder* that are a certain age old  e.g. courses.
# so you could delete a term of courses 4 years old if you like.  Note, make sure the loader isn't going to recreate or you will get churn
# Note this can also delete the point in time data as well.
# {valueType: "integer", required: true, regex: "^loader\\.retain\\.db\\.folder\\.([^.]+)\\.days$"}
#loader.retain.db.folder.courses.days=1825

# delete old folders in this folder
# {valueType: "stem", required: true, regex: "^loader\\.retain\\.db\\.folder\\.([^.]+)\\.parentFolderName$"}
#loader.retain.db.folder.courses.parentFolderName=my:folder:for:courses

# if also delete point in time for this old folder
# {valueType: "boolean", required: true, regex: "^loader\\.retain\\.db\\.folder\\.([^.]+)\\.deletePointInTime$"}
#loader.retain.db.folder.courses.deletePointInTime=true

# number of days after a subfolder (directly in a parent folder) is created that it will be obliterated (deleted) 
# and point in time will be deleted too. 
# "courses" or "anotherLabel" are variables you make up in these examples
# This is optional.  You can automatically obliterate folders *directly in a parent folder* that are a certain age old  e.g. courses.
# so you could delete a term of courses 4 years old if you like.  Note, make sure the loader isn't going to recreate or you will get churn
# Note this can also delete the point in time data as well.
# {valueType: "integer", required: true, regex: "^loader\\.retain\\.db\\.folder\\.([^.]+)\\.days$"}
#loader.retain.db.folder.anotherLabel.days=1825

# delete old folders in this folder
# {valueType: "stem", required: true, regex: "^loader\\.retain\\.db\\.folder\\.([^.]+)\\.parentFolderName$"}
#loader.retain.db.folder.anotherLabel.parentFolderName=my:folder:for:something

# if also delete point in time for this old folder
# {valueType: "boolean", required: true, regex: "^loader\\.retain\\.db\\.folder\\.([^.]+)\\.deletePointInTime$"}
#loader.retain.db.folder.anotherLabel.deletePointInTime=false



######################################
## Fail-safe 1 - Each individual group
######################################

# if the loader should check to see too many users were removed, if so, then error out and
# wait for manual intervention.  This setting means have global defaults.  If there are local settings
# those will still be used.
# {valueType: "boolean", required: true}
loader.failsafe.use = false

# if a group has a size less than this (default 200), then make changes including blanking it out.
# if -1 then do not have a global default
# {valueType: "integer", required: true}
loader.failsafe.minGroupSize = 200

# if a group with more members than the loader.failsafe.minGroupSize have more than this percent (default 30)  
# removed, then log it as error, fail the job, and don't actually remove the members 
# In order to run the job, an admin would need to change this param in the config, 
# and run the job manually, then change this config back.
# if -1 then do not have a global max percent remove
# {valueType: "integer", required: true}
loader.failsafe.maxPercentRemove = 30

############################################
## Fail-safe 2 - Group list - managed groups
############################################

# For group lists, if groupLikeString is specified, you can use this fail-safe to prevent too
# many groups from having their memberships cleared out because they are managed by the loader
# (i.e. match the groupLikeString) but don't have memberships in the group query.
# {valueType: "boolean", required: true}
loader.failsafe.groupList.managedGroups.use = false

# Only applicable if the number of managed groups (i.e. match the groupLikeString) that have
# members in Grouper before the loader starts is at least this amount.
# {valueType: "integer", required: true}
loader.failsafe.groupList.managedGroups.minManagedGroups = 200

# If the group list meets the criteria above and the percentage of groups that are managed by
# the loader (i.e. match the groupLikeString) that currently have members in Grouper but 
# wouldn't after the job runs is greater than this percentage, then don't remove members,
# log it as an error and fail the job.  An admin would need to approve the failsafe or change this param in the config,
# and run the job manually, then change this config back.
# {valueType: "integer", required: true}
loader.failsafe.groupList.managedGroups.maxPercentGroupsRemove = 30

# This does not work for grouper loader currently.  If the group list meets the criteria above and the 
# percentage of memberships that are managed by
# the loader (i.e. match the groupLikeString) that currently have members in Grouper but 
# wouldn't after the job runs is greater than this percentage, then don't remove members,
# log it as an error and fail the job.  An admin would need to approve the failsafe or change this param in the config,
# and run the job manually, then change this config back.
# {valueType: "integer", required: true}
loader.failsafe.groupList.managedGroups.maxPercentMembershipsRemove = 30

#############################################
## Failsafe emails
#############################################

# if sending email on loader failsafe issues.  Default to true if there are email addresses to send to
# {valueType: "boolean"}
loader.failsafe.sendEmail =

# if sending email on loader failsafe issues then send this these addresses (comma separated)
# mutually exclusive with sendEmailToGroup
# {valueType: "string"}
loader.failsafe.sendEmailToAddresses =

# if sending email on loader failsafe issues then send to members of this group name (id path)
# mutually exclusive with sendEmailToAddresses
# {valueType: "string"}
loader.failsafe.sendEmailToGroup =

# you can use the variables $jobName$
# {valueType: "string"}
loader.failsafe.email.subject = Grouper failsafe caused job to not run: $jobName$

# you can use the variables $newline$, $jobName$, $timestamp$.
# {valueType: "string"}
loader.failsafe.email.body = Hello,$newline$$newline$This is a notification that Grouper job $jobName$ did not run due to a failsafe condition.  Approve the failsafe in the UI if this is expected.$newline$$newline$${edu.internet2.middleware.grouper.cfg.GrouperConfig.retrieveConfig().getGrouperUiUrl(true)}grouperUi/app/UiV2Main.index?operation=UiV2Admin.daemonJobs&daemonJobsFilter=${grouperUtil.escapeUrlEncode(jobName)}$newline$$newline$Timestamp: $timestamp$$newline$$newline$Regards.



#################################
## Performance enhancements
#################################

# if you want to bulk retrieve subjects to add/remove
# {valueType: "boolean", required: true}
loader.bulkLookupSubjects = true

# If the bulk lookup should use lazy subjects to avoid actual subject lookups in the subject source.  This is mainly beneficial if your subject source includes an LDAP.
# {valueType: "boolean", required: true}
loader.bulkLookupSubjectsAsLazySubjects = true

#########################
## Unresolvables
#########################

# If there are unresolvables while loading a group from the source data, the job will still 
# have a result of SUCCESS unless the total membership count (with unresolvables) is 
# greater than or equal to minGroupSize and the percentage of unresolvables is greater than 
# the percent specified, in which case the result will be SUBJECT_PROBLEMS.
# {valueType: "integer", required: true}
loader.unresolvables.minGroupSize = 200

# If there are unresolvables while loading a group from the source data, the job will still 
# have a result of SUCCESS unless the total membership count (with unresolvables) is 
# greater than or equal to minGroupSize and the percentage of unresolvables is greater than 
# the percent specified, in which case the result will be SUBJECT_PROBLEMS.
# {valueType: "integer", required: true}
loader.unresolvables.maxPercentForSuccess = 5


#################################
## DB connections
## specify the db connection with user, pass, url, and driver class
## the string after "db." is the name of the connection, and it should not have
## spaces or other special chars in it
#################################

# specify the db connection with user, pass, url, and driver class
# the string after "db." is the name of the connection, and it should not have
# spaces or other special chars in it. eg: mylogin
# {valueType: "string", required: true, regex: "^db\\.([^.]+)\\.user$"}
# db.warehouse.user =

#note the password can be stored encrypted in an external file
# {valueType: "password", sensitive: true, regex: "^db\\.([^.]+)\\.pass$"}
#db.warehouse.pass =

# url for database connections. eg: jdbc:mysql://localhost:3306/grouper
# {valueType: "string", required: true, regex: "^db\\.([^.]+)\\.url$"}
#db.warehouse.url = 

# note: you probably dont have to enter a driver, it will detect from URL.  If it
# cant detect, then specify it here
# {valueType: "string", regex: "^db\\.([^.]+)\\.driver$"}
#db.warehouse.driver = 

#optional pooling params, these will default to the grouper.hibernate(.base).properties pooling settings. eg: 100
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.max_size$"}
#db.warehouse.c3p0.max_size =

# optional pooling param. eg: 0
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.min_size$"}
#db.warehouse.c3p0.min_size = 

# seconds. eg: 100
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.timeout$"}
#db.warehouse.c3p0.timeout =

# maximum statements. eg: 0
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.max_statements$"}
#db.warehouse.c3p0.max_statements =

# idle test period. eg: 100
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.idle_test_period$"}
#db.warehouse.c3p0.idle_test_period =

# acquire in increments of. eg: 1
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.acquire_increment$"}
#db.warehouse.c3p0.acquire_increment = 

# validate connection
# {valueType: "boolean", regex: "^db\\.([^.]+)\\.c3p0\\.validate$"}
#db.warehouse.c3p0.validate =

# if unreturnedConnectionTimeout is non zero, then if connection takes too long it will be logged as stack
# {valueType: "boolean", regex: "^db\\.([^.]+)\\.c3p0\\.debugUnreturnedConnectionStackTraces$"}
# db.warehouse.c3p0.debugUnreturnedConnectionStackTraces =

# in seconds, if connections are removed from the pool for longer than this, 
# and debugUnreturnedConnectionStackTraces is true, then log the stack of who took the connection (and didnt return it). eg: 30
# {valueType: "integer", regex: "^db\\.([^.]+)\\.c3p0\\.unreturnedConnectionTimeout$"}
# db.warehouse.c3p0.unreturnedConnectionTimeout =

# This defaults to true.  Turn this off if the database does not support or need or has a problem with quoted identifiers
# {valueType: "boolean", regex: "^db\\.([^.]+)\\.useQuotedColumnsInSql$", defaultValue: "true"}
# db.warehouse.useQuotedColumnsInSql =

# Quote to use for columns in SQL.  This defaults to backtic if mysql, and otherwise will be doublequote.
# {valueType: "string", regex: "^db\\.([^.]+)\\.quoteForColumnsInSql$", showEl: "${useQuotedColumnsInSql != null && useQuotedColumnsInSql}"}
# db.warehouse.quoteForColumnsInSql =

# if this database connector is enabled
# {valueType: "boolean", regex: "^db\\.([^.]+)\\.enabled$", defaultValue: "true"}
#db.warehouse.enabled = 

# testQuery to test the connection.  If its a known database type a default query might be known
# {valueType: "string", regex: "^db\\.([^.]+)\\.testQuery$"}
#db.warehouse.testQuery = 

# When testing the connection in the UI, this is the expected value from sql
# {valueType: "string", regex: "^db\\.([^.]+)\\.testExpectedValue$"}
# db.warehouse.testExpectedValue =

# if the db connections should be pooled (this is new as of 2.3.0.patch)
# {valueType: "boolean", required: true}
grouperLoader.db.connections.pool = true

#################################
## LDAP connections
## specify the ldap connection with user, pass, url
## the string after "ldap." is the ID of the connection, and it should not have
## spaces or other special chars in it.  In this case is it "personLdap"
#################################

# specify the ldap connection with user, pass, url
# the string after "ldap." is the ID of the connection, and it should not have
# spaces or other special chars in it.
# note the URL should start with ldap:  or ldaps: if it is SSL.  
# It should contain the server and port (optional if not default), and baseDn, 
# e.g. ldaps://ldapserver.school.edu:636/dc=school,dc=edu
# You might not want to specify the base dn here. If you do then all ldap filters will use this base dn.
# {valueType: "string", required: true, regex: "^ldap\\.([^.]+)\\.url$"}
#ldap.personLdap.url =

# load this ldaptive config file before the configs here.  load from classpath. eg: ldap.personLdap.properties
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.configFileFromClasspath$"}
#ldap.personLdap.configFileFromClasspath =

#optional, if authenticated. eg: uid=someapp,ou=people,dc=myschool,dc=edu
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.user$"}
#ldap.personLdap.user =

#optional, if authenticated, note the password can be stored encrypted in an external file
# {valueType: "password", sensitive: true, regex: "^ldap\\.([^.]+)\\.pass$"}
#ldap.personLdap.pass =

#optional, if you are using tls, set this to true.  Generally you will not be using an SSL URL to use TLS.
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.tls$", defaultValue: "true"}
#ldap.personLdap.tls =

# optional, if this ldap connector is an active directory
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.isActiveDirectory$", defaultValue: "false"}
#ldap.personLdap.isActiveDirectory =

#optional, if using sasl
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.saslAuthorizationId$"}
#ldap.personLdap.saslAuthorizationId = 

#optional, if using sasl
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.saslRealm$"}
#ldap.personLdap.saslRealm = 

# When testing the connection in the UI, this is the search dn, e.g. ou=People,dc=example,dc=edu
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.uiTestSearchDn$"}
# ldap.personLdap.uiTestSearchDn = 

# When testing the connection in the UI, this is the search scope
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.uiTestSearchScope$", formElement: "dropdown", optionValues: ["OBJECT_SCOPE", "ONELEVEL_SCOPE", "SUBTREE_SCOPE"]}
# ldap.personLdap.uiTestSearchScope =

# When testing the connection in the UI, this is the search filter, e.g. (uid=aanderson)
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.uiTestFilter$"}
# ldap.personLdap.uiTestFilter = 

# When testing the connection in the UI, this is the search attribute name, e.g. cn
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.uiTestAttributeName$"}
# ldap.personLdap.uiTestAttributeName = 

# When testing the connection in the UI, this is the search expected value
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.uiTestExpectedValue$"}
# ldap.personLdap.uiTestExpectedValue =


#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.batchSize$"}
#ldap.personLdap.batchSize = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.countLimit$"}
#ldap.personLdap.countLimit = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.timeLimit$"}
#ldap.personLdap.timeLimit = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.timeout$"}
#ldap.personLdap.timeout = 

# if there is a max size limit on ldap server, then this will retrieve results in pages
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.pagedResultsSize$"}
#ldap.personLdap.pagedResultsSize = 

# set to 'follow' if using AD and using paged results size and need this for some reason (generally you shouldnt)
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.referral$"}
#ldap.personLdap.referral = 

# comma-delimited list of classes to process LDAP search results. Useful if AD returns a ranged attribute for large
# groups (e.g., member;range=0-1499); include the GrouperRangeEntryHandler to handle progressive fetching.
# {valueType: "class", mustImplementInterface:"org.ldaptive.handler.Handler", multiple: true, regex: "^ldap\\.([^.]+)\\.searchResultHandlers$"}
#ldap.personLdap.searchResultHandlers=org.ldaptive.handler.DnAttributeEntryHandler,edu.internet2.middleware.grouper.ldap.ldaptive.GrouperRangeEntryHandler

# comma-delimited list of result codes (org.ldaptive.ResultCode) to ignore, e.g. TIME_LIMIT_EXCEEDED, SIZE_LIMIT_EXCEEDED, PARTIAL_RESULTS
# {valueType: "string", multiple: true, regex: "^ldap\\.([^.]+)\\.searchIgnoreResultCodes$"}
#ldap.personLdap.searchIgnoreResultCodes=

# if this ldap connector is enabled
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.enabled$", defaultValue: "true"}
#ldap.personLdap.enabled =

#if want to customize pooling
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.customizePooling$", subSection: "pooling", defaultValue: "false"}
#ldap.personLdap.customizePooling =

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.minPoolSize$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.minPoolSize = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.maxPoolSize$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.maxPoolSize = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.validateOnCheckIn$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.validateOnCheckIn = 

# validateOnCheckOut defaults to true if all other validate methods are false
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.validateOnCheckOut$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.validateOnCheckOut = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "boolean", regex: "^ldap\\.([^.]+)\\.validatePeriodically$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.validatePeriodically = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.validateTimerPeriod$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.validateTimerPeriod = 

#optional (note, time limit is for search operations, timeout is for connection timeouts), 
#most of these default to ldaptive defaults.  times are in millis
# {valueType: "integer", regex: "^ldap\\.([^.]+)\\.pruneTimerPeriod$", subSection: "pooling", showEl: "${customizePooling}"}
#ldap.personLdap.pruneTimerPeriod = 

# validator setup, currently supports CompareLdapValidator and SearchValidator.  additional properties below for CompareLdapValidator.
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.validator$", subSection: "pooling", showEl: "${customizePooling}", formElement: "dropdown", optionValues: ["CompareLdapValidator", "SearchValidator"]}
#ldap.personLdap.validator =

# validator setup, currently supports CompareLdapValidator and SearchValidator.  additional properties below for CompareLdapValidator. eg: ou=people,dc=example,dc=com
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.validatorCompareDn$", subSection: "pooling", showEl: "${customizePooling && validator == 'CompareLdapValidator'}"}
#ldap.personLdap.validatorCompareDn = 

# validator setup, currently supports CompareLdapValidator and SearchValidator.  additional properties below for CompareLdapValidator. eg: ou
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.validatorCompareAttribute$", subSection: "pooling", showEl: "${customizePooling && validator == 'CompareLdapValidator'}"}
#ldap.personLdap.validatorCompareAttribute =

# validator setup, currently supports CompareLdapValidator and SearchValidator.  additional properties below for CompareLdapValidator. eg: people
# {valueType: "string", regex: "^ldap\\.([^.]+)\\.validatorCompareValue$", subSection: "pooling", showEl: "${customizePooling && validator == 'CompareLdapValidator'}"}
#ldap.personLdap.validatorCompareValue =

# set this to true to set the system property: org.ldaptive.response.ENCODE_CNTRL_CHARS for ldaptive, helpful for AD
# https://todos.internet2.edu/browse/GRP-2969
# {valueType: "boolean"}
ldaptiveEncodeControlChars = false

##################################
## LDAP loader settings
##################################

# el classes to add to the el context for the EL to calculate subejct ids or group names etc.  
# Comma-separated fully qualified classnamesm will be registered by the non-fully qualified
# uncapitalized classname.  So you register a.b.SomeClass, it will be available by variable: someClass
# {valueType: "class", multiple: true}
loader.ldap.el.classes = 

##################################
## Daemon logging
## When running the daemon log, do you want to log these various things?
##################################

# overall log for a job
# {valueType: "boolean", required: true}
daemon.log.logEnabled_overallLog = true

# subjob log for a job (e.g. if a job manages a lite of groups)
# {valueType: "boolean", required: true}
daemon.log.logEnabled_subjobLog = true

# groups being created or deleted
# {valueType: "boolean", required: true}
daemon.log.logEnabled_groupManagement = true

# memberships being created or deleted
# {valueType: "boolean", required: true}
daemon.log.logEnabled_membershipManagement = true

# if each logger map should have an id
# {valueType: "boolean", required: true}
daemon.log.logIdsEnabled = false



##################################
## Daily report
##################################
#quartz cron-like schedule for daily grouper report, the default is 7am every day: 0 0 7 * * ? 
#leave blank to disable this
# {valueType: "cron"}
daily.report.quartz.cron = 0 0 7 * * ? 

#comma separated email addresses to email the daily report, e.g. a@b.c, b@c.d
# {valueType: "string", multiple: true}
daily.report.emailTo = 

#if you put a directory here, the daily reports will be saved there, and you can
#link up to a web service or store them or whatever.  e.g. /home/grouper/reports/
# {valueType: "string"}
daily.report.saveInDirectory =

##################################
## enabled / disabled cron
##################################

#quartz cron-like schedule for enabled/disabled daemon.  Note, this has nothing to do with the changelog
#leave blank to disable this, the default is 5 seconds after every minute: 5 * * * * ? 
# {valueType: "cron"}
changeLog.enabledDisabled.quartz.cron = 5 * * * * ?

# seconds between re-querying upcoming updates and caching
# {valueType: "integer", required: true}
changeLog.enabledDisabled.queryIntervalInSeconds = 3600

##################################
## clean logs
##################################

#quartz cron-like schedule for clean logs daemon.
# {valueType: "cron", defaultValue: "0 0 6 * * ?"}
changeLog.cleanLogs.quartz.cron = 0 0 6 * * ?

##################################
## grouper builtin messaging cleanup cron
##################################

#quartz cron-like schedule for grouper messaging daemon.
#leave blank to disable this, the default is every hour, 10 minutes after the hour 
#this daemon does cleanup on the builtin messaging table
# {valueType: "cron"}
changeLog.builtinMessagingDaemon.quartz.cron = 0 10 * * * ?

# after three days of not consuming messages, delete them, if -1, dont run this daemon
# {valueType: "integer", required: true}
grouper.builtin.messaging.deleteAllMessagesMoreThanHoursOld = 72

# after three hours of having processed messages, delete them.  Note, if this is -1 just delete when marking processed
# {valueType: "integer", required: true}
grouper.builtin.messaging.deleteProcessedMessagesMoreThanMinutesOld = 180





##################################
## Change log
##################################

# should the change log temp to change log daemon run?  Note, this should be true
# {valueType: "boolean", defaultValue: "true"}
changeLog.changeLogTempToChangeLog.enable = true

#quartz cron-like schedule for change log temp to change log daemon, the default is 50 seconds after every minute: 50 * * * * ?
# {valueType: "cron"}
changeLog.changeLogTempToChangeLog.quartz.cron = 

# The max number of change log temp changes for the change log temp to change log daemon to retrieve at one time
# {valueType: "integer", required: true}
changeLog.changeLogTempToChangeLogQuerySize = 1000

# The max number of changes to send to a change log consumer at one time
# {valueType: "integer", required: true}
changeLog.changeLogConsumerBatchSize = 1000

# Should the change log include flattened memberships?  
# {valueType: "boolean", required: true}
changeLog.includeFlattenedMemberships = true

# Should the change log include flattened privileges?  
# {valueType: "boolean", required: true}
changeLog.includeFlattenedPrivileges = true

# Should the change log include roles that have had permission changes?  
# {valueType: "boolean", required: true}
changeLog.includeRolesWithPermissionChanges = false

# Should the change log include subjects that have had permission changes?
# {valueType: "boolean", required: true}
changeLog.includeSubjectsWithPermissionChanges = false

# Should the change log include non-flattened (immediate and composite only) memberships?
# {valueType: "boolean", required: true}
changeLog.includeNonFlattenedMemberships = false

# Should the change log include non-flattened (immediate only) privileges?
# {valueType: "boolean", required: true}
changeLog.includeNonFlattenedPrivileges = false

# Once the number of change log updates exceeds this value, the transaction will commit and a new one will be created
# {valueType: "integer", required: true}
changeLog.tooManyChangeLogUpdatesSize = 10000


##################################
## Change log consumers
##################################

# specify the consumers here.  specify the consumer name after the changeLog.consumer. part.  This example is "printTest"
# but it could be "myConsumerName" e.g. changeLog.consumer.myConsumerName.class
# the class must extend edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase
# note see Impl below
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
# changeLog.consumer.printTest.class = edu.internet2.middleware.grouper.changeLog.consumer.PrintTest

# the quartz cron is a cron-like string.  it defaults to every minute on the minute (since the temp to change log job runs
# at 10 seconds to each minute).  it defaults to this: 0 * * * * ?
# though it will stagger each one by 2 seconds.  You can leave this blank
# {valueType: "cron"}
# changeLog.consumer.printTest.quartzCron = 

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
# changeLog.consumer.printTest.changeLogConsumerBatchSize =

# rules consumer, needed for some of the Grouper rule types to run (e.g. flattenedMembershipRemove, flattenedMembershipAdd)
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.grouperRules.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.RuleConsumer

# rules consumer, needed for some of the Grouper rule types to run (e.g. flattenedMembershipRemove, flattenedMembershipAdd)
# {valueType: "cron"}
changeLog.consumer.grouperRules.quartzCron =

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.grouperRules.changeLogConsumerBatchSize =

# consumer for syncing groups to other groupers
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.syncGroups.class = edu.internet2.middleware.grouper.client.GroupSyncConsumer

# consumer for syncing groups to other groupers
# {valueType: "cron"}
changeLog.consumer.syncGroups.quartzCron =

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.syncGroups.changeLogConsumerBatchSize =

# recent-memberships consumer will update recent-membership groups as memberships/attributes change
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.recentMemberships.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# recent-memberships runs as change log consumer
# {valueType: "cron"}
changeLog.consumer.recentMemberships.quartzCron = 

# if this many records happens in one change log session, just do a full loader job
# {valueType: "integer", defaultValue: "100"}
changeLog.consumer.recentMemberships.maxUntilFullSync = 100

# publishing class for recent-memberships
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.recentMemberships.publisher.class = edu.internet2.middleware.grouper.app.serviceLifecycle.GrouperRecentMembershipsChangeLogConsumer

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.recentMemberships.changeLogConsumerBatchSize =

# Object Type Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.grouperObjectTypeIncremental.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.grouperObjectTypeIncremental.publisher.class = edu.internet2.middleware.grouper.app.grouperTypes.GrouperObjectTypesEsbListener

# object type incremental runs as change log consumer
# {valueType: "cron"}
changeLog.consumer.grouperObjectTypeIncremental.quartzCron = 0 * * * * ?

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.grouperObjectTypeIncremental.changeLogConsumerBatchSize =

# Attestation Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.grouperAttestationIncremental.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.grouperAttestationIncremental.publisher.class = edu.internet2.middleware.grouper.app.attestation.GrouperAttestationEsbListener

# attestation incremental runs as change log consumer
# {valueType: "cron"}
changeLog.consumer.grouperAttestationIncremental.quartzCron = 0 * * * * ?

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.grouperAttestationIncremental.changeLogConsumerBatchSize =

# Deprovisioning Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.grouperDeprovisioningIncremental.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.grouperDeprovisioningIncremental.publisher.class = edu.internet2.middleware.grouper.app.deprovisioning.GrouperDeprovisioningEsbListener

# deprovisioning incremental runs as change log consumer
# {valueType: "cron"}
changeLog.consumer.grouperDeprovisioningIncremental.quartzCron = 0 * * * * ?

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.grouperDeprovisioningIncremental.changeLogConsumerBatchSize =


# find bad memberships consumer will fix membership issues soon after they occur
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.findBadMemberships.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# find bad memberships change log consumer
# {valueType: "cron"}
changeLog.consumer.findBadMemberships.quartzCron =

# publishing class for find bad memberships
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.findBadMemberships.publisher.class = edu.internet2.middleware.grouper.misc.FindBadMembershipsChangeLogConsumer

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.findBadMemberships.changeLogConsumerBatchSize =


# recalculate stem view privileges as privileges change
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.stemViewPrivileges.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# recalculate stem view privileges quartz cron
# {valueType: "cron"}
changeLog.consumer.stemViewPrivileges.quartzCron =

# publishing class for find bad memberships
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.stemViewPrivileges.publisher.class = edu.internet2.middleware.grouper.stem.StemViewPrivilegeEsbListener

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to 10000
# {valueType: "integer"}
changeLog.consumer.stemViewPrivileges.changeLogConsumerBatchSize = 10000

# Do a full sync on stem view privileges for applicable users
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.stemViewPrivilegesFull.class = edu.internet2.middleware.grouper.stem.StemViewPrivilegeFullDaemonLogic

# Do a full sync on stem view privileges for applicable users
# {valueType: "cron", required: true}
otherJob.stemViewPrivilegesFull.quartzCron = 32 17 2 * * ?

# Do a full sync on requiring memberships
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.grouperMembershipRequireFull.class = edu.internet2.middleware.grouper.app.membershipRequire.MembershipRequireFullSyncJob

# Do a full sync on requiring memberships
# {valueType: "cron", required: true}
otherJob.grouperMembershipRequireFull.quartzCron = 45 31 1 * * ?

# change log consumer for membership require
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.membershipRequire.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# quartz cron
# {valueType: "cron"}
changeLog.consumer.membershipRequire.quartzCron = 0 * * * * ?

# el filter
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.elfilter$"}
changeLog.consumer.membershipRequire.elfilter = event.eventType eq 'ATTRIBUTE_ASSIGN_ADD' || event.eventType eq 'MEMBERSHIP_DELETE'
          
# publishing class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.membershipRequire.publisher.class = edu.internet2.middleware.grouper.app.membershipRequire.MembershipRequireEsbListener

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
changeLog.consumer.membershipRequire.changeLogConsumerBatchSize =



# change log consumer for membership require
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
changeLog.consumer.sqlCacheGroup.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# quartz cron
# {valueType: "cron"}
changeLog.consumer.sqlCacheGroup.quartzCron = 0 * * * * ?

# el filter
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.elfilter$"}
changeLog.consumer.sqlCacheGroup.elfilter = event.eventType eq 'ATTRIBUTE_ASSIGN_VALUE_ADD' || event.eventType eq 'ATTRIBUTE_ASSIGN_VALUE_DELETE'

# publishing class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
changeLog.consumer.sqlCacheGroup.publisher.class = edu.internet2.middleware.grouper.sqlCache.EsbPublisherSqlCache


##################################
## Change log consumers based in Impl
## Note, you might want to extend: edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBaseImpl
## this is a higher level change log consumer that does a lot of logic for you
## this class will fire certain events for groups and memberships based on tagged folders or groups
## Note, to use this make an attribute and assign it to (generally) folder(s) or some groups or whatever
## GSH:
## GrouperSession grouperSession = GrouperSession.startRootSession();
## AttributeDef provisioningMarkerAttributeDef = new AttributeDefSave(grouperSession).assignCreateParentStemsIfNotExist(true).assignName("attr:someAttrDef").assignToStem(true).assignToGroup(true).save();
## AttributeDefName provisioningMarkerAttributeName = new AttributeDefNameSave(grouperSession, provisioningMarkerAttributeDef).assignName("attr:provisioningMarker").save()
## Stem parentFolder = StemFinder.findByName(grouperSession, "some:folder", true);
## parentFolder.getAttributeDelegate().assignAttribute(provisioningMarkerAttributeName);
##################################


# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBaseImpl"}
# changeLog.consumer.abc.class = edu.internet2.middleware.grouper.changeLog.consumer.PrintChangeLogConsumer

# note: this name matches the attribute name created in the example above
# {valueType: "attributeDefName", regex: "^changeLog\\.consumer\\.([^.]+)\\.syncAttributeName$"}
# changeLog.consumer.abc.syncAttributeName =

# quartz cron of consumer
# {valueType: "cron"}
# changeLog.consumer.abc.quartzCron =

# defaults to true if not configured
# {valueType: "boolean", regex: "^changeLog\\.consumer\\.([^.]+)\\.retryOnError$"}
# changeLog.consumer.abc.retryOnError =

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.abc.changeLogConsumerBatchSize =

##################################
## PSPNG
##################################

# cache the result of the analysis seeing if a group is provisionable
# {valueType: "boolean", defaultValue: "true"}
pspngCacheGroupProvisionable = true

# When getting all provisionable groups, it will do a more efficient way if the provisionable 
# script is the standard one which I think everyone has.  i.e. it knows where provision_to and 
# do_not_provision_to are, so just do the logic in java and in memory
# {valueType: "boolean", defaultValue: "true"}
pspngNonScriptProvisionable = true

# The list of provisionable groups are cached for a number of minutes, 2 should be fine,
# this cache is cleared at the start of each incremental or full sync also
# {valueType: "integer", defaultValue: "1"}
pspngCacheAllGroupProvisionableMinutes = 2

# if pspng should not find group and stem attributes if it doesnt think it need to, false for old behavior
# {valueType: "boolean", defaultValue: "true"}
pspngCacheGroupAndStemAttributes = true

# if the full sync otherJob is running, then dont run the change log for that provisioner for X minutes
# so cached can be fully used and things dont conflict.  After X minutes, allow change log to run and finish
# but then the next change log the next minute, will wait X minutes too
# {valueType: "integer", defaultValue: "10"}
pspngDontRunChangeLogDuringFullSyncForMinutes = 10

##################################
## PSP
##################################

# psp consumer class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.psp.grouper.PspChangeLogConsumer"}
# changeLog.consumer.psp.class = edu.internet2.middleware.psp.grouper.PspChangeLogConsumer

# http://www.quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger
# {valueType: "cron"}
# changeLog.consumer.psp.quartzCron = 0 * * * * ?

# To retry processing a change log entry if an error occurs, set retryOnError to true. Defaults to false.
# {valueType: "boolean", required: true}
# changeLog.consumer.psp.retryOnError = false

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.psp.changeLogConsumerBatchSize =

# To run full provisioning synchronizations periodically, provide the class name which provides a 'public void fullSync()' method.
# {valueType: "class", readOnly: true}
# changeLog.psp.fullSync.class = edu.internet2.middleware.psp.grouper.PspChangeLogConsumer

# Schedule full synchronizations. Defaults to 5 am : 0 0 5 * * ?.
# {valueType: "cron"}
# changeLog.psp.fullSync.quartzCron = 0 0 5 * * ?

# Run a full synchronization job at startup. Defaults to false.
# {valueType: "boolean", required: true}
# changeLog.psp.fullSync.runAtStartup = false

# Omit diff responses from bulk response to conserve memory.
# {valueType: "boolean", required: true}
# changeLog.psp.fullSync.omitDiffResponses = true

# Omit sync responses from bulk response to conserve memory.
# {valueType: "boolean", required: true}
# changeLog.psp.fullSync.omitSyncResponses = true




###################################
## XMPP notifications 
## (note, uncomment the consumer class and cron above)
## this will get grouper ws getMembers rest lite xmp: 
## http://anonsvn.internet2.edu/cgi-bin/viewvc.cgi/i2mi/trunk/grouper-ws/grouper-ws/doc/samples/getMembers/WsSampleGetMembersRestLite_xml.txt?view=log
###################################

# general xmpp configuration
# {valueType: "string"}
xmpp.server.host = jabber.school.edu

# xmpp port
# {valueType: "integer", required: true}
xmpp.server.port = 5222

# xmpp username
# {valueType: "string"}
xmpp.user = username

# note, pass can be in an external file with morphstring
# {valueType: "password", sensitive: true}
xmpp.pass = 

# xmpp resource
# {valueType: "string"}
xmpp.resource = grouperServer

###################################
## Rules config
###################################

# when the rules validations and daemons run.  Leave blank to not run
# {valueType: "cron"}
rules.quartz.cron = 0 0 7 * * ?

#####################################
## Messaging overall settings for daemon jobs
#####################################

# auto create built in queues, topics, privileges
# {valueType: "boolean", required: true}
loader.messaging.settings.autocreate.objects = true


#####################################
## Messaging listener using the messaging API
## note, change "messagingListener" in key to be the name of the listener.  e.g. messaging.listener.myAzureListener.class
## extends edu.internet2.middleware.grouper.messaging.MessagingListenerBase
## note, routingKey property is valid only for rabbitmq. For other messaging systems, it is ignored.
## this listener will just print out messages: edu.internet2.middleware.grouper.messaging.MessagingListenerPrint
#####################################

# messaging listener class
# {valueType: "class", required: true, mustExtendClass: "edu.internet2.middleware.grouper.messaging.MessagingListenerBase", regex: "^messaging\\.listener\\.([^.]+)\\.class$"}
#messaging.listener.messagingListener.class = edu.internet2.middleware.grouper.messaging.MessagingListenerBase

# messaging listener quartz cron
# {valueType: "cron", regex: "^messaging\\.listener\\.([^.]+)\\.quartzCron$"}
#messaging.listener.messagingListener.quartzCron = 0 * * * * ?

# messaging listener messaging system name
# {valueType: "string", regex: "^messaging\\.listener\\.([^.]+)\\.messagingSystemName$"}
#messaging.listener.messagingListener.messagingSystemName = grouperBuiltinMessaging

# messaging listener queue name
# {valueType: "string", regex: "^messaging\\.listener\\.([^.]+)\\.queueName$"}
#messaging.listener.messagingListener.queueName = abc

# messaging listener routing key
# {valueType: "string", regex: "^messaging\\.listener\\.([^.]+)\\.routingKey$"}
#messaging.listener.messagingListener.routingKey =

# messaging listener exchange type. Valid options are DIRECT, HEADERS, TOPIC, FANOUT
# {valueType: "string", regex: "^messaging\\.listener\\.([^.]+)\\.exchangeType$"}
#messaging.listener.messagingListener.exchangeType =

# messaging listener number of tries per iteration
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.numberOfTriesPerIteration$"}
#messaging.listener.messagingListener.numberOfTriesPerIteration = 3

# messaging listener polling timeout seconds
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.pollingTimeoutSeconds$"}
#messaging.listener.messagingListener.pollingTimeoutSeconds = 18

# messaging listener sleep seconds in between iterations
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.sleepSecondsInBetweenIterations$"}
#messaging.listener.messagingListener.sleepSecondsInBetweenIterations = 0

# messaging listener max messages to receive at once
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.maxMessagesToReceiveAtOnce$"}
#messaging.listener.messagingListener.maxMessagesToReceiveAtOnce = 20

# if there are 20 messages to receive at once, then do this 50 times per call max
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.maxOuterLoops$"}
#messaging.listener.messagingListener.maxOuterLoops = 50

#####################################
## Messaging listener using the change log consumer API
#####################################

# note, change "messagingListenerChangeLogConsumer" in key to be the name of the listener.  e.g. messaging.listener.myAzureListener.class
# keep this class to be MessagingListenerToChangeLogConsumer
# {valueType: "class", readOnly: true, required: true, mustExtendClass: "edu.internet2.middleware.grouper.messaging.MessagingListenerToChangeLogConsumer", regex: "^messaging\\.listener\\.([^.]+)\\.class$"}
#messaging.listener.messagingListenerChangeLogConsumer.class = edu.internet2.middleware.grouper.messaging.MessagingListenerToChangeLogConsumer

# Class extends: edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase
# {valueType: "class", required: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase", regex: "^messaging\\.listener\\.([^.]+)\\.changeLogConsumerClass$"}
#messaging.listener.messagingListenerChangeLogConsumer.changeLogConsumerClass = edu.internet2.middleware.grouper.messaging.SomethingExtendsChangeLogConsumerBase

# messaging listener quartz cron
# {valueType: "cron", regex: "^messaging\\.listener\\.([^.]+)\\.quartzCron$"}
#messaging.listener.messagingListenerChangeLogConsumer.quartzCron = 0 * * * * ?

# system name
# {valueType: "string", regex: "^messaging\\.listener\\.([^.]+)\\.messagingSystemName$"}
#messaging.listener.messagingListenerChangeLogConsumer.messagingSystemName = grouperBuiltinMessaging

# queue name in messaging system
# {valueType: "string", regex: "^messaging\\.listener\\.([^.]+)\\.queueName$"}
#messaging.listener.messagingListenerChangeLogConsumer.queueName = abc

# number of tries per iteration
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.numberOfTriesPerIteration$"}
#messaging.listener.messagingListenerChangeLogConsumer.numberOfTriesPerIteration = 3

# polling timeout seconds
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.pollingTimeoutSeconds$"}
#messaging.listener.messagingListenerChangeLogConsumer.pollingTimeoutSeconds = 18

# sleep seconds in between iteration
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.sleepSecondsInBetweenIterations$"}
#messaging.listener.messagingListenerChangeLogConsumer.sleepSecondsInBetweenIterations = 0

# max messages to receive at once
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.maxMessagesToReceiveAtOnce$"}
#messaging.listener.messagingListenerChangeLogConsumer.maxMessagesToReceiveAtOnce = 20

# max outer loops
# if there are 20 messages to receive at once, then do this 50 times per call max
# {valueType: "integer", regex: "^messaging\\.listener\\.([^.]+)\\.maxOuterLoops$"}
#messaging.listener.messagingListenerChangeLogConsumer.maxOuterLoops = 50


#####################################
## Messaging integration with change log, send change log entries to a messaging system
#####################################

# note, change "messaging" in key to be the name of the consumer.  e.g. changeLog.consumer.myAzureConsumer.class
# note, routingKey property is valid only for rabbitmq. For other messaging systems, it is ignored.
# {valueType: "class", required: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerToMessage"}
#changeLog.consumer.messaging.class = edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerToMessage

# quartz cron
# {valueType: "cron"}
#changeLog.consumer.messaging.quartzCron = 0 * * * * ?

# system name
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.messagingSystemName$"}
#changeLog.consumer.messaging.messagingSystemName = grouperBuiltinMessaging

# routing key
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.routingKey$"}
#changeLog.consumer.messaging.routingKey = 

# exchange type. valid options are DIRECT, TOPIC, HEADERS, FANOUT
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.exchangeType$"}
#changeLog.consumer.messaging.exchangeType = 

# queue or topic
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.messageQueueType$"}
#changeLog.consumer.messaging.messageQueueType = queue

# queue or topic name
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.queueOrTopicName$"}
#changeLog.consumer.messaging.queueOrTopicName = abc

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.messaging.changeLogConsumerBatchSize =


#####################################
## Messaging integration with ESB, send change log entries to a messaging system
#####################################

# note, change "messagingEsb" in key to be the name of the consumer.  e.g. changeLog.consumer.myAzureConsumer.class
# note, routingKey property is valid only for rabbitmq. For other messaging systems, it is ignored.
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
#changeLog.consumer.messagingEsb.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# quartz cron
# {valueType: "cron"}
#changeLog.consumer.messagingEsb.quartzCron = 0 * * * * ?

# el filter
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.elfilter$"}
#changeLog.consumer.messagingEsb.elfilter = event.eventType eq 'GROUP_DELETE' || event.eventType eq 'GROUP_ADD' || event.eventType eq 'MEMBERSHIP_DELETE' || event.eventType eq 'MEMBERSHIP_ADD'

# publishing class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbMessagingPublisher"}
#changeLog.consumer.messagingEsb.publisher.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbMessagingPublisher

# messaging system name
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.messagingSystemName$"}
#changeLog.consumer.messagingEsb.publisher.messagingSystemName = grouperBuiltinMessaging

# routing key
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.routingKey$"}
#changeLog.consumer.messagingEsb.publisher.routingKey = 

# EL replacement definition. groupName is the variable for the name of the group. grouperUtil is the class GrouperUtilElSafe can be used for utility methods. 
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.regexRoutingKeyReplacementDefinition$"}
#changeLog.consumer.messagingEsb.regexRoutingKeyReplacementDefinition = ${groupName.replaceFirst('hawaii.edu', 'group.modify').replace(':enrolled', '').replace(':waitlisted', '').replace(':withdrawn', '')}

# replace routing key with periods
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.replaceRoutingKeyColonsWithPeriods$"}
#changeLog.consumer.messagingEsb.replaceRoutingKeyColonsWithPeriods = true

# queue or topic
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.messageQueueType$"}
#changeLog.consumer.messagingEsb.publisher.messageQueueType = queue

# queue or topic name
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.queueOrTopicName$"}
#changeLog.consumer.messagingEsb.publisher.queueOrTopicName = abc

# exchange type for rabbitmq. valid options are DIRECT, TOPIC, HEADERS, FANOUT
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.exchangeType$"}
#changeLog.consumer.messagingEsb.publisher.exchangeType = 

# key for optional extra arguments for rabbitmq. For each key, set up a corresponding value having the same index
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.queueArgs\\.([0-9]+)\\.key$"}
#changeLog.consumer.messagingEsb.publisher.queueArgs.0.key = x-queue-type

# value for optional extra arguments for rabbitmq. Each index should have a corresponding key
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.queueArgs\\.([0-9]+)\\.value$"}
#changeLog.consumer.messagingEsb.publisher.queueArgs.0.value = quorum

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.messagingEsb.changeLogConsumerBatchSize =

#####################################
## ESB integration
#####################################

# quartz cron
# {valueType: "cron"}
#changeLog.consumer.awsJira.quartzCron = 0/15 * * * * ?

# class
# {valueType: "class", readOnly: true, required: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer"}
#changeLog.consumer.awsJira.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# el filter
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.elfilter$"}
#changeLog.consumer.awsJira.elfilter = event.eventType eq 'MEMBERSHIP_ADD' || event.eventType eq 'MEMBERSHIP_ADD'

# if dont send sensitive data
# {valueType: "boolean", regex: "^changeLog\\.consumer\\.([^.]+)\\.noSensitiveData$"}
#changeLog.consumer.awsJira.noSensitiveData = true

# if you want to encrypt messages, set this to an implementation of edu.internet2.middleware.grouperClient.encryption.GcEncryptionInterface
# {valueType: "class", regex: "^changeLog\\.consumer\\.([^.]+)\\.encryptionImplementation$", mustImplementInterface: "edu.internet2.middleware.grouperClient.encryption.GcEncryptionInterface"}
#changeLog.consumer.awsJira.encryptionImplementation = edu.internet2.middleware.grouperClient.encryption.GcSymmetricEncryptAesCbcPkcs5Padding

# this is a key or could be encrypted in a file as well like other passwords
# generate a key with: java -cp grouperClient.jar edu.internet2.middleware.grouperClient.encryption.GcGenerateKey 
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.encryptionKey$"}
#changeLog.consumer.awsJira.encryptionKey = abc123

# if you dont want to send the first 4 of the sha hash base 64 of the secret
# {valueType: "boolean", regex: "^changeLog\\.consumer\\.([^.]+)\\.dontSendShaBase64secretFirst4$"}
#changeLog.consumer.awsJira.dontSendShaBase64secretFirst4 = false

# publisher class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouperAwsChangelog.GrouperAwsEsbPublisher"}
#changeLog.consumer.awsJira.publisher.class = edu.internet2.middleware.grouperAwsChangelog.GrouperAwsEsbPublisher

# aws access key
# {valueType: "password", sensitive: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.awsAccessKey$"}
#changeLog.consumer.awsJira.publisher.awsAccessKey = ABCXYZ

# aws secret key
# {valueType: "password", sensitive: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.awsSecretKey$"}
#changeLog.consumer.awsJira.publisher.awsSecretKey = 123REWQ

# aws region
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.awsRegion$"}
#changeLog.consumer.awsJira.publisher.awsRegion = US_EAST_1

# aws sns topic arn
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.awsSnsTopicArn$"}
#changeLog.consumer.awsJira.publisher.awsSnsTopicArn = arn:aws:sns:us-east-1:123:name

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.awsJira.changeLogConsumerBatchSize =

# quartz cron
# {valueType: "cron"}
#changeLog.consumer.xmppTest.quartzCron = 

# class
# {valueType: "class", readOnly: true, required: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer"}
#changeLog.consumer.xmppTest.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# el filter
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.elfilter$"}
#changeLog.consumer.xmppTest.elfilter = event.eventType eq 'GROUP_DELETE' || event.eventType eq 'GROUP_ADD' || event.eventType eq 'MEMBERSHIP_DELETE' || event.eventType eq 'MEMBERSHIP_ADD'

# publisher class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouperAwsChangelog.GrouperAwsEsbPublisher"}
#changeLog.consumer.xmppTest.publisher.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbXmppPublisher

# publisher server
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.server$"}
#changeLog.consumer.xmppTest.publisher.server = jabber.school.edu

# {valueType: "integer", required: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.port$"}
#changeLog.consumer.xmppTest.publisher.port = 5222

# user name
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.username$"}
#changeLog.consumer.xmppTest.publisher.username = jabberuser

# password
# {valueType: "password", sensitive: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.password$"}
#changeLog.consumer.xmppTest.publisher.password = /home/whatever/pass/jabberuserEncrypted.pass

# recipient
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.recipient$"}
#changeLog.consumer.xmppTest.publisher.recipient = system1@school.edu

# add subject attributes
# {valueType: "string", multiple: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.addSubjectAttributes$"}
#changeLog.consumer.xmppTest.publisher.addSubjectAttributes = NETID

#note, on the content type header, activemq might need: application/x-www-form-urlencoded
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.contentTypeHeader$"}
#changeLog.consumer.xmppTest.publisher.contentTypeHeader = application/json; charset=utf-8

#note, on the stringRequestEntityPrefix, activemq might need: data=
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.stringRequestEntityPrefix$"}
#changeLog.consumer.xmppTest.publisher.stringRequestEntityPrefix = 

#note, on the stringRequestEntityContentType, activemq might need: application/x-www-form-urlencoded
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.stringRequestEntityContentType$"}
#changeLog.consumer.xmppTest.publisher.stringRequestEntityContentType = application/json

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.xmppTest.changeLogConsumerBatchSize =


################################
## Other jobs built-in
## 
## Configure other jobs.
## "jobName" is the name of your job.
## Class must implement org.quartz.Job.
## Priority is optional
##
## For jobs that run by default, you can disable them by setting an empty quartz cron in grouper-loader.properties.
################################

# Find and fix bad memberships class
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.findBadMemberships.class = edu.internet2.middleware.grouper.misc.FindBadMembershipsDaemon

# Find and fix bad memberships cron
# {valueType: "cron", required: true}
otherJob.findBadMemberships.quartzCron = 0 0 1 * * ?

# Find and fix bad groups unique extension in folder
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.findBadGroupsUniqueExtensionInFolder.class = edu.internet2.middleware.grouper.misc.FindBadGroupsUniqueExtensionInFolderDaemon

# Find and fix bad groups unique extension in folder
# {valueType: "cron", required: true}
otherJob.findBadGroupsUniqueExtensionInFolder.quartzCron = 43 15 1 * * ?

# Put in comma separated email addresses to send errors to.  Use a:b:c@grouper to send to a group (email addresses must be configured in the subject source).
# {valueType: "string"}
otherJob.findBadGroupsUniqueExtensionInFolder.mailToOnError = 

# Find and fix PIT data which is missing
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.syncAllPitTables.class = edu.internet2.middleware.grouper.misc.SyncAllPitTablesDaemon

# Find and fix PIT data which is missing cron
# {valueType: "cron", required: true}
otherJob.syncAllPitTables.quartzCron = 17 12 3 * * ?

# Find and fix bad set tables, which are what links up transitive relationships
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.syncAllSetTables.class = edu.internet2.middleware.grouper.misc.SyncAllSetTablesDaemon

# Find and fix bad set tables, which are what links up transitive relationships
# {valueType: "cron", required: true}
otherJob.syncAllSetTables.quartzCron = 17 12 5 * * ?

# Keep the current time in a database independent way
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.timeDaemon.class = edu.internet2.middleware.grouper.app.serviceLifecycle.GrouperTimeDaemon

# Run the time daemon every minute
# {valueType: "cron", required: true}
otherJob.timeDaemon.quartzCron = 45 * * * * ?

# Delete old sync logs
# {valueType: "class", readOnly: true, mustImplementInterface: "org.quartz.Job"}
otherJob.deleteOldSyncLogs.class = edu.internet2.middleware.grouper.app.provisioning.DeleteOldSyncLogsDaemon

# Run the delete old sync logs daemon every minute
# {valueType: "cron", required: true}
otherJob.deleteOldSyncLogs.quartzCron = 39 41 23 * * ?

# Keep entries for this many seconds.  Default to 1 week (604800 seconds).  Set to -1 to keep all (not recommended)
# {valueType: "integer", defaultValue: "604800"}
otherJob.deleteOldSyncLogs.keepEntriesForSeconds = 

# Find and fix scheduler issues class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.schedulerCheckDaemon.class = edu.internet2.middleware.grouper.app.loader.GrouperDaemonSchedulerCheck

# Find and fix scheduler issues cron
# {valueType: "cron", required: true}
otherJob.schedulerCheckDaemon.quartzCron = 25 0/30 * * * ?

# If there hasnt been a success in the last X minutes, then kick this off from thread (not from daemon).  Who is watching the watcher?
# If this is -1, then do not run a watcher thread
# {valueType: "integer", defaultValue: "35"}
otherJob.schedulerCheckDaemon.maxMinutesSinceSuccess = 35

# If there has been a daemon run in the last X minutes, then dont run manually.  -1 to not include.  Note, if maxMinutesSinceSuccess is -1, then
# this config will not be used
# {valueType: "integer", defaultValue: "15"}
otherJob.schedulerCheckDaemon.minMinutesSinceStarted = 15

# Atttestation Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.attestationDaemon.class = edu.internet2.middleware.grouper.app.attestation.GrouperAttestationJob

# Atttestation Job cron
# {valueType: "cron", required: true}
otherJob.attestationDaemon.quartzCron = 0 0 1 * * ?

# Data Provider FullSync Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.grouperDataProviderFullSyncDaemon.class = edu.internet2.middleware.grouper.dataField.GrouperDataProviderFullSyncJob

# Data Provider FullSync config id
# {valueType: "string", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.dataField.DataProviderConfigurationOptionValueDriver"}
# otherJob.grouperDataProviderFullSyncDaemon.dataProviderConfigId =

# Data Provider Full sync Job cron
# {valueType: "cron", required: true}
# otherJob.grouperDataProviderFullSyncDaemon.quartzCron = 0 0 5 * * ?

# Data Provider Incremental Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.grouperDataProviderIncrementalSyncDaemon.class = edu.internet2.middleware.grouper.dataField.GrouperDataProviderIncrementalSyncJob

# Data Provider Incremental config id
# {valueType: "string", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.dataField.DataProviderConfigurationOptionValueDriver"}
# otherJob.grouperDataProviderIncrementalSyncDaemon.dataProviderConfigId =

# Data Provider incremental Job cron
# {valueType: "cron", required: true}
# otherJob.grouperDataProviderIncrementalSyncDaemon.quartzCron = 10 * * * * ?


# Provisioning Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.grouperProvisioningDaemon.class = edu.internet2.middleware.grouper.app.provisioning.GrouperProvisioningJob

# Provisioning Job cron
# {valueType: "cron", required: true}
otherJob.grouperProvisioningDaemon.quartzCron = 0 0 4 * * ?


# Provisioning FullSync Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.grouperProvisioningFullSyncDaemon.class = edu.internet2.middleware.grouper.app.provisioning.GrouperProvisioningFullSyncJob

# Provisioning FullSync provisioner config id 
# {valueType: "string", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningConfigurationOptionValueDriver"}
# otherJob.grouperProvisioningFullSyncDaemon.provisionerConfigId =

# Provisioning Full sync Job cron
# {valueType: "cron", required: true}
# otherJob.grouperProvisioningFullSyncDaemon.quartzCron = 0 0 4 * * ?

# Provisioning Incremental sync Job class
# {valueType: "class", required: true, readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer"}
# changeLog.consumer.grouperProvisioningIncrementalSyncDaemon.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# Provisioning Incremental provisioner config id 
# {valueType: "string", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningConfigurationOptionValueDriver"}
# changeLog.consumer.grouperProvisioningIncrementalSyncDaemon.provisionerConfigId =

# Provisioning Incremental sync Job cron
# {valueType: "cron"}
# changeLog.consumer.grouperProvisioningIncrementalSyncDaemon.quartzCron = 0 * * * * ?

# publisher class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningConsumer"}
# changeLog.consumer.grouperProvisioningIncrementalSyncDaemon.publisher.class = edu.internet2.middleware.grouper.app.provisioning.ProvisioningConsumer

# turns on the changelog consumer debug logging
# {valueType: "boolean", defaultValue: "false"}
# changeLog.consumer.grouperProvisioningIncrementalSyncDaemon.publisher.debug = false

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.grouperProvisioningIncrementalSyncDaemon.changeLogConsumerBatchSize =

# Run upgrade tasks
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.upgradeTasks.class = edu.internet2.middleware.grouper.app.upgradeTasks.UpgradeTasksJob

# Run upgrade tasks cron
# {valueType: "cron", required: true}
otherJob.upgradeTasks.quartzCron = 5 25 * * * ?

# reports clear Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.grouperReportClearDaemon.class = edu.internet2.middleware.grouper.app.reports.GrouperReportClearJob

# reports clear Job cron
# {valueType: "cron", required: true}
otherJob.grouperReportClearDaemon.quartzCron = 0 0 3 * * ?

# Workflow daemon that updates instances and send emails
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.grouperWorkflowDaemon.class = edu.internet2.middleware.grouper.app.workflow.GrouperWorkflowDaemonJob

# Object Type Job cron
# {valueType: "cron", required: true}
otherJob.grouperWorkflowDaemon.quartzCron = 0 0/5 * ? * * *

# Workflow reminder email daemon
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.grouperWorkflowReminderDaemon.class = edu.internet2.middleware.grouper.app.workflow.GrouperWorkflowReminderEmailJob

# Object Type Job cron
# {valueType: "cron", required: true}
otherJob.grouperWorkflowReminderDaemon.quartzCron = 0 0 4 * * ? 

# Grouper password recently used clean up job
# dont have password in name or grouper will think its a secret
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.grouperCredentialRecentlyUsedCleanupDaemon.class = edu.internet2.middleware.grouper.authentication.GrouperPasswordRecentlyUsedCleanupJob

# Grouper password recently used clean up job cron
# dont have password in name or grouper will think its a secret
# {valueType: "cron", required: true}
otherJob.grouperCredentialRecentlyUsedCleanupDaemon.quartzCron = 8 19 * * * ?

# number of entries to keep in the table per grouper password
# dont have password in name or grouper will think its a secret
# {valueType: "integer"}
otherJob.grouperCredentialRecentlyUsedCleanupDaemon.entriesToKeep = 20

# Grouper loader to sync jexl script jobs
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.grouperLoaderJexlScriptFullSync.class = edu.internet2.middleware.grouper.abac.GrouperLoaderJexlScriptFullSync

# Grouper loader to sync jexl script jobs
# {valueType: "cron", required: true}
otherJob.grouperLoaderJexlScriptFullSync.quartzCron = 31 19 * * * ?

################################
## Table sync jobs
## tableSync jobs should use class: edu.internet2.middleware.grouper.app.tableSync.TableSyncOtherJob
## and include a setting to point to the grouperClient config, if not same: otherJob.<otherJobName>.grouperClientTableSyncConfigKey = key
## this is the subtype of job to run: otherJob.<otherJobName>.syncType = fullSyncFull    
## (can be: fullSyncFull, fullSyncGroups, fullSyncChangeFlag, incrementalAllColumns, incrementalPrimaryKey)
################################

# Object Type Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.membershipSync.class = edu.internet2.middleware.grouper.app.tableSync.TableSyncOtherJob

# Object Type Job cron
# {valueType: "cron", required: true}
# otherJob.membershipSync.quartzCron = 0 0/30 * * * ?

# this is the key in the grouper.client.properties that represents this job
# {valueType: "string", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.sqlSync.SqlSyncConfiguration"}
# otherJob.membershipSync.grouperClientTableSyncConfigKey =

# fullSyncFull, fullSyncGroups, fullSyncChangeFlag, incrementalAllColumns, incrementalPrimaryKey
# {valueType: "string", required: true, formElement: "dropdown", optionValues: ["fullSyncFull", "fullSyncGroups", "fullSyncChangeFlag", "incrementalAllColumns", "incrementalPrimaryKey"]}
# otherJob.membershipSync.syncType =



# Object Type Job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.recentMembershipsConfFull.class = edu.internet2.middleware.grouper.app.tableSync.TableSyncOtherJob

# Object Type Job cron, every hour
# {valueType: "cron", required: true}
otherJob.recentMembershipsConfFull.quartzCron = 0 0 * * * ?

# this is the key in the grouper.client.properties that represents this job
# {valueType: "string"}
otherJob.recentMembershipsConfFull.grouperClientTableSyncConfigKey = recentMembershipsConf

# fullSyncFull, fullSyncGroups, fullSyncChangeFlag, incrementalAllColumns, incrementalPrimaryKey
# {valueType: "string"}
otherJob.recentMembershipsConfFull.syncType = fullSyncFull

################################
## USDU
################################


# USDU Job class
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
otherJob.usduDaemon.class = edu.internet2.middleware.grouper.app.usdu.UsduJob

# USDU Job cron
# {valueType: "cron", required: true}
otherJob.usduDaemon.quartzCron = 0 0 1 * * ?

################################
## Other jobs
## 
## Configure other jobs.
## "jobName" is the name of your job.
## Class must implement org.quartz.Job.  Should extend edu.internet2.middleware.grouper.app.loader.OtherJobBase
## Priority is optional
## see edu.internet2.middleware.grouper.app.loader.GrouperLoaderIncrementalJob as an example
##
################################

# other job class
# {valueType: "class", required: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.jobName.class = a.b.c.SomethingThatExtendsOtherJobBase

# other job quartz cron
# {valueType: "cron", required: true}
# otherJob.jobName.quartzCron = 

# other job priority (optional)
# {valueType: "integer", defaultValue: "5"}
# otherJob.jobName.priority =


#####################################
## Message to WS Daemon Job
#####################################

# message to ws daemon job class
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
#otherJob.messageConsumerDaemon.class = edu.internet2.middleware.grouper.app.messaging.MessageConsumerDaemon

# message to ws daemon job cron
# {valueType: "cron", required: true}
#otherJob.messageConsumerDaemon.quartzCron = 0 * * ? * *

# there can be multiple entries, "wsMessagingBridge" is the name of this one, change that for each config section
# the messaging system name must correspond to a messaging system in the grouper.client.properties
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.messagingSystemName$"}
# grouper.messaging.wsMessagingBridge.messagingSystemName = rabbitMqMessaging

# the queue or topic to check
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.messagingSystemName$"}
#grouper.messaging.wsMessagingBridge.queueOrTopicName = sampleWsMessagingQueue

# routingKey is only valid for rabbitmq; for others, it's ignored
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.routingKey$"}
#grouper.messaging.wsMessagingBridge.routingKey = 

# exchangeType is only valid for rabbitmq; for others, it's ignored. Valid options are DIRECT, TOPIC, HEADERS, FANOUT
# {valueType: "string", required: false, regex: "^grouper\\.messaging\\.([^.]+)\\.exchangeType$"}
#grouper.messaging.wsMessagingBridge.exchangeType = 

# if this is a "queue" or "topic", generally it will be queue
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.messageQueueType$"}
#grouper.messaging.wsMessagingBridge.messageQueueType = queue

# the source id of the source of the user to act as
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.actAsSubjectSourceId$"}
#grouper.messaging.wsMessagingBridge.actAsSubjectSourceId = g:isa

# the subject id of the user to act as
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.actAsSubjectId$"}
#grouper.messaging.wsMessagingBridge.actAsSubjectId = GrouperSystem
 
# the long polling seconds, listen to the queue for this many seconds for messages
# {valueType: "integer", required: true, regex: "^grouper\\.messaging\\.([^.]+)\\.longPollingSeconds$"}
#grouper.messaging.wsMessagingBridge.longPollingSeconds = 20

# grouper ws url
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.ws\\.url$"}
#grouper.messaging.wsMessagingBridge.ws.url =

# grouper ws username
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.ws\\.username$"}
#grouper.messaging.wsMessagingBridge.ws.username = 

# grouper ws password
# {valueType: "password", sensitive: true, regex: "^grouper\\.messaging\\.([^.]+)\\.ws\\.password$"}
#grouper.messaging.wsMessagingBridge.ws.password = 

# proxy requests here, e.g. https://server:1234
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.ws\\.proxyUrl$"}
#grouper.messaging.wsMessagingBridge.ws.proxyUrl = 

# socks or http
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.ws\\.proxyType$", formElement: "dropdown", optionValues: ["PROXY_HTTP", "PROXY_SOCKS5"]}
#grouper.messaging.wsMessagingBridge.ws.proxyType = 



# optional queue argument keys for rabbitMQ, number from zero and increase sequentially
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.queueArgs\\.([0-9]+)\\.key$"}
#grouper.messaging.wsMessagingBridge.queueArgs.0.key = x-queue-type

# optional queue argument values for rabbitMQ
# {valueType: "string", regex: "^grouper\\.messaging\\.([^.]+)\\.queueArgs\\.([0-9]+)\\.value$"}
#grouper.messaging.wsMessagingBridge.queueArgs.0.value = quorum

#####################################################
## TIER Instrumentation daemon - send stats to TIER.
#####################################################

# set this to enable the instrumentation
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
otherJob.tierInstrumentationDaemon.class = edu.internet2.middleware.grouper.instrumentation.TierInstrumentationDaemon

# cron string
# {valueType: "cron", required: true}
otherJob.tierInstrumentationDaemon.quartzCron = 0 0 2 * * ?

# proxy requests here, e.g. https://server:1234
# {valueType: "string"}
otherJob.tierInstrumentationDaemon.proxyUrl =

# socks or http
# {valueType: "string", formElement: "dropdown", optionValues: ["PROXY_HTTP", "PROXY_SOCKS5"]}
otherJob.tierInstrumentationDaemon.proxyType = 

# collector url
# {valueType: "string"}
otherJob.tierInstrumentationDaemon.collectorUrl = http://collector.internet2.edu:5001



###############################################################
## Object types full sync daemon - propagates object types
###############################################################

# set this to enable the object types full sync
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
otherJob.objectTypesFullSyncDaemon.class = edu.internet2.middleware.grouper.app.grouperTypes.GrouperObjectTypesDaemonLogic

# cron string
# {valueType: "cron", required: true}
otherJob.objectTypesFullSyncDaemon.quartzCron = 39 17 2 * * ?

###############################################################
## Attestation full sync daemon - propagates attestation attributes
###############################################################

# set this to enable the attestation full sync
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
otherJob.attestationFullSyncDaemon.class = edu.internet2.middleware.grouper.app.attestation.GrouperAttestationDaemonLogic

# cron string
# {valueType: "cron", required: true}
otherJob.attestationFullSyncDaemon.quartzCron = 45 18 2 * * ?

###############################################################
## Deprovisioning full sync daemon - propagates deprovisioning attributes
###############################################################

# set this to enable the deprovisioning full sync
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
otherJob.deprovisioningFullSyncDaemon.class = edu.internet2.middleware.grouper.app.deprovisioning.GrouperDeprovisioningDaemonLogic

# cron string
# {valueType: "cron", required: true}
otherJob.deprovisioningFullSyncDaemon.quartzCron = 50 20 4 * * ?

#####################################################
## Email notifications (e.g. daily)
#####################################################


# set this class to enable the email notification
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.emailNotificationConfigId.class = edu.internet2.middleware.grouper.app.loader.NotificationDaemon

# cron string
# {valueType: "cron", required: true}
# otherJob.emailNotificationConfigId.quartzCron = 0 03 5 * * ?

# is this a notification to each result, or a summary of the results (perhaps printing the list in the email)
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.emailType$", formElement: "dropdown", optionValues: ["notification", "summary"]}
# otherJob.emailNotificationConfigId.emailType = 

# is the population to get the email from a group or from a sql query?
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.populationType$", formElement: "dropdown", optionValues: ["groupMembership", "sqlQuery"]}
# otherJob.emailNotificationConfigId.populationType = 

# group name fully qualified of group which the population should receive the email, or that the summary is about.  e.g. a:b:c
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.emailListGroupName$", showEl: "${populationType == 'groupMembership'}"}
# otherJob.emailNotificationConfigId.emailListGroupName = 

# sql connection id (of your database external systems) that the query runs where the results are the people to send emails to, or that the summary is about.
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.emailListDbConnection$", showEl: "${populationType == 'sqlQuery'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# otherJob.emailNotificationConfigId.emailListDbConnection = 

# sql query where each row represents a subject to send an email to, or a row in the email summary.
# There must be a column of subject_id.  There can optionally be a column email_address_to_send_to if you want to override the subject email address.
# Any other columns will be available for the email body and subject template.
# {valueType: "string", required: true, formElement: "textarea", regex: "^otherJob\\.([^.]+)\\.emailListQuery$", showEl: "${populationType == 'sqlQuery'}"}
# otherJob.emailNotificationConfigId.emailListQuery = 

# If this is a summary type email, then this is group to send email to.  Each member of the group will receive the summary
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.emailSummaryToGroupName$", showEl: "${emailType == 'summary'}"}
# otherJob.emailNotificationConfigId.emailSummaryToGroupName = 

# Only send the summary email if there are records to report on
# {valueType: "boolean", required: true, regex: "^otherJob\\.([^.]+)\\.emailSummaryOnlyIfRecordsExist$", showEl: "${emailType == 'summary'}"}
# otherJob.emailNotificationConfigId.emailSummaryOnlyIfRecordsExist = 

# subject source id of subjects to send emails to (filter subjects from other sources)
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.subjectSourceId$", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.subject.provider.SourceManagerOptionValueDriver"}
# otherJob.emailNotificationConfigId.subjectSourceId = 

# subject of the email.  Note, you can use any variables that the body uses.  This is a jexl template
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.emailSubjectTemplate$"}
# otherJob.emailNotificationConfigId.emailSubjectTemplate = 

# body of the email.  You can use any variables from the query or the subject.  Uses a JEXL template.  e.g. hello ${subject_name},
# subject_name, subject_id, subject_description, subject_attribute_firstname (where "firstname" is a lower case subject attribute key),
# column_some_column_name where "some_column_name" is a lower case column name from query (if applicable).  __NEWLINE__ will substitute
# to a newline.  If this is a summary report, then you can loop over the records to print a line per person.  The JEXL template
# code part starts with two dollar signs: $$ e.g.
# ${size(listOfRecordMaps)}__NEWLINE__$$ for (var recordMap : listOfRecordMaps) {__NEWLINE__  Record subject ID: ${recordMap.get('subject_id')}__NEWLINE__$$}
# {valueType: "string", required: true, formElement: "textarea", regex: "^otherJob\\.([^.]+)\\.emailBodyTemplate$"}
# otherJob.emailNotificationConfigId.emailBodyTemplate = 

# group name of a group that the user will be added to after an email is sent, with a membership attribute with value. 
# Note, this uses the attribute framework with PIT so you probably shouldnt use this "group of people who received emails" 
# for use cases with mass email sending.
# of yyyy/mm/dd (string) of as email sent date
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.lastSentGroupName$"}
# otherJob.emailNotificationConfigId.lastSentGroupName = 

# group name of a group that the user must be in, to be eligible to get emails sent to them, or eligible to be in the summary
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.eligibilityGroupName$"}
# otherJob.emailNotificationConfigId.eligibilityGroupName = 

# email addresses to be emailed as bcc (comma separated)
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.bccsCommaSeparated$"}
# otherJob.emailNotificationConfigId.bccsCommaSeparated = 

# if true then only sent to bcc and the "to" line will be in the email
# only 20 emails will be sent max
# {valueType: "boolean", defaultValue: "false", regex: "^otherJob\\.([^.]+)\\.sendToBccOnly$"}
# otherJob.emailNotificationConfigId.sendToBccOnly = 

#####################################################
## Sync to Grouper from SQL (or Grouper via SQL)
#####################################################

# Set this class to enable the email notification
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.syncToGrouperFromSqlConfigId.class = edu.internet2.middleware.grouper.app.syncToGrouper.SyncToGrouperFromSqlDaemon

# Cron string
# {valueType: "cron", required: true}
# otherJob.syncToGrouperFromSqlConfigId.quartzCron = 0 03 5 * * ?

# Readonly (true to not make changes in Grouper)
# {valueType: "boolean", order: 1000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperReadonly$", required: true}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperReadonly = 

# Debug output
# {valueType: "boolean", order: 2000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperLogOutput$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperLogOutput = 

# Sql connection id (of your database external systems) where the data table is
# {valueType: "string", order: 3000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperDatabaseConfigId$", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperDatabaseConfigId = 

# Sync from another Grouper (true) will auto generate queries that work with Grouper.  Select false to enter in arbitrary SQL queries.
# {valueType: "boolean", order: 4000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperFromAnotherGrouper$", required: true}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperFromAnotherGrouper = 

# Set a schema to point to in the database connection if not connecting as the schema that either owns the objects or has synonyms to them without prefix
# {valueType: "String", order: 5000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperDatabaseSyncFromAnotherGrouperSchema$", showEl: "${sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperDatabaseSyncFromAnotherGrouperSchema = 

# Use SQL metadata to see which columns are available for syncing.  Otherwise specify which columns to sync
# {valueType: "boolean", order: 6000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperAutoconfigureColumns$", required: true}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperAutoconfigureColumns = 

# Specify the top level folders to sync by name comma separated
# {valueType: "string", order: 7000, subSection: "sqlSyncToGrouper", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperTopLevelStems$", required: true, multiple: true}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperTopLevelStems = 

# True to sync folders to Grouper
# {valueType: "boolean", order: 8000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSync$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSync = 

# SQL to get folders from database
# {valueType: "string", formElement: "textarea", order: 9000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSql$", required: true, showEl: "${sqlSyncToGrouperStemSync && !sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSql = 

# Insert folders into Grouper
# {valueType: "boolean", order: 10000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemInsert = 

# Update folders in Grouper
# {valueType: "boolean", order: 11000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemUpdate$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemUpdate = 

# Delete folders in Grouper which are in the "folders to sync" which are not in the other database
# {valueType: "boolean", order: 12000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemDeleteExtra$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemDeleteExtra = 

# Sync folder alternate names from the alternate_name column label
# {valueType: "boolean", order: 13000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSyncFieldAlternateName$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSyncFieldAlternateName = 

# Sync folder descriptions from the description column label
# {valueType: "boolean", order: 14000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSyncFieldDescription$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSyncFieldDescription = 

# Sync folder display names from the display_name column label
# {valueType: "boolean", order: 15000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSyncFieldDisplayName$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSyncFieldDisplayName = 

# Sync folder ID index from the id_index column label
# {valueType: "boolean", order: 16000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSyncFieldIdIndexOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperStemInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSyncFieldIdIndexOnInsert = 

# Sync folder ID (UUID) from the id column label
# {valueType: "boolean", order: 17000, subSection: "sqlSyncToGrouperStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperStemSyncFieldIdOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperStemSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperStemInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperStemSyncFieldIdOnInsert = 

# True to sync groups to Grouper
# {valueType: "boolean", order: 18000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSync$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSync = 

# SQL to get groups from database
# {valueType: "string", formElement: "textarea", order: 19000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSql$", required: true, showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSql = 

# Insert groups into Grouper
# {valueType: "boolean", order: 20000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupInsert = 

# Update groups in Grouper
# {valueType: "boolean", order: 21000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupUpdate$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupUpdate = 

# Delete groups from Grouper
# {valueType: "boolean", order: 22000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupDeleteExtra$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupDeleteExtra = 

# Sync group alternate name from the alternate_name column label
# {valueType: "boolean", order: 23000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldAlternateName$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldAlternateName = 

# Sync group description from the description column label
# {valueType: "boolean", order: 24000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldDescription$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldDescription = 

# Sync group display name from the display_name column label
# {valueType: "boolean", order: 25000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldDisplayName$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldDisplayName = 

# Sync group enabled and disabled dates from the disabled_timestamp and enabled_timestamp column label
# {valueType: "boolean", order: 26000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldEnabledDisabled$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldEnabledDisabled = 

# Sync group ID index from the id_index column label
# {valueType: "boolean", order: 27000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldIdIndexOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperGroupInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldIdIndexOnInsert = 

# Sync group ID from the id column label
# {valueType: "boolean", order: 28000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldIdOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperGroupInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldIdOnInsert = 

# Sync group group type from the type_of_group column label
# {valueType: "boolean", order: 29000, subSection: "sqlSyncToGrouperGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperGroupSyncFieldTypeOfGroup$", defaultValue: "false", showEl: "${sqlSyncToGrouperGroupSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperGroupSyncFieldTypeOfGroup = 

# True to sync composites to Grouper
# {valueType: "boolean", order: 30000, subSection: "sqlSyncToGrouperCompositeSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperCompositeSync$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperCompositeSync = 

# SQL to get composites from database
# {valueType: "string", formElement: "textarea", order: 31000, subSection: "sqlSyncToGrouperCompositeSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperCompositeSql$", required: true, showEl: "${sqlSyncToGrouperCompositeSync && !sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperCompositeSql = 

# Insert composites into Grouper
# {valueType: "boolean", order: 32000, subSection: "sqlSyncToGrouperCompositeSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperCompositeInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperCompositeSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperCompositeInsert = 

# Update composites in Grouper
# {valueType: "boolean", order: 33000, subSection: "sqlSyncToGrouperCompositeSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperCompositeUpdate$", defaultValue: "false", showEl: "${sqlSyncToGrouperCompositeSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperCompositeUpdate = 

# Delete composites in Grouper which are in the "folders to sync" which are not in the other database
# {valueType: "boolean", order: 34000, subSection: "sqlSyncToGrouperCompositeSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperCompositeDeleteExtra$", defaultValue: "false", showEl: "${sqlSyncToGrouperCompositeSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperCompositeDeleteExtra = 

# Sync composite ID (UUID) from the id column label
# {valueType: "boolean", order: 35000, subSection: "sqlSyncToGrouperCompositeSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperCompositeSyncFieldIdOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperCompositeSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperCompositeInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperCompositeSyncFieldIdOnInsert = 

# True to sync memberships to Grouper
# {valueType: "boolean", order: 36000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipSync$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipSync = 

# SQL to get memberships from database
# {valueType: "string", formElement: "textarea", order: 37000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipSql$", required: true, showEl: "${sqlSyncToGrouperMembershipSync && !sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipSql = 

# Insert memberships into Grouper
# {valueType: "boolean", order: 38000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperMembershipSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipInsert = 

# Update memberships in Grouper
# {valueType: "boolean", order: 39000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipUpdate$", defaultValue: "false", showEl: "${sqlSyncToGrouperMembershipSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipUpdate = 

# Delete memberships in Grouper which are in the "memberships to sync" which are not in the other database
# {valueType: "boolean", order: 40000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipDeleteExtra$", defaultValue: "false", showEl: "${sqlSyncToGrouperMembershipSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipDeleteExtra = 

# Sync membership enabled and disabled times from immediate_mship_disabled_time and immediate_mship_enabled_time column labels
# {valueType: "boolean", order: 41000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipSyncFieldsEnabledDisabled$", defaultValue: "false", showEl: "${sqlSyncToGrouperMembershipSync && !sqlSyncToGrouperAutoconfigureColumns}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipSyncFieldsEnabledDisabled = 

# Sync membership ID from the immediate_membership_id column label
# {valueType: "boolean", order: 42000, subSection: "sqlSyncToGrouperMembershipSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperMembershipSyncFieldIdOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperMembershipSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperMembershipInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperMembershipSyncFieldIdOnInsert = 

# True to sync group privileges to Grouper
# {valueType: "boolean", order: 43000, subSection: "sqlSyncToGrouperPrivilegeGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeGroupSync$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeGroupSync = 

# SQL to get group privileges from database
# {valueType: "string", formElement: "textarea", order: 44000, subSection: "sqlSyncToGrouperPrivilegeGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeGroupSql$", required: true, showEl: "${sqlSyncToGrouperPrivilegeGroupSync && !sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeGroupSql = 

# Insert group privileges into Grouper
# {valueType: "boolean", order: 45000, subSection: "sqlSyncToGrouperPrivilegeGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeGroupInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperPrivilegeGroupSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeGroupInsert = 

# Delete group privileges in Grouper which are in the "group privileges to sync" which are not in the other database
# {valueType: "boolean", order: 46000, subSection: "sqlSyncToGrouperPrivilegeGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeGroupDeleteExtra$", defaultValue: "false", showEl: "${sqlSyncToGrouperPrivilegeGroupSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeGroupDeleteExtra = 

# Sync group privilege ID from the immediate_membership_id column label
# {valueType: "boolean", order: 47000, subSection: "sqlSyncToGrouperPrivilegeGroupSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeGroupSyncFieldIdOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperPrivilegeGroupSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperPrivilegeGroupInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeGroupSyncFieldIdOnInsert = 

# True to sync stem privileges to Grouper
# {valueType: "boolean", order: 48000, subSection: "sqlSyncToGrouperPrivilegeStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeStemSync$", defaultValue: "false"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeStemSync = 

# SQL to get stem privileges from database
# {valueType: "string", formElement: "textarea", order: 49000, subSection: "sqlSyncToGrouperPrivilegeStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeStemSql$", required: true, showEl: "${sqlSyncToGrouperPrivilegeStemSync && !sqlSyncToGrouperFromAnotherGrouper}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeStemSql = 

# Insert stem privileges into Grouper
# {valueType: "boolean", order: 50000, subSection: "sqlSyncToGrouperPrivilegeStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeStemInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperPrivilegeStemSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeStemInsert = 

# Delete stem privileges in Grouper which are in the "stem privileges to sync" which are not in the other database
# {valueType: "boolean", order: 51000, subSection: "sqlSyncToGrouperPrivilegeStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeStemDeleteExtra$", defaultValue: "false", showEl: "${sqlSyncToGrouperPrivilegeStemSync}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeStemDeleteExtra = 

# Sync stem privilege ID from the immediate_membership_id column label
# {valueType: "boolean", order: 52000, subSection: "sqlSyncToGrouperPrivilegeStemSync", regex: "^otherJob\\.([^.]+)\\.sqlSyncToGrouperPrivilegeStemSyncFieldIdOnInsert$", defaultValue: "false", showEl: "${sqlSyncToGrouperPrivilegeStemSync && !sqlSyncToGrouperAutoconfigureColumns && sqlSyncToGrouperPrivilegeStemInsert}"}
# otherJob.syncToGrouperFromSqlConfigId.sqlSyncToGrouperPrivilegeStemSyncFieldIdOnInsert = 


#####################################################
## LDAP to SQL sync
#####################################################


# Set this class to enable the email notification
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.ldapToSqlSyncConfigId.class = edu.internet2.middleware.grouper.app.ldapToSql.LdapToSqlSyncDaemon

# Cron string
# {valueType: "cron", required: true}
# otherJob.ldapToSqlSyncConfigId.quartzCron = 0 03 5 * * ?

# Sql connection id (of your database external systems) where the data table is
# {valueType: "string", order: 1000, subSection: "ldapToSqlLdap", regex: "^otherJob\\.([^.]+)\\.ldapSqlLdapConnection$", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.externalSystem.LdapGrouperExternalSystem"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlLdapConnection = 

# Base DN where LDAP filter should search for records, e.g. (&(employeeID=*)(pwdLastSet=*))
# {valueType: "string", order: 2000, subSection: "ldapToSqlLdap", regex: "^otherJob\\.([^.]+)\\.ldapSqlBaseDn$", required: true}
# otherJob.ldapToSqlSyncConfigId.ldapSqlBaseDn = 

# Search scope: OBJECT_SCOPE, ONELEVEL_SCOPE, SUBTREE_SCOPE
# {valueType: "string", order: 3000, subSection: "ldapToSqlLdap", regex: "^otherJob\\.([^.]+)\\.ldapSqlSearchScope$", required: true, formElement: "dropdown", optionValues: ["OBJECT_SCOPE", "ONELEVEL_SCOPE", "SUBTREE_SCOPE"]}
# otherJob.ldapToSqlSyncConfigId.ldapSqlSearchScope = 

# LDAP filter that pulls data back from LDAP
# {valueType: "string", order: 4000, subSection: "ldapToSqlLdap", regex: "^otherJob\\.([^.]+)\\.ldapSqlFilter$", required: true}
# otherJob.ldapToSqlSyncConfigId.ldapSqlFilter = 

# Comma-separated extra attributes if one column has multiple attributes concatenated used in translations
# {valueType: "string", order: 5000, subSection: "ldapToSqlLdap", regex: "^otherJob\\.([^.]+)\\.ldapSqlExtraAttributes$"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlExtraAttributes = 

# Sql connection id (of your database external systems) where the data table is
# {valueType: "string", order: 20000, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlDbConnection$", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlDbConnection = 

# Table name where ldap data should sync to, note you need to prefix the schema if not in the connecting schema
# {valueType: "string", order: 21000, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlTableName$", required: true}
# otherJob.ldapToSqlSyncConfigId.ldapSqlTableName = 

# If there is another table to hold multi-valued attribute values.
# {valueType: "boolean", order: 21200, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlHasMultiValuedTable$", defaultValue: "false"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlHasMultiValuedTable = 

# Table name of table to hold multi-valued attribute values.  The table must have three columns: ldap_id, attribute_name, attribute_value
# {valueType: "string", order: 21200, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlMultiValuedTableName$", required: true, showEl: "${ldapSqlHasMultiValuedTable}"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlMultiValuedTableName = 

# Which column in the main table uniquely identifies each result from the LDAP filter.  You could use DN or another unique identifier.
# {valueType: "string", order: 21400, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlIdColumn$", required: true, showEl: "${ldapSqlHasMultiValuedTable}"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlIdColumn = 

# Which attributes should be stored in the multi-valued attribute table
# {valueType: "string", order: 21600, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlMultiValuedAttributes$", required: true, showEl: "${ldapSqlHasMultiValuedTable}"}
# otherJob.ldapToSqlSyncConfigId.ldapSqlMultiValuedAttributes = 

# Number of attributes and columns
# {valueType: "string", order: 22000, subSection: "ldapToSqlDatabase", regex: "^otherJob\\.([^.]+)\\.ldapSqlNumberOfAttributes$", required: true, formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"]}
# otherJob.ldapToSqlSyncConfigId.ldapSqlNumberOfAttributes = 

# Name of SQL column or use
# {valueType: "string", order: 30000, required: true, showEl: "${ldapSqlNumberOfAttributes > $i$}", repeatGroup: "ldapToSqlAttribute", repeatCount: 30}
# otherJob.ldapToSqlSyncConfigId.ldapSqlAttribute.$i$.sqlColumn =

# If this SQL value direct from LDAP or is it translated
# {valueType: "string", showEl: "${ldapSqlNumberOfAttributes > $i$}", repeatGroup: "ldapToSqlAttribute", repeatCount: 30, required: true, formElement: "dropdown", optionValues: ["ldapAttribute", "translation"]}
# otherJob.ldapToSqlSyncConfigId.ldapSqlAttribute.$i$.ldapTranslationType =

# Name of LDAP attribute or use dn for the distinguishedName.  If the attribute is multi-valued, then there should only be two columns, a single-valued attribute and a multi-valued attribute
# {valueType: "string", showEl: "${ldapSqlNumberOfAttributes > $i$ && ldapSqlAttribute.$i$.ldapTranslationType == 'ldapAttribute'}", required: true, repeatGroup: "ldapToSqlAttribute", repeatCount: 30}
# otherJob.ldapToSqlSyncConfigId.ldapSqlAttribute.$i$.ldapName =

# Enter a translation if there is no ldap attribute or if it needs to be adjusted.  "dn" is a variable, and ldapAttribute__&lt;attributename&gt; (attribute name is lower case).
# All attributes and extraAttributes can be used.  loaderLdapElUtils can be used, and ldapLookup.  e.g. ${ldapAttribute__lastname + ",  + ldapAttribute__firstname}
# {valueType: "string", showEl: "${ldapSqlNumberOfAttributes > $i$ && ldapSqlAttribute.$i$.ldapTranslationType == 'translation'}", required: true, repeatGroup: "ldapToSqlAttribute", repeatCount: 30}
# otherJob.ldapToSqlSyncConfigId.ldapSqlAttribute.$i$.translation =

# If this is the unique or one column in a composite key
# {valueType: "boolean", defaultValue: "false", showEl: "${ldapSqlNumberOfAttributes > $i$}", repeatGroup: "ldapToSqlAttribute", repeatCount: 30}
# otherJob.ldapToSqlSyncConfigId.ldapSqlAttribute.$i$.uniqueKey =


#####################################################
## Script daemons
## "scriptDaemonConfigKey" is the key of the config, change that for your script daemon
#####################################################

# set this to enable the script daemon
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.scriptDaemonConfigKey.class = edu.internet2.middleware.grouper.app.loader.OtherJobScript

# cron string
# {valueType: "cron", required: true}
# otherJob.scriptDaemonConfigKey.quartzCron = 0 38 6 * * ?

# script type.  note: in SQL you should commit after DML commands.
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.scriptType$", formElement: "dropdown", optionValues: ["gsh", "sql"]}
# otherJob.scriptDaemonConfigKey.scriptType = 

# file type, you can run a script in config, or run a file in your container
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.fileType$", formElement: "dropdown", optionValues: ["script", "file"]}
# otherJob.scriptDaemonConfigKey.fileType = 

# source of script
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.scriptSource$", formElement: "textarea", showEl: "${fileType == 'script'}"}
# otherJob.scriptDaemonConfigKey.scriptSource = 

# file name in container to run
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.fileName$", showEl: "${fileType == 'file'}"}
# otherJob.scriptDaemonConfigKey.fileName = 

# if SQL this is the connection name to use
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.connectionName$", showEl: "${scriptType == 'sql'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# otherJob.scriptDaemonConfigKey.connectionName = 

# if this is a lightweight script, i.e. not as many imports
# {valueType: "boolean", regex: "^otherJob\\.([^.]+)\\.lightWeight$", showEl: "${scriptType == 'gsh'}", defaultValue: "false"}
# otherJob.scriptDaemonConfigKey.lightWeight = 


#####################################################
## Change log script daemon
## "changeLogScriptDaemonConfigKey" is the key of the config, change that for your change log script daemon
#####################################################

# set this to enable the script daemon
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.ChangeLogConsumerBase"}
# changeLog.consumer.changeLogScriptDaemonConfigKey.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# cron string
# {valueType: "cron", required: true}
# changeLog.consumer.changeLogScriptDaemonConfigKey.quartzCron = 0 * * * * ?

# el filter, e.g. event.eventType eq 'GROUP_DELETE' || event.eventType eq 'GROUP_ADD' || event.eventType eq 'MEMBERSHIP_DELETE' || event.eventType eq 'MEMBERSHIP_ADD'<br />
# e.g. (event.eventType eq 'MEMBERSHIP_DELETE' || event.eventType eq 'MEMBERSHIP_ADD') &&  (event.groupName =~ '^test\:.*$')
# {valueType: "string", regex: "^changeLog\\.consumer\\.([^.]+)\\.elfilter$"}
# changeLog.consumer.changeLogScriptDaemonConfigKey.elfilter = 

# publishing class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.EsbPublisherChangeLogScript", regex: "^changeLog\\.consumer\\.([^.]+)\\.publisher\\.class$"}
# changeLog.consumer.changeLogScriptDaemonConfigKey.publisher.class = edu.internet2.middleware.grouper.app.loader.EsbPublisherChangeLogScript

# file type, you can run a script in config, or run a file in your container
# {valueType: "string", required: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.changeLogFileType$", formElement: "dropdown", optionValues: ["script", "file"]}
# changeLog.consumer.changeLogScriptDaemonConfigKey.changeLogFileType = 

# source of script
# {valueType: "string", required: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.changeLogScriptSource$", formElement: "textarea", showEl: "${changeLogFileType == 'script'}"}
# changeLog.consumer.changeLogScriptDaemonConfigKey.changeLogScriptSource = 

# file name in container to run
# {valueType: "string", required: true, regex: "^changeLog\\.consumer\\.([^.]+)\\.changeLogFileName$", showEl: "${changeLogFileType == 'file'}"}
# changeLog.consumer.changeLogScriptDaemonConfigKey.changeLogFileName = 

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
#changeLog.consumer.changeLogScriptDaemonConfigKey.changeLogConsumerBatchSize =


#####################################################
## CSV file sftp
## "csvJobId" is the key of the config, change that for your csv file job
#####################################################


# set this to enable the report
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.csvJobId.class = edu.internet2.middleware.grouper.app.reports.GrouperCsvReportJob

# cron string
# {valueType: "cron", required: true}
# otherJob.csvJobId.quartzCron = 0 21 7 * * ?

# query to run
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.csvReport\\.query$"}
# otherJob.csvJobId.csvReport.query = select USER_ID, USER_NAME, EMAIL_ADDRESS, AUTH_TYPE, TITLE, DEPARTMENT, CUSTOM_STRING, DAY_PASS, CUSTOM_STRING2, GROUPS from some_view

# database to hit
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.csvReport\\.database$"}
# otherJob.csvJobId.csvReport.database = pennCommunity

# remove underscores and capitalize headers, go from USER_NAME to UserName
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.csvReport\\.removeUnderscoresAndCapitalizeHeaders$"}
# otherJob.csvJobId.csvReport.removeUnderscoresAndCapitalizeHeaders = false

# fileName, e.g. myFile.csv or /opt/whatever/myFile.csv.  If blank will create a name 
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.csvReport\\.database$"}
# otherJob.csvJobId.csvReport.fileName = MyFile.csv

# sftp config id (from grouper.properties) if sftp'ing this file somewhere, otherwise blank
# https://spaces.at.internet2.edu/display/Grouper/Grouper+Sftp+files
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.csvReport\\.sftp\\.configId$"}
# otherJob.csvJobId.csvReport.sftp.configId = someSftpServer

# remote file to sftp to if sftp'ing
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.csvReport\\.sftp\\.fileNameRemote$"}
# otherJob.csvJobId.csvReport.sftp.fileNameRemote = /data01/whatever/MyFile.csv

# if the file should be deleted from the grouper daemon server after sending it
# {valueType: "boolean", regex: "^otherJob\\.([^.]+)\\.csvReport\\.deleteFile$"}
# otherJob.csvJobId.csvReport.deleteFile = true

#####################################################
## sftp delimited file and sync to SQL table
## "sftpToSqlJobId" is the key of the config, change that for your csv file job
#####################################################

# set this to enable the report
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.sftpToSqlJobId.class = edu.internet2.middleware.grouper.app.sqlSync.GrouperSftpToSqlJob

# cron string
# {valueType: "cron", required: true}
# otherJob.sftpToSqlJobId.quartzCron = 

# sftp config id (from grouper.properties) if sftp'ing this file somewhere, otherwise blank
# https://spaces.at.internet2.edu/display/Grouper/Grouper+Sftp+files
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.sftp\\.configId$", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.file.SftpGrouperExternalSystem"}
# otherJob.sftpToSqlJobId.sftpToSql.sftp.configId = 

# remote file to sftp to if sftp'ing, e.g. /data01/whatever/MyFile.csv
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.sftp\\.fileNameRemote$", required: true}
# otherJob.sftpToSqlJobId.sftpToSql.sftp.fileNameRemote = 

# if it should be an error if the remote file doesnt exist
# {valueType: "boolean", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.ignoreIfRemoteFileDoesNotExist$", defaultValue: "false"}
# otherJob.sftpToSqlJobId.sftpToSql.errorIfRemoteFileDoesNotExist =

# if the file should be deleted from the grouper daemon server after sending it
# {valueType: "boolean", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.deleteFile$", defaultValue: "false"}
# otherJob.sftpToSqlJobId.sftpToSql.deleteFile =

# database external system config id to hit, default to "grouper"
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.database$", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# otherJob.sftpToSqlJobId.sftpToSql.database = 

# table to sql to, e.g. some_table.  or you can qualify by schema: some_schema.another_table
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.table$", required: true}
# otherJob.sftpToSqlJobId.sftpToSql.table = 

# comma separated columns to sync to, e.g. col1, col2, col3
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.columns$", required: true}
# otherJob.sftpToSqlJobId.sftpToSql.columns = 

# comma separated primary key columns, e.g. col1
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.columnsPrimaryKey$", required: true}
# otherJob.sftpToSqlJobId.sftpToSql.columnsPrimaryKey = 

# if there is a header row
# {valueType: "boolean", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.hasHeaderRow$", defaultValue: "false"}
# otherJob.sftpToSqlJobId.sftpToSql.hasHeaderRow = 

# separator in file
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.separator$", required: true}
# otherJob.sftpToSqlJobId.sftpToSql.separator = 

# escaped separator (cannot contain separator)
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.sftpToSql\\.escapedSeparator$"}
# otherJob.sftpToSqlJobId.sftpToSql.escapedSeparator = 



############################
## Incremental loader jobs
############################

# incremental loader job class
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.GrouperLoaderIncrementalJob"}
# otherJob.incrementalLoader1.class = edu.internet2.middleware.grouper.app.loader.GrouperLoaderIncrementalJob

# incremental loader job cron
# {valueType: "cron", required: true}
# otherJob.incrementalLoader1.quartzCron = 0 * * * * ?

# incremental loader job database name
# {valueType: "string", regex: "^otherJob.([^.]+).databaseName$"}
# otherJob.incrementalLoader1.databaseName=warehouse

# incremental loader job table name
# {valueType: "string", regex: "^otherJob.([^.]+).tableName$"}
# otherJob.incrementalLoader1.tableName=myincrementaltable

# incremental loader full sync threshold
# If there are more than this many changes for a single loader job, then invoke the full sync instead.  This could improve performance but also handle fail safe which isn't part of the incremental sync.
# {valueType: "integer", regex: "^otherJob.([^.]+).fullSyncThreshold$"}
# otherJob.incrementalLoader1.fullSyncThreshold=100

# whether subject lookups in the data source should be case insensitive.  only applicable for sql loader jobs.  note, if true, for some databases (e.g. oracle), you may need a function based index in your data source for the function "lower" for better performance
# {valueType: "boolean", regex: "^otherJob.([^.]+).caseInsensitiveSubjectLookupsInDataSource$"}
# otherJob.incrementalLoader1.caseInsensitiveSubjectLookupsInDataSource=false


#############
## Quartz settings
#############

# quartz schedule instance name
# {valueType: "string", required: true}
org.quartz.scheduler.instanceName = DefaultQuartzScheduler

# quartz scheduler instnace id
# {valueType: "string", required: true}
org.quartz.scheduler.instanceId = AUTO

# quartz scheduler rmi export
# {valueType: "boolean", required: true}
org.quartz.scheduler.rmi.export = false

# quartz scheduler rmi proxy
# {valueType: "boolean", required: true}
org.quartz.scheduler.rmi.proxy = false

# quartz scheduler wrap job executiong transaction
# {valueType: "boolean", required: true}
org.quartz.scheduler.wrapJobExecutionInUserTransaction = false

# quartz scheduler thread pool class
# {valueType: "class", required: true, mustImplementInterface: "org.quartz.spi.ThreadPool"}
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool

# quartz scheduler thread count
# {valueType: "integer", required: true}
org.quartz.threadPool.threadCount = 10

# quartz scheduler thread priority
# {valueType: "integer", required: true}
org.quartz.threadPool.threadPriority = 5

# quartz scheduler threads inherit context class
# {valueType: "boolean", required: true}
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = true

# quartz scheduler misfire threshold
# {valueType: "integer", required: true}
org.quartz.jobStore.misfireThreshold = 60000

# quartz scheduler jobstore class
# {valueType: "class", required: true, mustImplementInterface: "org.quartz.spi.JobStore"}
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX

# quartz scheduler data source
# {valueType: "string"}
org.quartz.jobStore.dataSource = myDS

# quartz scheduler table prefix
# {valueType: "string"}
org.quartz.jobStore.tablePrefix = grouper_QZ_

# quartz scheduler is clustered
# {valueType: "boolean", required: true}
org.quartz.jobStore.isClustered = true

# quartz scheduler check in interval
# {valueType: "integer", required: true}
org.quartz.jobStore.clusterCheckinInterval = 20000

# automatically determined but can override
# {valueType: "class"}
org.quartz.jobStore.driverDelegateClass =

# get connections from grouper's database pool
# {valueType: "class"}
org.quartz.dataSource.myDS.connectionProvider.class = edu.internet2.middleware.grouper.app.loader.GrouperQuartzConnectionProvider

# Quartz seems to have issues where sometimes a job is running twice at the same time, usually after a misfire.
# We have our own check to make sure jobs don't overlap based on data in the grouper_loader_log table if a job's status is STARTED.
# However, if the daemon is killed, it may be stuck on the STARTED state until the row is deleted.  So we'll consider a job's
# STARTED state to be invalid if it hasn't been updated in the number of seconds below.
# {valueType: "integer", required: true}
loader.assumeJobKilledIfNoUpdateInSeconds=300

#############
## Provisioning and sync settings
#############

# delete metadata information about things not provisioned anymore and removed from target (default 1 week)
# {valueType: "integer"}
grouper.provisioning.removeSyncRowsAfterSecondsOutOfTarget = 604800

# If there are this number of memberships or more for a single provisionable group, then perform a "group sync" instead of the individual operations instead, for efficiency
# {valueType: "integer", defaultValue: "500"}
provisionerDefault.membershipsConvertToGroupSyncThreshold =

# If there are this number of memberships or more for a single provisionable group, then perform a "group sync" instead of the individual operations instead, for efficiency
# {valueType: "integer", defaultValue: "500"}
provisionerDefault.membershipsConvertToGroupSyncThreshold =

# In incremental processing, each provisionable group/entity to sync memberships counts as 10, 
# each provisionable membership to sync counts as 1.  If the total score is more than this number, 
# it will convert the incrementals to a a full sync.  e.g. 10000 individual memberships to sync 
# (and not more than 500 in a single group), or 1000 groups to sync, or a combination. 
# -1 means do not convert to full sync.  This is an overridable default.  Each provisioner can override.
# {valueType: "integer", defaultValue: "10000"}
provisionerDefault.scoreConvertToFullSyncThreshold =

# Remove sync log rows after a certain number of days
# {valueType: "integer"}
grouper.provisioning.removeSyncLogRowsAfterDays = 7


#######################################
## common provisioner settings
#######################################

# start with
# {valueType: "string", required: false, readOnly: true, order: 10}
# provisioner.genericProvisioner.startWith = this is start with read only

# have entity attributes that are not in the subject source?
# {valueType: "boolean", order: 402, defaultValue: "false", subSection: "entityAttributes"}
# provisioner.genericProvisioner.entityResolver.entityAttributesNotInSubjectSource =

# Resolve attributes with SQL
# {valueType: "boolean", order: 404, defaultValue: "false", subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource}"}
# provisioner.genericProvisioner.entityResolver.resolveAttributesWithSQL =

# Use global SQL resolver
# {valueType: "boolean", order: 406, indent: 1, defaultValue: "false", subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.entityResolver.useGlobalSQLResolver =

# Global SQL resolver
# {valueType: "string", order: 408, indent: 2, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && entityResolver.useGlobalSQLResolver}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.attr.resolver.SqlGlobalAttributeResolverOptionValueDriver"}
# provisioner.genericProvisioner.entityResolver.globalSQLResolver = 

# SQL config id
# {valueType: "string", order: 410, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# provisioner.genericProvisioner.entityResolver.sqlConfigId =

# Table or view name
# {valueType: "string", order: 412, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}"}
# provisioner.genericProvisioner.entityResolver.tableOrViewName =

# Comma separated column names from the entity attributes table that need to be added as attributes in the target system
# {valueType: "string", order: 413, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}"}
# provisioner.genericProvisioner.entityResolver.columnNames =  

# Subject source id column
# {valueType: "string", order: 414, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.subject.provider.SourceManagerOptionValueDriver"}
# provisioner.genericProvisioner.entityResolver.subjectSourceIdColumn =

# Subject search / matching column
# {valueType: "string", order: 416, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}"}
# provisioner.genericProvisioner.entityResolver.subjectSearchMatchingColumn = 

# SQL mapping type
# {valueType: "string", order: 418, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}", formElement: "dropdown", optionValues: ["entityAttribute", "translation"]}
# provisioner.genericProvisioner.entityResolver.sqlMappingType =

# SQL mapping entity attribute
# {valueType: "string", order: 420, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver && entityResolver.sqlMappingType == 'entityAttribute' }", formElement: "dropdown", optionValues: ['subjectId', 'subjectIdentifer0']}
# provisioner.genericProvisioner.entityResolver.sqlMappingEntityAttribute =

# SQL mapping expression
# {valueType: "string", order: 422, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver && entityResolver.sqlMappingType == 'translation' }"}
# provisioner.genericProvisioner.entityResolver.sqlMappingExpression =

# Last updated column
# {valueType: "string", order: 424, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}"}
# provisioner.genericProvisioner.entityResolver.lastUpdatedColumn =

# Last updated type
# {valueType: "string", order: 426, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL && !entityResolver.useGlobalSQLResolver}", formElement: "dropdown", optionValues: ["timestamp", "millisSince1970"]}
# provisioner.genericProvisioner.entityResolver.lastUpdatedType =

# Select all SQL on full
# {valueType: "boolean", order: 428, indent: 1, defaultValue: "true", subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.entityResolver.selectAllSQLOnFull =

# Resolve attributes with LDAP
# {valueType: "boolean", order: 430, defaultValue: "false", subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource}"}
# provisioner.genericProvisioner.entityResolver.resolveAttributesWithLDAP =

# Use global LDAP resolver
# {valueType: "boolean", order: 432, indent: 1, defaultValue: "false", subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP}"}
# provisioner.genericProvisioner.entityResolver.useGlobalLDAPResolver =

# Global LDAP resolver
# {valueType: "string", order: 434, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && entityResolver.useGlobalLDAPResolver}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.attr.resolver.LdapGlobalAttributeResolverOptionValueDriver"}
# provisioner.genericProvisioner.entityResolver.globalLDAPResolver = 

# LDAP config id
# {valueType: "string", order: 436, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.externalSystem.LdapGrouperExternalSystem"}
# provisioner.genericProvisioner.entityResolver.ldapConfigId = 

# Base DN
# {valueType: "string", order: 438, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}"}
# provisioner.genericProvisioner.entityResolver.baseDN = 

# Subject source id of subjects
# {valueType: "string", order: 439, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.subject.provider.SourceManagerOptionValueDriver"}
# provisioner.genericProvisioner.entityResolver.subjectSourceId =

# Search scope
# {valueType: "string", order: 440, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}", formElement: "dropdown", optionValues: ['ONELEVEL_SCOPE', 'SUBTREE_SCOPE']}
# provisioner.genericProvisioner.entityResolver.searchScope = 

# Filter part
# {valueType: "string", order: 442, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}"}
# provisioner.genericProvisioner.entityResolver.filterPart =

# Attributes
# {valueType: "string", order: 444, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}"}
# provisioner.genericProvisioner.entityResolver.attributes =

# Attributes
# {valueType: "string", order: 444, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}"}
# provisioner.genericProvisioner.entityResolver.multiValuedLdapAttributes = 

# LDAP matching / search attribute
# {valueType: "string", order: 446, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}"}
# provisioner.genericProvisioner.entityResolver.ldapMatchingSearchAttribute =

# LDAP mapping type
# {valueType: "string", order: 448, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}", formElement: "dropdown", optionValues: ["entityAttribute", "translation"]}
# provisioner.genericProvisioner.entityResolver.ldapMappingType =

# LDAP mapping entity attribute
# {valueType: "string", order: 450, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver && entityResolver.ldapMappingType == 'entityAttribute'}", formElement: "dropdown", optionValues: ['subjectId', 'subjectIdentifier0', 'subjectIdentifier1', 'subjectIdentifier2']}
# provisioner.genericProvisioner.entityResolver.ldapMappingEntityAttribute =

# LDAP matching expression
# {valueType: "string", order: 452, indent: 1, required: true, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver && entityResolver.ldapMappingType == 'translation'}"}
# provisioner.genericProvisioner.entityResolver.ldapMatchingExpression =

# Filter all LDAP on full
# {valueType: "boolean", order: 454, indent: 1, defaultValue: "true", subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP}"}
# provisioner.genericProvisioner.entityResolver.filterAllLDAPOnFull =

# Last updated attribute
# {valueType: "string", order: 456, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}"}
# provisioner.genericProvisioner.entityResolver.lastUpdatedAttribute =

# LDAP last updated format
# {valueType: "string", order: 458, indent: 1, subSection: "entityAttributes", showEl: "${entityResolver.entityAttributesNotInSubjectSource && entityResolver.resolveAttributesWithLDAP && !entityResolver.useGlobalLDAPResolver}", formElement: "dropdown", optionValues: ["default", "activeDirectory"]}
# provisioner.genericProvisioner.entityResolver.lastUpdatedFormat =

# have group resolver attributes
# {valueType: "boolean", order: 460, defaultValue: "false", subSection: "groupAttributes"}
# provisioner.genericProvisioner.groupResolver.groupResolverAttributes =

# Resolve attributes with SQL
# {valueType: "boolean", order: 461, defaultValue: "false", subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes}"}
# provisioner.genericProvisioner.groupResolver.resolveAttributesWithSQL =

# SQL config id
# {valueType: "string", order: 462, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# provisioner.genericProvisioner.groupResolver.sqlConfigId =

# Table or view name
# {valueType: "string", order: 463, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.groupResolver.tableOrViewName =

# Table structure
# {valueType: "string", order: 464, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}", formElement: "dropdown", optionValues: ["columnsAreAttributes", "attributeNameInColumnValue"]}
# provisioner.genericProvisioner.groupResolver.tableStructure =

# Comma separated column names from the group attributes table
# {valueType: "string", order: 465, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL && groupResolver.tableStructure == 'columnsAreAttributes'}"}
# provisioner.genericProvisioner.groupResolver.columnNames =  

# attribute name column name
# {valueType: "string", order: 466, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL && groupResolver.tableStructure == 'attributeNameInColumnValue'}"}
# provisioner.genericProvisioner.groupResolver.attributeNameColumnName = 

# attribute value column name
# {valueType: "string", order: 467, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL && groupResolver.tableStructure == 'attributeNameInColumnValue'}"}
# provisioner.genericProvisioner.groupResolver.attributeValueColumnName = 

# group search/matching column, the value matches the group name
# {valueType: "string", order: 468, indent: 1, required: true, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.groupResolver.groupMatchingColumn = 

# Last updated column
# {valueType: "string", order: 469, indent: 1, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.groupResolver.lastUpdatedColumn =

# Last updated type
# {valueType: "string", order: 470, indent: 1, subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}", formElement: "dropdown", optionValues: ["timestamp", "millisSince1970"]}
# provisioner.genericProvisioner.groupResolver.lastUpdatedType =

# Select all SQL on full
# {valueType: "boolean", order: 472, indent: 1, defaultValue: "true", subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.groupResolver.selectAllSQLOnFull =


# When an attribute last updated is detected to need processing during an incremental sync, should the memberships of the group be recalculated or just the group 
# {valueType: "boolean", order: 475, defaultValue: "false", subSection: "groupAttributes", showEl: "${groupResolver.groupResolverAttributes && groupResolver.resolveAttributesWithSQL}"}
# provisioner.genericProvisioner.groupResolver.recalcMembershipsOnIncremental =

# Operate on grouper memberships
# {valueType: "boolean", order: 500, defaultValue: "false", subSection: "membership"}
# provisioner.genericProvisioner.operateOnGrouperMemberships =

# groupAttributes: group ldap object has attribute to hold memberships. 
# entityAttributes: user ldap object has attribute to hold memberships
# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", formElement: "dropdown", optionValues: ["groupAttributes", "entityAttributes", "membershipObjects"]}
# provisioner.genericProvisioner.provisioningType =

# If CRUD should be customized, otherwise SELECT INSERT DELETE_IF_GROUPER_CREATED_THEN_DELETED
# {valueType: "boolean", order: 1250, defaultValue: "false", subSection: "membership", showEl: "${operateOnGrouperMemberships}"}
# provisioner.genericProvisioner.customizeMembershipCrud =

# Select memberships
# {valueType: "boolean", order: 1500, indent: 1, defaultValue: "true", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud}"}
# provisioner.genericProvisioner.selectMemberships =

# Insert memberships
# {valueType: "boolean", order: 2500, indent: 1, defaultValue: "true", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud}"}
# provisioner.genericProvisioner.insertMemberships =

# Replace memberships
# {valueType: "boolean", order: 2550, indent: 1, defaultValue: "false", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud}"}
# provisioner.genericProvisioner.replaceMemberships =

# Delete memberships
# {valueType: "boolean", order: 3500, indent: 1, defaultValue: "true", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud}"}
# provisioner.genericProvisioner.deleteMemberships =

# Delete memberships if not exist in grouper
# {valueType: "boolean", order: 4500, indent: 2, defaultValue: "false", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud && deleteMemberships}"}
# provisioner.genericProvisioner.deleteMembershipsIfNotExistInGrouper =

# Delete value if managed by grouper
# {valueType: "boolean", order: 4550, indent: 2, defaultValue: "false", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud && deleteMemberships && (provisioningType == 'groupAttributes' || provisioningType == 'entityAttributes')}"}
# provisioner.genericProvisioner.deleteValueIfManagedByGrouper =

# Delete memberships only in tracked groups
# {valueType: "boolean", order: 4600, indent: 2, defaultValue: "true", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud && deleteMemberships && deleteMembershipsIfNotExistInGrouper && !deleteValueIfManagedByGrouper}"}
# provisioner.genericProvisioner.deleteMembershipsOnlyInTrackedGroups = 

# Delete memberships if deleted in grouper
# {valueType: "boolean", order: 5500, indent: 2, defaultValue: "false", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud && deleteMemberships && !deleteMembershipsIfNotExistInGrouper && !deleteValueIfManagedByGrouper}"}
# provisioner.genericProvisioner.deleteMembershipsIfGrouperDeleted =

# Delete memberships if created in grouper
# {valueType: "boolean", order: 5600, indent: 2, defaultValue: "true", subSection: "membership", showEl: "${operateOnGrouperMemberships && customizeMembershipCrud && deleteMemberships && !deleteMembershipsIfNotExistInGrouper && !deleteMembershipsIfGrouperDeleted && !deleteValueIfManagedByGrouper}"}
# provisioner.genericProvisioner.deleteMembershipsIfGrouperCreated =

# Advanced options, note, there might not be any
# {valueType: "boolean", order: 5625, defaultValue: "false", subSection: "membership", showEl: "${operateOnGrouperMemberships}"}
# provisioner.genericProvisioner.membershipAdvancedOptions =

# Operate on grouper groups
# {valueType: "boolean", order: 7500, defaultValue: "false", subSection: "group"}
# provisioner.genericProvisioner.operateOnGrouperGroups =

# If CRUD should be customized, otherwise SELECT INSERT UPDATE DELETE_IF_GROUPER_CREATED_THEN_DELETED
# {valueType: "boolean", order: 8000, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups}"}
# provisioner.genericProvisioner.customizeGroupCrud =

# Select groups
# {valueType: "boolean", order: 8500, indent: 1, defaultValue: "true", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud}"}
# provisioner.genericProvisioner.selectGroups =

# Insert groups
# {valueType: "boolean", order: 9000, indent: 1, subSection: "group", defaultValue: "true", showEl: "${operateOnGrouperGroups && customizeGroupCrud}"}
# provisioner.genericProvisioner.insertGroups =

# Delete groups
# {valueType: "boolean", order: 9500, indent: 1, defaultValue: "true", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud}"}
# provisioner.genericProvisioner.deleteGroups =

# Delete groups if not exist in grouper
# {valueType: "boolean", order: 10000, indent: 2, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud && deleteGroups}"}
# provisioner.genericProvisioner.deleteGroupsIfNotExistInGrouper =

# Delete groups if deleted in grouper
# {valueType: "boolean", order: 10500, indent: 2, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud && deleteGroups && deleteGroupsIfNotExistInGrouper == false}"}
# provisioner.genericProvisioner.deleteGroupsIfGrouperDeleted =

# Delete groups if not exist in grouper
# {valueType: "boolean", order: 10600, indent: 2, defaultValue: "true", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud && deleteGroups && deleteGroupsIfNotExistInGrouper == false && deleteGroupsIfGrouperDeleted == false}"}
# provisioner.genericProvisioner.deleteGroupsIfGrouperCreated =

# Delete groups if not exist in grouper
# {valueType: "boolean", order: 10800, indent: 2, defaultValue: "true", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud && deleteGroups && (deleteGroupsIfNotExistInGrouper == true || deleteGroupsIfGrouperDeleted == true || deleteGroupsIfGrouperCreated == true)}"}
# provisioner.genericProvisioner.deleteGroupsIfUnmarkedProvisionable =

# Update groups
# {valueType: "boolean", order: 11500, indent: 1, defaultValue: "true", subSection: "group", showEl: "${operateOnGrouperGroups && customizeGroupCrud}"}
# provisioner.genericProvisioner.updateGroups =

# Select all groups
# {valueType: "boolean", order: 11750, defaultValue: "true", subSection: "group", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups)}"}
# provisioner.genericProvisioner.selectAllGroups =

# if the groups need to be resolved in target
# {valueType: "boolean", defaultValue: "false", subSection: "group", showEl:"${operateOnGrouperGroups && selectGroups}", order: 12000}
# provisioner.genericProvisioner.hasTargetGroupLink =

# number of attributes for target groups
# {valueType: "integer", order: 19999, subSection: "group", defaultValue: "0", showEl:"${operateOnGrouperGroups}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.genericProvisioner.numberOfGroupAttributes =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.name =

# Translate type
# {valueType: "string", order: 21200, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["grouperProvisioningGroupField", "staticValues", "translationScript"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateExpressionType =

# Translate from field
# {valueType: "string", order: 21400, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.translateExpressionType == 'grouperProvisioningGroupField'}", formElement: "dropdown", optionValues: ["description", "displayExtension", "displayName", "extension", "groupAttributeValueCache0", "groupAttributeValueCache1", "groupAttributeValueCache2", "groupAttributeValueCache3", "id", "idIndex", "idIndexString", "name"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateFromGrouperProvisioningGroupField =

# Translate from static values
# {valueType: "string", order: 21600, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.translateExpressionType == 'staticValues'}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateFromStaticValues =

# Translate expression
# {valueType: "string", order: 21800, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.translateExpressionType == 'translationScript'}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateExpression =

# Check for nulls in script
# {valueType: "boolean", order: 21850, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.translateExpressionType == 'translationScript'}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", order: 21855, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.translateExpressionType == 'translationScript' && targetGroupAttribute.$i$.nullChecksInScript}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translationContinueCondition =

# Advanced options
# {valueType: "boolean", order: 22200, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.showAdvancedAttribute =

# Show group attribute crud
# {valueType: "boolean", order: 22400, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.showAttributeCrud = 

# Select attribute?
# {valueType: "boolean", order: 22500, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (selectGroups == null || selectGroups) && targetGroupAttribute.$i$.showAttributeCrud}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.select =

# Insert attribute?
# {valueType: "boolean", order: 23000, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (insertGroups == null || insertGroups) && targetGroupAttribute.$i$.showAttributeCrud}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.insert =

# Update attribute?
# {valueType: "boolean", order: 24000, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (updateGroups == null || updateGroups) && targetGroupAttribute.$i$.showAttributeCrud}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.update =

# Show group attribute validation
# {valueType: "boolean", order: 25000, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.showAttributeValueSettings =

# Value type
# {valueType: "string", order: 25100, indent: 2, defaultValue: "string", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValueSettings}", formElement: "dropdown", optionValues: ["string", "long", "int"], repeatGroup: "targetGroupAttribute", repeatCount: 20 }
# provisioner.genericProvisioner.targetGroupAttribute.$i$.valueType =

# Multi-valued attribute?
# {valueType: "boolean", order: 25200, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.multiValued =

# Default value if there is not a value
# {valueType: "string", order: 25500, indent: 2, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.defaultValue =

# Ignore this group if this attribute matches any of these values (comma separated)
# {valueType: "string", order: 26000, indent: 2, multiple: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.ignoreIfMatchesValue =

# When searching and matching if case should be considered when comparing grouper and target values
# {valueType: "boolean", order: 26500, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.caseSensitiveCompare =

# Show group attribute validation
# {valueType: "boolean", order: 29200, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.showAttributeValidation =

# unprovisionable if null
# {valueType: "boolean", order: 29225, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValidation}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.unprovisionableIfNull =

# If a value is required to provision this group
# {valueType: "boolean", order: 29250, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValidation}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.required =

# Maximum length of this field to be valid for provisioning
# {valueType: "integer", order: 29500, indent: 2, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValidation}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.maxlength =

# Validate value with jexl to see if valid for provisioning, the variable 'value' represents the current value.  return true if valid and false if invalid
# {valueType: "string", order: 29750, indent: 2, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && targetGroupAttribute.$i$.showAttributeValidation}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.validExpression =

# Translate expression create only type
# {valueType: "string", order: 31300, indent: 1, required: false, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (!customizeGroupCrud || targetGroupAttribute.$i$.insert)}", formElement: "dropdown", optionValues: ["grouperProvisioningGroupField", "staticValues", "translationScript"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateExpressionTypeCreateOnly =

# Translate from field create only
# {valueType: "string", order: 31600, indent: 1, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (!customizeGroupCrud || targetGroupAttribute.$i$.insert) && targetGroupAttribute.$i$.translateExpressionTypeCreateOnly == 'grouperProvisioningGroupField'}", formElement: "dropdown", optionValues: ["description", "displayExtension", "displayName", "extension", "groupAttributeValueCache0", "groupAttributeValueCache1", "groupAttributeValueCache2", "groupAttributeValueCache3", "id", "idIndex", "idIndexString", "name"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateFromGrouperProvisioningGroupFieldCreateOnly =

# Translate from static values create only
# {valueType: "string", order: 31800, indent: 1, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (!customizeGroupCrud || targetGroupAttribute.$i$.insert) && targetGroupAttribute.$i$.translateExpressionTypeCreateOnly == 'staticValues'}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateFromStaticValuesCreateOnly =

# Translate expression create only
# {valueType: "string", order: 32000, indent: 1, required: false, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && targetGroupAttribute.$i$.showAdvancedAttribute && (!customizeGroupCrud || targetGroupAttribute.$i$.insert) && targetGroupAttribute.$i$.translateExpressionTypeCreateOnly == 'translationScript'}", repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetGroupAttribute.$i$.translateExpressionCreateOnly =

# Operate on grouper entities
# {valueType: "boolean", order: 37000, defaultValue: "false", subSection: "entity"}
# provisioner.genericProvisioner.operateOnGrouperEntities =

# (Default), just SELECT entities and do not make changes.  If true (make changes), then SELECT INSERT UPDATE DELETE_IF_GROUPER_CREATED_THEN_DELETED
# {valueType: "boolean", order: 37200, defaultValue: "false", subSection: "entity", showEl: "${operateOnGrouperEntities}"}
# provisioner.genericProvisioner.makeChangesToEntities =

# If CRUD should be customized, otherwise SELECT (if not makeChangesToEntities), or SELECT INSERT UPDATE DELETE_IF_GROUPER_CREATED_THEN_DELETED (if makeChangesToEntities)
# {valueType: "boolean", order: 37300, defaultValue: "false", subSection: "entity", showEl: "${operateOnGrouperEntities}"}
# provisioner.genericProvisioner.customizeEntityCrud =

# Select entities
# {valueType: "boolean", order: 37500, indent: 1, defaultValue: "true", subSection: "entity", showEl: "${operateOnGrouperEntities && customizeEntityCrud}"}
# provisioner.genericProvisioner.selectEntities =

# Insert entities
# {valueType: "boolean", order: 38000, indent: 1, subSection: "entity", defaultValue: "true", showEl: "${operateOnGrouperEntities && customizeEntityCrud && makeChangesToEntities}"}
# provisioner.genericProvisioner.insertEntities =

# Delete entities
# {valueType: "boolean", order: 39000, indent: 1, subSection: "entity", defaultValue: "true", showEl: "${operateOnGrouperEntities && customizeEntityCrud && makeChangesToEntities}"}
# provisioner.genericProvisioner.deleteEntities =

# Delete entities if not exist in grouper
# {valueType: "boolean", order: 39500, indent: 2, defaultValue: "false", subSection: "entity", showEl: "${operateOnGrouperEntities && customizeEntityCrud && makeChangesToEntities && deleteEntities}"}
# provisioner.genericProvisioner.deleteEntitiesIfNotExistInGrouper =

# Delete entities if deleted in grouper
# {valueType: "boolean", order: 40000, indent: 2, defaultValue: "false", subSection: "entity", showEl: "${operateOnGrouperEntities && customizeEntityCrud && makeChangesToEntities && deleteEntities && !deleteEntitiesIfNotExistInGrouper}"}
# provisioner.genericProvisioner.deleteEntitiesIfGrouperDeleted =

# Delete entities if not exist in grouper
# {valueType: "boolean", order: 40100, indent: 2, defaultValue: "true", subSection: "entity", showEl: "${operateOnGrouperEntities && customizeEntityCrud && makeChangesToEntities && deleteEntities && !deleteEntitiesIfNotExistInGrouper && !deleteEntitiesIfGrouperDeleted}"}
# provisioner.genericProvisioner.deleteEntitiesIfGrouperCreated =

# Update entities
# {valueType: "boolean", order: 41000, indent: 1, defaultValue: "true", subSection: "entity", showEl: "${operateOnGrouperEntities && customizeEntityCrud && makeChangesToEntities}"}
# provisioner.genericProvisioner.updateEntities =

# Select all entities
# {valueType: "boolean", order: 42000, required: "true", subSection: "entity", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities)}"}
# provisioner.genericProvisioner.selectAllEntities =

# if the entities need to be resolved in target
# {valueType: "boolean", defaultValue: "false", showEl:"${operateOnGrouperEntities && selectEntities}", order: 53000, subSection: "entity"}
# provisioner.genericProvisioner.hasTargetEntityLink =

# number of attributes for target entities
# {valueType: "integer", order: 59000, subSection: "entity", defaultValue: "0", showEl:"${operateOnGrouperEntities}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.genericProvisioner.numberOfEntityAttributes =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.name =

# Translate type
# {valueType: "string", order: 61100, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["grouperProvisioningEntityField", "staticValues", "translationScript"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateExpressionType =

# Translate from field
# {valueType: "string", order: 61200, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.translateExpressionType == 'grouperProvisioningEntityField'}", formElement: "dropdown", optionValues: ["description", "email", "entityAttributeValueCache0", "entityAttributeValueCache1", "entityAttributeValueCache2", "entityAttributeValueCache3", "id", "memberId", "name", "subjectId", "subjectSourceId", "subjectIdentifier", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2", "idIndex"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateFromGrouperProvisioningEntityField =

# Translate from static values
# {valueType: "string", order: 61300, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.translateExpressionType == 'staticValues'}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateFromStaticValues =

# Translate expression
# {valueType: "string", order: 61400, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.translateExpressionType == 'translationScript'}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateExpression =

# Check for nulls in script
# {valueType: "boolean", order: 61450, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.translateExpressionType == 'translationScript'}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", order: 61455, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.translateExpressionType == 'translationScript' && targetEntityAttribute.$i$.nullChecksInScript}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translationContinueCondition =

# Advanced options
# {valueType: "boolean", order: 61500, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.showAdvancedAttribute =

# Show entity attribute crud
# {valueType: "boolean", order: 62000, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.showAttributeCrud = 

# Select attribute?
# {valueType: "boolean", order: 63000, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && (selectEntities == null || selectEntities) && targetEntityAttribute.$i$.showAttributeCrud}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.select =

# Insert attribute?
# {valueType: "boolean", order: 64000, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && makeChangesToEntities && (insertEntities == null || insertEntities) && targetEntityAttribute.$i$.showAttributeCrud}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.insert =

# Update attribute?
# {valueType: "boolean", order: 65000, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && makeChangesToEntities && (updateEntities == null || updateEntities) && targetEntityAttribute.$i$.showAttributeCrud}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.update =

# Show entity attribute validation
# {valueType: "boolean", order: 67100, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.showAttributeValueSettings =

# Value type
# {valueType: "string", order: 67200, indent: 2, defaultValue: "string", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValueSettings}", formElement: "dropdown", optionValues: ["string", "long", "int"], repeatGroup: "targetEntityAttribute", repeatCount: 20 }
# provisioner.genericProvisioner.targetEntityAttribute.$i$.valueType =

# Multi-valued attribute?
# {valueType: "boolean", order: 67300, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.multiValued =

# Default value if there is not a value
# {valueType: "string", order: 67400, indent: 2, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.defaultValue =

# Ignore entity if this attribute matches any of these values (comma separated)
# {valueType: "string", order: 67500, indent: 2, multiple: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.ignoreIfMatchesValue =

# When searching and matching if case should be considered when comparing grouper and target values
# {valueType: "boolean", order: 68000, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.caseSensitiveCompare =

# Show entity attribute validation
# {valueType: "boolean", order: 69125, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.showAttributeValidation =

# unprovisionable if null
# {valueType: "boolean", order: 69200, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValidation}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.unprovisionableIfNull =

# If a value is required to provision this entity
# {valueType: "boolean", order: 69250, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValidation}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.required =

# Maximum length of this field to be valid for provisioning
# {valueType: "string", order: 69500, indent: 2, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValidation}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.maxlength =

# Validate value with jexl to see if valid for provisioning
# {valueType: "string", order: 69750, indent: 2, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && targetEntityAttribute.$i$.showAttributeValidation}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.validExpression =

# Translate expression create only type
# {valueType: "string", order: 70650, indent: 1, required: false, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && makeChangesToEntities && (!customizeEntityCrud || targetEntityAttribute.$i$.insert)}", formElement: "dropdown", optionValues: ["grouperProvisioningEntityField", "staticValues", "translationScript"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateExpressionTypeCreateOnly =

# Translate from field create only
# {valueType: "string", order: 70750, indent: 1, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && makeChangesToEntities && (!customizeEntityCrud || targetEntityAttribute.$i$.insert) && targetEntityAttribute.$i$.translateExpressionTypeCreateOnly == 'grouperProvisioningEntityField'}", formElement: "dropdown", optionValues: ["description", "email", "entityAttributeValueCache0", "entityAttributeValueCache1", "entityAttributeValueCache2", "entityAttributeValueCache3", "id", "memberId", "name", "subjectId", "subjectSourceId", "subjectIdentifier", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2", "idIndex"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateFromGrouperProvisioningEntityFieldCreateOnly =

# Translate from static values create only
# {valueType: "string", order: 70850, indent: 1, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && makeChangesToEntities && (!customizeEntityCrud || targetEntityAttribute.$i$.insert) && targetEntityAttribute.$i$.translateExpressionTypeCreateOnly == 'staticValues'}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateFromStaticValuesCreateOnly =

# Translate expression create only
# {valueType: "string", order: 72000, indent: 1, required: false, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && targetEntityAttribute.$i$.showAdvancedAttribute && makeChangesToEntities && (!customizeEntityCrud || targetEntityAttribute.$i$.insert) && targetEntityAttribute.$i$.translateExpressionTypeCreateOnly == 'translationScript'}", repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetEntityAttribute.$i$.translateExpressionCreateOnly =

# subject sources to provision
# {valueType: "string", required: true, order: 76000, multiple: true, formElement: "checkbox", checkboxValuesFromClass: "edu.internet2.middleware.grouper.SubjectFinder", subSection: "general2", showEl: "${operateOnGrouperEntities || operateOnGrouperMemberships}"}
# provisioner.genericProvisioner.subjectSourcesToProvision = 

# delete memberships for unprovisionable users
# {valueType: "boolean", defaultValue: "false", order: 76250, subSection: "general2", showEl: "${provisioningType == 'entityAttributes' && deleteMembershipsIfNotExistInGrouper}"}
# provisioner.genericProvisioner.deleteMembershipsForUnprovisionableUsers =

# Advanced options, note, there might not be any
# {valueType: "boolean", order: 76500, defaultValue: "false", subSection: "membership2", showEl: "${operateOnGrouperMemberships}"}
# provisioner.genericProvisioner.membership2AdvancedOptions =

# Matching ID expression
# {valueType: "string", order: 76510, subSection: "membership2", showEl: "${operateOnGrouperMemberships && membership2AdvancedOptions && provisioningType == 'membershipObjects'}"}
# provisioner.genericProvisioner.membershipMatchingIdExpression =

# if provisioning normal memberships or privileges
# {valueType: "string", order: 76520, formElement: "dropdown", subSection: "membership2", showEl: "${operateOnGrouperMemberships && membership2AdvancedOptions}", defaultValue: "members", optionValues: ["members", "read, admin", "update, admin", "admin"]}
# provisioner.genericProvisioner.membershipFields =

# number of attributes for memberships
# {valueType: "integer", order: 76700, subSection: "membership2", defaultValue: "0", showEl:"${operateOnGrouperMemberships && provisioningType == 'membershipObjects'}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.genericProvisioner.numberOfMembershipAttributes =

# Name of the attribute
# {valueType: "string", order: 76710, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.name =

# Translate type
# {valueType: "string", order: 76720, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$}", formElement: "dropdown", optionValues: ["grouperProvisioningGroupField", "grouperProvisioningEntityField", "staticValues", "grouperTargetGroupField", "grouperTargetEntityField", "translationScript"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateExpressionType =

# Translate from field
# {valueType: "string", order: 76734, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'grouperProvisioningGroupField'}", formElement: "dropdown", optionValues: ["id", "idIndex", "idIndexString", "displayExtension", "displayName", "extension", "groupAttributeValueCache0", "groupAttributeValueCache1", "groupAttributeValueCache2", "groupAttributeValueCache3", "name", "description"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromGrouperProvisioningGroupField =

# Translate from field
# {valueType: "string", order: 76738, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'grouperProvisioningEntityField'}", formElement: "dropdown", optionValues: ["description", "email", "entityAttributeValueCache0", "entityAttributeValueCache1", "entityAttributeValueCache2", "entityAttributeValueCache3", "id", "memberId", "name", "subjectId", "subjectSourceId", "subjectIdentifier", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2", "idIndex"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromGrouperProvisioningEntityField =

# Translate from static values
# {valueType: "string", order: 76742, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'staticValues'}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromStaticValues =

# Translate expression
# {valueType: "string", order: 76745, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'translationScript'}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateExpression =

# Translate from target group field
# {valueType: "string", order: 76746, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'grouperTargetGroupField'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromGrouperTargetGroupField =

# Translate from target entity field
# {valueType: "string", order: 76747, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'grouperTargetEntityField'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromGrouperTargetEntityField =

# Check for nulls in script
# {valueType: "boolean", order: 76750, defaultValue: "false", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'translationScript'}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", order: 76755, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.translateExpressionType == 'translationScript' && targetMembershipAttribute.$i$.nullChecksInScript}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translationContinueCondition =

# Advanced options
# {valueType: "boolean", order: 76770, defaultValue: "false", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.showAdvancedAttribute =


# Show membership attribute crud
# {valueType: "boolean", order: 76780, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.showAttributeCrud =


# Select attribute?
# {valueType: "boolean", order: 76785, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (selectMemberships == null || selectMemberships) && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeCrud}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.select =

# Insert attribute?
# {valueType: "boolean", order: 76788, indent: 2, defaultValue: "true", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (insertMemberships == null || insertMemberships) && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeCrud}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.insert =

# Show membership attribute validation
# {valueType: "boolean", order: 76790, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.showAttributeValueSettings =

# Value type
# {valueType: "string", order: 76792, indent: 2, defaultValue: "string", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeValueSettings}", formElement: "dropdown", optionValues: ["string", "long", "int"], repeatGroup: "targetMembershipAttribute", repeatCount: 20 }
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.valueType =

# Ignore this group if this attribute matches any of these values (comma separated)
# {valueType: "string", order: 76794, indent: 2, multiple: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.ignoreIfMatchesValue =

# Default value if there is not a value
# {valueType: "string", order: 76795, indent: 2, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeValueSettings}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.defaultValue =

# Show membership attribute validation
# {valueType: "boolean", order: 76797, indent: 1, defaultValue: "false", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.showAttributeValidation =

# If a value is required to provision this group
# {valueType: "boolean", order: 76799, indent: 2, defaultValue: "false", showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeValidation}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.required =

# Maximum length of this attribute to be valid for provisioning
# {valueType: "integer", order: 76800, indent: 2, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeValidation}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.maxlength =

# Validate value with jexl to see if valid for provisioning, the variable 'value' represents the current value.  return true if valid and false if invalid
# {valueType: "string", order: 76750, indent: 2, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && targetMembershipAttribute.$i$.showAdvancedAttribute && targetMembershipAttribute.$i$.showAttributeValidation}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.validExpression =

# Translate expression create only type
# {valueType: "string", order: 76805, indent: 1, required: false, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (!customizeMembershipCrud || targetMembershipAttribute.$i$.insert) && targetMembershipAttribute.$i$.showAdvancedAttribute}", formElement: "dropdown", optionValues: ["grouperProvisioningGroupField", "grouperProvisioningEntityField", "staticValues", "translationScript"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateExpressionTypeCreateOnly =

# Translate from field create only
# {valueType: "string", order: 76810, indent: 1, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (!customizeMembershipCrud || targetMembershipAttribute.$i$.insert) && targetMembershipAttribute.$i$.translateExpressionTypeCreateOnly == 'grouperProvisioningGroupField' && targetMembershipAttribute.$i$.showAdvancedAttribute}", formElement: "dropdown", optionValues: ["description", "displayExtension", "displayName", "extension", "groupAttributeValueCache0", "groupAttributeValueCache1", "groupAttributeValueCache2", "groupAttributeValueCache3", "id", "idIndex", "idIndexString", "name"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromGrouperProvisioningGroupFieldCreateOnly =

# Translate from field create only
# {valueType: "string", order: 76815, indent: 1, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (!customizeMembershipCrud || targetMembershipAttribute.$i$.insert) && targetMembershipAttribute.$i$.translateExpressionTypeCreateOnly == 'grouperProvisioningEntityField' && targetMembershipAttribute.$i$.showAdvancedAttribute}", formElement: "dropdown", optionValues: ["description", "email", "entityAttributeValueCache0", "entityAttributeValueCache1", "entityAttributeValueCache2", "entityAttributeValueCache3", "id", "memberId", "name", "subjectId", "subjectSourceId", "subjectIdentifier", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2", "idIndex"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromGrouperProvisioningEntityFieldCreateOnly =

# Translate from static values create only
# {valueType: "string", order: 76820, indent: 1, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (!customizeMembershipCrud || targetMembershipAttribute.$i$.insert) && targetMembershipAttribute.$i$.translateExpressionTypeCreateOnly == 'staticValues' && targetMembershipAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateFromStaticValuesCreateOnly =

# Translate expression create only
# {valueType: "string", order: 76825, indent: 1, required: false, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$ && (!customizeMembershipCrud || targetMembershipAttribute.$i$.insert) && targetMembershipAttribute.$i$.translateExpressionTypeCreateOnly == 'translationScript' && targetMembershipAttribute.$i$.showAdvancedAttribute}", repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.genericProvisioner.targetMembershipAttribute.$i$.translateExpressionCreateOnly =

# membership attribute name for groups
# {valueType: "string", required: true, order: 77000, subSection: "group2", showEl: "${operateOnGrouperGroups && provisioningType == 'groupAttributes'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.genericProvisioner.groupMembershipAttributeName = 

# membership attribute value for groups
# {valueType: "string", required: true, order: 77010, subSection: "group2", showEl: "${operateOnGrouperGroups && provisioningType == 'groupAttributes'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityCacheDropdownOptions"}
# provisioner.genericProvisioner.groupMembershipAttributeValue = 

# generally the matching attribute(s) are the same as the search attributes, but they can be different
# {valueType: "boolean", defaultValue: "true", order: 77220, subSection: "group2", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > 0 && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups)}"}
# provisioner.genericProvisioner.groupMatchingAttributeSameAsSearchAttribute = 

# how many group matching attributes
# {valueType: "integer", required: true, order: 77222, subSection: "group2", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > 0 && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups)}", formElement: "dropdown",  optionValues: ["1", "2", "3"] }
# provisioner.genericProvisioner.groupMatchingAttributeCount = 

# group matching attribute 1
# {valueType: "string", required: true, order: 77226, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && groupMatchingAttributeCount >= 1}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions" }
# provisioner.genericProvisioner.groupMatchingAttribute0name = 

# group matching attribute 2
# {valueType: "string", required: true, order: 77230, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && groupMatchingAttributeCount >= 2}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions" }
# provisioner.genericProvisioner.groupMatchingAttribute1name = 

# group matching attribute 3
# {valueType: "string", required: true, order: 77234, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && groupMatchingAttributeCount >= 3}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions" }
# provisioner.genericProvisioner.groupMatchingAttribute2name = 

# how many group search attributes
# {valueType: "integer", required: true, order: 77250, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && !groupMatchingAttributeSameAsSearchAttribute}", formElement: "dropdown",  optionValues: ["1", "2", "3"] }
# provisioner.genericProvisioner.groupSearchAttributeCount = 

# group search attribute 1
# {valueType: "string", required: true, order: 77254, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && !groupMatchingAttributeSameAsSearchAttribute && groupSearchAttributeCount >= 1}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions" }
# provisioner.genericProvisioner.groupSearchAttribute0name = 

# group search attribute 2
# {valueType: "string", required: true, order: 77258, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && !groupMatchingAttributeSameAsSearchAttribute && groupSearchAttributeCount >= 2}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions" }
# provisioner.genericProvisioner.groupSearchAttribute1name = 

# group search attribute 3
# {valueType: "string", required: true, order: 77262, subSection: "group2", showEl: "${operateOnGrouperGroups && (!customizeGroupCrud || selectGroups || insertGroups || updateGroups || deleteGroups) && !groupMatchingAttributeSameAsSearchAttribute && groupSearchAttributeCount >= 3}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions" }
# provisioner.genericProvisioner.groupSearchAttribute2name = 

# Target group link - has groupAttributeValueCache?
# {valueType: "boolean", defaultValue: "false", subSection: "group2", showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > 0}", order: 78001}
# provisioner.genericProvisioner.groupAttributeValueCacheHas =

# Target group link - has groupAttributeValueCache0?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas}", order: 78001}
# provisioner.genericProvisioner.groupAttributeValueCache0has =

# Target group link - groupAttributeValueCache0 source
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache0has}", order: 78002, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.groupAttributeValueCache0source =

# Target group link - groupAttributeValueCache0 type
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache0has}", order: 78004, formElement: "dropdown", optionValues: ["groupAttribute", "translationScript"]}
# provisioner.genericProvisioner.groupAttributeValueCache0type =

# Target group link - groupAttributeValueCache0 groupAttribute
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache0has && groupAttributeValueCache0type == 'groupAttribute'}", order: 78006, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.genericProvisioner.groupAttributeValueCache0groupAttribute =

# Target group link - groupAttributeValueCache0 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache0has && groupAttributeValueCache0type == 'translationScript'}", order: 78008}
# provisioner.genericProvisioner.groupAttributeValueCache0translationScript =

# Target group link - has groupAttributeValueCache1?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas}", order: 78101}
# provisioner.genericProvisioner.groupAttributeValueCache1has =

# Target group link - groupAttributeValueCache1 source
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache1has}", order: 78102, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.groupAttributeValueCache1source =

# Target group link - groupAttributeValueCache1 type
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache1has}", order: 78104, formElement: "dropdown", optionValues: ["groupAttribute", "translationScript"]}
# provisioner.genericProvisioner.groupAttributeValueCache1type =

# Target group link - groupAttributeValueCache1 groupAttribute
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache1has && groupAttributeValueCache1type == 'groupAttribute'}", order: 78106, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.genericProvisioner.groupAttributeValueCache1groupAttribute =

# Target group link - groupAttributeValueCache1 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache1has && groupAttributeValueCache1type == 'translationScript'}", order: 78108}
# provisioner.genericProvisioner.groupAttributeValueCache1translationScript =


# Target group link - has groupAttributeValueCache2?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas}", order: 78201}
# provisioner.genericProvisioner.groupAttributeValueCache2has =

# Target group link - groupAttributeValueCache2 source
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache2has}", order: 78202, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.groupAttributeValueCache2source =

# Target group link - groupAttributeValueCache2 type
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache2has}", order: 78204, formElement: "dropdown", optionValues: ["groupAttribute", "translationScript"]}
# provisioner.genericProvisioner.groupAttributeValueCache2type =

# Target group link - groupAttributeValueCache2 groupAttribute
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache2has && groupAttributeValueCache2type == 'groupAttribute'}", order: 78206, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.genericProvisioner.groupAttributeValueCache2groupAttribute =

# Target group link - groupAttributeValueCache2 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache2has && groupAttributeValueCache2type == 'translationScript'}", order: 78208}
# provisioner.genericProvisioner.groupAttributeValueCache2translationScript =


# Target group link - has groupAttributeValueCache3?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas}", order: 78301}
# provisioner.genericProvisioner.groupAttributeValueCache3has =

# Target group link - groupAttributeValueCache3 source
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache3has}", order: 78302, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.groupAttributeValueCache3source =

# Target group link - groupAttributeValueCache3 type
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache3has}", order: 78304, formElement: "dropdown", optionValues: ["groupAttribute", "translationScript"]}
# provisioner.genericProvisioner.groupAttributeValueCache3type =

# Target group link - groupAttributeValueCache3 groupAttribute
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache3has && groupAttributeValueCache3type == 'groupAttribute'}", order: 78306, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.genericProvisioner.groupAttributeValueCache3groupAttribute =

# Target group link - groupAttributeValueCache3 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "group2", showEl: "${operateOnGrouperGroups && groupAttributeValueCacheHas && groupAttributeValueCache3has && groupAttributeValueCache3type == 'translationScript'}", order: 78308}
# provisioner.genericProvisioner.groupAttributeValueCache3translationScript =


# group section 2 advanced options
# {valueType: "boolean", defaultValue: "false", order: 79800, subSection: "group2", showEl: "${operateOnGrouperGroups}"}
# provisioner.genericProvisioner.group2advanced = 

# groups require members
# {valueType: "boolean", indent: 1, defaultValue: "false", order: 79800, subSection: "group2", showEl: "${operateOnGrouperGroups && group2advanced}"}
# provisioner.genericProvisioner.groupsRequireMembers = 


# membership attribute name for entities
# {valueType: "string", required: true, order: 80100, subSection: "entity2", showEl: "${operateOnGrouperEntities && provisioningType == 'entityAttributes'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.genericProvisioner.entityMembershipAttributeName = 

# membership attribute value for entities
# {valueType: "string", required: true, order: 80101, subSection: "entity2", showEl: "${operateOnGrouperEntities && provisioningType == 'entityAttributes'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupCacheDropdownOptions"}
# provisioner.genericProvisioner.entityMembershipAttributeValue = 

# generally the matching attribute(s) are the same as the search attributes, but they can be different
# {valueType: "boolean", defaultValue: "true", order: 80220, subSection: "entity2", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > 0 &&  (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities)))}"}
# provisioner.genericProvisioner.entityMatchingAttributeSameAsSearchAttribute = 

# how many entity matching attributes
# {valueType: "integer", required: true, order: 80222, subSection: "entity2", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > 0 && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities)))}", formElement: "dropdown",  optionValues: ["1", "2", "3"] }
# provisioner.genericProvisioner.entityMatchingAttributeCount = 

# entity matching attribute 1
# {valueType: "string", required: true, order: 80226, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && entityMatchingAttributeCount >= 1}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions" }
# provisioner.genericProvisioner.entityMatchingAttribute0name = 

# entity matching attribute 2
# {valueType: "string", required: true, order: 80230, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && entityMatchingAttributeCount >= 2}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions" }
# provisioner.genericProvisioner.entityMatchingAttribute1name = 

# entity matching attribute 3
# {valueType: "string", required: true, order: 80234, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && entityMatchingAttributeCount >= 3}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions" }
# provisioner.genericProvisioner.entityMatchingAttribute2name = 

# how many entity search attributes
# {valueType: "integer", required: true, order: 80250, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && !entityMatchingAttributeSameAsSearchAttribute}", formElement: "dropdown",  optionValues: ["1", "2", "3"] }
# provisioner.genericProvisioner.entitySearchAttributeCount = 

# entity search attribute 1
# {valueType: "string", required: true, order: 80254, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && !entityMatchingAttributeSameAsSearchAttribute && entitySearchAttributeCount >= 1}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions" }
# provisioner.genericProvisioner.entitySearchAttribute0name = 

# entity search attribute 2
# {valueType: "string", required: true, order: 80258, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && !entityMatchingAttributeSameAsSearchAttribute && entitySearchAttributeCount >= 2}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions" }
# provisioner.genericProvisioner.entitySearchAttribute1name = 

# entity search attribute 3
# {valueType: "string", required: true, order: 80262, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities || (makeChangesToEntities && (insertEntities || updateEntities || deleteEntities))) && !entityMatchingAttributeSameAsSearchAttribute && entitySearchAttributeCount >= 3}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions" }
# provisioner.genericProvisioner.entitySearchAttribute2name = 


# Target entity link - has entityAttributeValueCache?
# {valueType: "boolean", defaultValue: "false", subSection: "entity2", showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > 0 }", order: 80301}
# provisioner.genericProvisioner.entityAttributeValueCacheHas =

# Target entity link - has entityAttributeValueCache0?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas}", order: 80301}
# provisioner.genericProvisioner.entityAttributeValueCache0has =

# Target entity link - entityAttributeValueCache0 source
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has}", order: 80302, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.entityAttributeValueCache0source =

# Target entity link - entityAttributeValueCache0 type
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has}", order: 80304, formElement: "dropdown", optionValues: ["entityAttribute", "subjectTranslationScript", "translationScript"]}
# provisioner.genericProvisioner.entityAttributeValueCache0type =

# Target entity link - entityAttributeValueCache0 entityAttribute
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has && entityAttributeValueCache0type == 'entityAttribute'}", order: 80306, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.genericProvisioner.entityAttributeValueCache0entityAttribute =

# Target entity link - entityAttributeValueCache0 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has && (entityAttributeValueCache0type == 'translationScript' || entityAttributeValueCache0type == 'subjectTranslationScript')}", order: 80308}
# provisioner.genericProvisioner.entityAttributeValueCache0translationScript =

# Target entity link - Entity attribute value cache 0 auto-USDU.  This should generally be left as the default (true), USDU should update the value of this cache item from the subject source.
# {valueType: "boolean", indent: 2, defaultValue: "true", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has}", order: 80309}
# provisioner.genericProvisioner.entityAttributeValueCache0auto =

# Check for nulls in script
# {valueType: "boolean", order: 80350, subSection: "entity2", defaultValue: "false", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has && entityAttributeValueCache0type == 'subjectTranslationScript'}"}
# provisioner.genericProvisioner.entityAttributeValueCache0nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", subSection: "entity2", order: 80370, showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache0has && entityAttributeValueCache0nullChecksInScript}"}
# provisioner.genericProvisioner.entityAttributeValueCache0translationContinueCondition =

# Target entity link - has entityAttributeValueCache1?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas}", order: 80401}
# provisioner.genericProvisioner.entityAttributeValueCache1has =

# Target entity link - entityAttributeValueCache1 source
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has}", order: 80402, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.entityAttributeValueCache1source =

# Target entity link - entityAttributeValueCache1 type
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has}", order: 80404, formElement: "dropdown", optionValues: ["entityAttribute", "subjectTranslationScript", "translationScript"]}
# provisioner.genericProvisioner.entityAttributeValueCache1type =

# Target entity link - entityAttributeValueCache1 entityAttribute
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has && entityAttributeValueCache1type == 'entityAttribute'}", order: 80406, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.genericProvisioner.entityAttributeValueCache1entityAttribute =

# Target entity link - entityAttributeValueCache1 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has && (entityAttributeValueCache1type == 'translationScript' || entityAttributeValueCache1type == 'subjectTranslationScript')}", order: 80408}
# provisioner.genericProvisioner.entityAttributeValueCache1translationScript =

# Target entity link - Entity attribute value cache 1 auto-USDU.  This should generally be left as the default (true), USDU should update the value of this cache item from the subject source.
# {valueType: "boolean", indent: 2, defaultValue: "true", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has}", order: 80409}
# provisioner.genericProvisioner.entityAttributeValueCache1auto =

# Check for nulls in script
# {valueType: "boolean", order: 80450, subSection: "entity2", defaultValue: "false", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has && entityAttributeValueCache1type == 'subjectTranslationScript'}"}
# provisioner.genericProvisioner.entityAttributeValueCache1nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", order: 80470, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache1has && entityAttributeValueCache1nullChecksInScript}"}
# provisioner.genericProvisioner.entityAttributeValueCache1translationContinueCondition =


# Target entity link - has entityAttributeValueCache2?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas}", order: 80501}
# provisioner.genericProvisioner.entityAttributeValueCache2has =

# Target entity link - entityAttributeValueCache2 source
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has}", order: 80502, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.entityAttributeValueCache2source =

# Target entity link - entityAttributeValueCache2 type
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has}", order: 80504, formElement: "dropdown", optionValues: ["entityAttribute", "subjectTranslationScript", "translationScript"]}
# provisioner.genericProvisioner.entityAttributeValueCache2type =

# Target entity link - entityAttributeValueCache2 entityAttribute
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has && entityAttributeValueCache2type == 'entityAttribute'}", order: 80506, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.genericProvisioner.entityAttributeValueCache2entityAttribute =

# Target entity link - entityAttributeValueCache2 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has && (entityAttributeValueCache2type == 'translationScript' || entityAttributeValueCache2type == 'subjectTranslationScript')}", order: 80508}
# provisioner.genericProvisioner.entityAttributeValueCache2translationScript =

# Target entity link - Entity attribute value cache 2 auto-USDU.  This should generally be left as the default (true), USDU should update the value of this cache item from the subject source.
# {valueType: "boolean", indent: 2, defaultValue: "true", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has}", order: 80509}
# provisioner.genericProvisioner.entityAttributeValueCache2auto =

# Check for nulls in script
# {valueType: "boolean", order: 80550, subSection: "entity2", defaultValue: "false", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has && entityAttributeValueCache2type == 'subjectTranslationScript'}"}
# provisioner.genericProvisioner.entityAttributeValueCache2nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", order: 80570, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache2has && entityAttributeValueCache2nullChecksInScript}"}
# provisioner.genericProvisioner.entityAttributeValueCache2translationContinueCondition =


# Target entity link - has entityAttributeValueCache3?
# {valueType: "boolean", indent: 1, defaultValue: "false", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas}", order: 80601}
# provisioner.genericProvisioner.entityAttributeValueCache3has =

# Target entity link - entityAttributeValueCache3 source
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has}", order: 80602, formElement: "dropdown", optionValues: ["grouper", "target"]}
# provisioner.genericProvisioner.entityAttributeValueCache3source =

# Target entity link - entityAttributeValueCache3 type
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has}", order: 80604, formElement: "dropdown", optionValues: ["entityAttribute", "subjectTranslationScript", "translationScript"]}
# provisioner.genericProvisioner.entityAttributeValueCache3type =

# Target entity link - entityAttributeValueCache3 entityAttribute
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has && entityAttributeValueCache3type == 'entityAttribute'}", order: 80606, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.genericProvisioner.entityAttributeValueCache3entityAttribute =

# Target entity link - entityAttributeValueCache3 translationScript
# {valueType: "string", indent: 2, required: true, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has && (entityAttributeValueCache3type == 'translationScript' || entityAttributeValueCache3type == 'subjectTranslationScript')}", order: 80608}
# provisioner.genericProvisioner.entityAttributeValueCache3translationScript =

# Target entity link - Entity attribute value cache 3 auto-USDU.  This should generally be left as the default (true), USDU should update the value of this cache item from the subject source.
# {valueType: "boolean", indent: 2, defaultValue: "true", subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has}", order: 80609}
# provisioner.genericProvisioner.entityAttributeValueCache3auto =

# Check for nulls in script
# {valueType: "boolean", order: 80650, subSection: "entity2", defaultValue: "false", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has && entityAttributeValueCache3type == 'subjectTranslationScript'}"}
# provisioner.genericProvisioner.entityAttributeValueCache3nullChecksInScript =

# Condition that must be true in order to continue translation
# {valueType: "string", formElement: "textarea", order: 80670, subSection: "entity2", showEl: "${operateOnGrouperEntities && entityAttributeValueCacheHas && entityAttributeValueCache3has && entityAttributeValueCache3nullChecksInScript}"}
# provisioner.genericProvisioner.entityAttributeValueCache3translationContinueCondition =

# entity section 2 advanced options
# {valueType: "boolean", defaultValue: "false", order: 81000, subSection: "entity2", showEl: "${operateOnGrouperEntities}"}
# provisioner.genericProvisioner.entity2advanced = 

# overall group of entities to provision.  If not specified, then provision entities with any memberships.  Optional
# {valueType: "string", order: 81010, showEl: "${operateOnGrouperEntities && entity2advanced}", subSection: "entity2"}
# provisioner.genericProvisioner.groupIdOfUsersToProvision =

# overall group of entities to exclude.  If not specified, then do not exclude entities.  The group of users to provision happens first, then these are excluded after.  Optional
# {valueType: "string", order: 81011, showEl: "${operateOnGrouperEntities && entity2advanced}", subSection: "entity2"}
# provisioner.genericProvisioner.groupIdOfUsersNotToProvision =

# optional override for subject identifier to sync to member sync table
# {valueType: "string", order: 81020, showEl: "${operateOnGrouperEntities && entity2advanced}", formElement: "dropdown", optionValues: ["subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"], subSection: "entity2"}
# provisioner.genericProvisioner.subjectIdentifierForMemberSyncTable =

# If searching for entities by search attribute (e.g. looking up owners) this is the name of the search attribute to use for the value 
# {valueType: "string", order: 81025, subSection: "entity2", showEl: "${operateOnGrouperEntities && entity2advanced}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.genericProvisioner.searchAttributeNameToRetrieveEntities =

# Show provisioning diagnostics
# {valueType: "boolean", order: 82000, defaultValue: "false", subSection: "provisioningDiagnostics"}
# provisioner.genericProvisioner.showProvisioningDiagnostics =

# Select all groups during diagnostics
# {valueType: "boolean", order: 82100, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.selectAllGroupsDuringDiagnostics =

# Select all entities during diagnostics
# {valueType: "boolean", order: 82200, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.selectAllEntitiesDuringDiagnostics =

# Select all memberships during diagnostics
# {valueType: "boolean", order: 82300, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.selectAllMembershipsDuringDiagnostics =

# Test group name
# {valueType: "string", order: 82400, subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.testGroupName =

# create group during diagnostics
# {valueType: "boolean", order: 82500, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.createGroupDuringDiagnostics =

# delete group during diagnostics
# {valueType: "boolean", order: 83000, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.deleteGroupDuringDiagnostics =

# Test subject id or identifier
# {valueType: "string", order: 84000, subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.testSubjectIdOrIdentifier =

# create entity during diagnostics
# {valueType: "boolean", order: 85000, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.createEntityDuringDiagnostics =

# delete entity during diagnostics
# {valueType: "boolean", order: 86000, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.deleteEntityDuringDiagnostics =


# create membership during diagnostics
# {valueType: "boolean", order: 86100, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.createMembershipDuringDiagnostics =


# delete membership during diagnostics
# {valueType: "boolean", order: 86200, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${showProvisioningDiagnostics}"}
# provisioner.genericProvisioner.deleteMembershipDuringDiagnostics =

# Show assigning provisioning
# {valueType: "boolean", subSection: "assigningProvisioning", order: 86500, defaultValue: "false"}
# provisioner.genericProvisioner.showAssigningProvisioning =

# Group allowed to assign
# {valueType: "string", subSection: "assigningProvisioning", order: 86550, showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.groupAllowedToAssign =

# Group allowed to view
# {valueType: "string", subSection: "assigningProvisioning", order: 86560, showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.groupAllowedToView =

# Allow assignment only on one stem
# {valueType: "boolean", subSection: "assigningProvisioning", defaultValue: "false", order: 86600, showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.allowAssignmentsOnlyOnOneStem =

# Only provision policy groups
# {valueType: "boolean", order: 86700, defaultValue: "false", subSection: "assigningProvisioning", showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.onlyProvisionPolicyGroups =

# If you want a metadata item on folders for specifying if provision only policy groups
# {valueType: "boolean", order: 86750, defaultValue: "true", subSection: "assigningProvisioning", showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.allowPolicyGroupOverride =

# If you want to filter for groups in a provisionable folder by a regex on its name, specify here.  If the regex matches then the group in the folder is provisionable.  e.g. folderExtension matches ^.*_someExtension   folderName matches ^.*_someExtension   groupExtension matches ^.*_someExtension   groupName matches ^.*_someExtension$
# {valueType: "String", order: 86775, subSection: "assigningProvisioning", showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.provisionableRegex =

# If you want a metadata item on folders for specifying regex of names of objects to provision
# {valueType: "boolean", order: 86800, defaultValue: "true", subSection: "assigningProvisioning", showEl: "${showAssigningProvisioning}"}
# provisioner.genericProvisioner.allowProvisionableRegexOverride =

# Configure metadata
# {valueType: "boolean", order: 86790, defaultValue: "false", subSection: "metadata"}
# provisioner.genericProvisioner.configureMetadata =

# number of metadata
# {valueType: "integer", order: 86800, subSection: "metadata", defaultValue: "0", formElement: "dropdown", showEl: "${configureMetadata}", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.genericProvisioner.numberOfMetadata =

# name of metadata item.  This will be the name in the json attribute and can be assigned to a group, entity, or membership attribute.
# this should be unique across metadata for this provisioner.  Must start with md_
# {valueType: "string", order: 86810, showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.name =

# if this metadata item should show when marking a folder as provisionable
# {valueType: "boolean", order: 86840, defaultValue: "false", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.showForFolder =

# if this metadata item should show when marking a group as provisionable
# {valueType: "boolean", order: 86850, defaultValue: "false", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.showForGroup =

# if this metadata item should show when marking a member (entity) as provisionable
# {valueType: "boolean", order: 86860, defaultValue: "false", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.showForMember =

# if this metadata item should show when marking a membership as provisionable
# {valueType: "boolean", order: 86870, defaultValue: "false", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.showForMembership =

# if this metadata item can be changed
# {valueType: "boolean", order: 86871, defaultValue: "true", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.canChange =

# if this metadata item can be affected once it's in target
# {valueType: "boolean", order: 86872, defaultValue: "true", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20}
# provisioner.genericProvisioner.metadata.$i$.canUpdate =

# value type from the web form
# {valueType: "string", order: 86874, defaultValue: "string", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.GrouperProvisioningObjectMetadataItemValueType" }
# provisioner.genericProvisioner.metadata.$i$.valueType =

# if this item is required
# {valueType: "boolean", order: 86875, defaultValue: "false", showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20 }
# provisioner.genericProvisioner.metadata.$i$.required =

# default value of the metadata if the user does not enter anything
# {valueType: "string", order: 86880, showEl: "${configureMetadata && numberOfMetadata > $i$ && !metadata.$i$.required}", repeatGroup: "metadata", repeatCount: 20 }
# provisioner.genericProvisioner.metadata.$i$.defaultValue =

# form element type for value
# {valueType: "string", order: 86890, defaultValue: "text", showEl: "${configureMetadata && numberOfMetadata > $i$ && metadata.$i$.valueType != 'boolean'}", repeatGroup: "metadata", repeatCount: 20, formElement: "dropdown", optionValues: ["text", "textarea", "dropdown"] }
# provisioner.genericProvisioner.metadata.$i$.formElementType =

# comma-separated drop down values, escape commas in values with the hex code &amp;#x2c;
# {valueType: "string", order: 86900, showEl: "${configureMetadata && numberOfMetadata > $i$ && metadata.$i$.formElementType == 'dropdown'}", repeatGroup: "metadata", repeatCount: 20 }
# provisioner.genericProvisioner.metadata.$i$.dropdownValues =

# group id that can update this value
# {valueType: "string", order: 86920, showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20 }
# provisioner.genericProvisioner.metadata.$i$.groupIdThatCanView =

# group id that can update this value
# {valueType: "string", order: 86930, showEl: "${configureMetadata && numberOfMetadata > $i$}", repeatGroup: "metadata", repeatCount: 20 }
# provisioner.genericProvisioner.metadata.$i$.groupIdThatCanUpdate =

# Show failsafe options
# {valueType: "boolean", order: 120000, defaultValue: "false", subSection: "failsafe"}
# provisioner.genericProvisioner.showFailsafe =

# If the loader should check to see too many users were removed, if so, then error out and
# wait for manual intervention.  This setting means have global defaults.  If there are local settings
# those will still be used.
# {valueType: "string", order: 121000, formElement: "dropdown", subSection: "failsafe", showEl: "${showFailsafe}", optionValues: ["false", "true"]}
# provisioner.genericProvisioner.failsafeUse =

# if sending email on loader failsafe issues.  Default to true if there are email addresses to send to
# {valueType: "string", order: 122000, formElement: "dropdown", subSection: "failsafe", showEl: "${showFailsafe}", optionValues: ["false", "true"]}
# provisioner.genericProvisioner.failsafeSendEmail =

# If a group has a size less than this (default 200), then make changes including blanking it out.
# if -1 then do not have a global default
# {valueType: "integer", order: 123000, subSection: "failsafe", showEl: "${showFailsafe}"}
# provisioner.genericProvisioner.failsafeMinGroupSize =

# if a group with more members than the loader.failsafe.minGroupSize have more than this percent (default 30)  
# removed, then log it as error, fail the job, and don't actually remove the members 
# In order to run the job, an admin would need to change this param in the config, 
# and run the job manually, then change this config back.
# if -1 then do not have a global max percent remove
# {valueType: "integer", order: 124000, subSection: "failsafe", showEl: "${showFailsafe}"}
# provisioner.genericProvisioner.failsafeMaxPercentRemove =

# Only applicable if the number of managed groups (i.e. match the groupLikeString) that have
# members in Grouper before the loader starts is at least this amount.
# {valueType: "integer", order: 125000, subSection: "failsafe", showEl: "${showFailsafe}"}
# provisioner.genericProvisioner.failsafeMinManagedGroups =

# If the group list meets the criteria above and the percentage of groups that are managed by
# the loader (i.e. match the groupLikeString) that currently have members in Grouper but 
# wouldn't after the job runs is greater than this percentage, then don't remove members,
# log it as an error and fail the job.  An admin would need to approve the failsafe or change this param in the config,
# and run the job manually, then change this config back.
# {valueType: "integer", order: 126000, subSection: "failsafe", showEl: "${showFailsafe}"}
# provisioner.genericProvisioner.failsafeMaxOverallPercentGroupsRemove =

# This does not work for grouper loader currently.  If the group list meets the criteria above and the 
# percentage of memberships that are managed by
# the loader (i.e. match the groupLikeString) that currently have members in Grouper but 
# wouldn't after the job runs is greater than this percentage, then don't remove members,
# log it as an error and fail the job.  An admin would need to approve the failsafe or change this param in the config,
# and run the job manually, then change this config back.
# {valueType: "integer", order: 127000, subSection: "failsafe", showEl: "${showFailsafe}"}
# provisioner.genericProvisioner.failsafeMaxOverallPercentMembershipsRemove =

# If the overall membership count of the job is less than this amount then trigger a failsafe (do not run the job).  
# -1 means disable this failsafe.  There is no default value for this configuration.
# {valueType: "integer", order: 128000, subSection: "failsafe", showEl: "${showFailsafe}"}
# provisioner.genericProvisioner.failsafeMinOverallNumberOfMembers =

# Show error handling options
# {valueType: "boolean", order: 130000, defaultValue: "false", subSection: "errorHandling"}
# provisioner.genericProvisioner.errorHandlingShow =

# If the full or incremental provisioner should have a ERROR if there is an error in a group / entity / membership
# {valueType: "boolean", order: 130010, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingProvisionerDaemonShouldFailOnObjectError =

# Object errors will be logged, at least a handful of each type
# {valueType: "boolean", order: 130020, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingLogErrors =

# Object errors will be logged, at least a handful of each type
# {valueType: "integer", order: 130030, defaultValue: "5", subSection: "errorHandling", showEl: "${errorHandlingShow && errorHandlingLogErrors}"}
# provisioner.genericProvisioner.errorHandlingLogCountPerType = 

# If invalid data counts as an error.  Data is invalid if it is the wrong type or fails a validation
# {valueType: "boolean", order: 130040, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingInvalidDataIsAnError = 

# If attribute length validation counts as an error.  This happens when there is a max length on an attribute and the data is too long
# {valueType: "boolean", order: 130050, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingLengthValidationIsAnError = 

# If required but missing attributes count as an error.  Attribute can be marked as required, if they are blank then this problem happens
# {valueType: "boolean", order: 130060, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingRequiredValidationIsAnError = 

# If the grouper translated objects match to multiple target objects on the same attribute, then this problem happens
# {valueType: "boolean", order: 130065, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingMatchingValidationIsAnError = 

# If missing object in target counts as an error.  If the object is missing from the target and cannot be created this this problem happens
# {valueType: "boolean", order: 130070, defaultValue: "true", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingTargetObjectDoesNotExistIsAnError = 

# Level 1 error handling percent.  This is the percent chance that the incremental will process errors.
# {valueType: "floating", order: 130075, defaultValue: "1", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingPercentLevel1 = 

# Level 1 error handling minutes.  This is how many minutes in the past that error will be retried (+20 seconds).
# {valueType: "floating", order: 130080, defaultValue: "180", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingMinutesLevel1 = 

# Level 2 error handling percent.  This is the percent chance that the incremental will process errors.  Note, this does not include the level 1, so it actually occurs level2% - level1% of the time.
# {valueType: "floating", order: 130085, defaultValue: "5", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingPercentLevel2 = 

# Level 2 error handling minutes.  This is how many minutes in the past that error will be retried (+20 seconds).
# {valueType: "floating", order: 130090, defaultValue: "120", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingMinutesLevel2 = 

# Level 3 error handling percent.  This is the percent chance that the incremental will process errors.  Note, this does not include the level 1+2, so it actually occurs level3% - level1+2% of the time.
# {valueType: "floating", order: 130095, defaultValue: "10", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingPercentLevel3 = 

# Level 3 error handling minutes.  This is how many minutes in the past that error will be retried (+20 seconds).
# {valueType: "floating", order: 130100, defaultValue: "12", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingMinutesLevel3 = 

# Level 4 error handling percent.  This is the percent chance that the incremental will process errors.  Note, this does not include the level 1+2+3, so it actually occurs level4% - level1+2+3% of the time.  If 100 then do this all the time.
# {valueType: "floating", order: 130105, defaultValue: "100", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingPercentLevel4 = 

# Level 4 error handling minutes.  This is how many minutes in the past that error will be retried (+20 seconds).
# {valueType: "floating", order: 130110, defaultValue: "3", subSection: "errorHandling", showEl: "${errorHandlingShow}"}
# provisioner.genericProvisioner.errorHandlingMinutesLevel4 = 

# Show advanced options
# {valueType: "boolean", order: 137000, defaultValue: "false", subSection: "advanced"}
# provisioner.genericProvisioner.showAdvanced =

# Thread pool size
# {valueType: "integer", order: 137500, defaultValue: "5", subSection: "advanced", showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.threadPoolSize =

# Can full sync
# {valueType: "boolean", order: 138000, defaultValue: "true", subSection: "advanced", showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.canFullSync =


# if the target should be checked before sending actions.  e.g. if an addMember is made to a provisionable group, then check the target to see if the entity is already a member first.
# {valueType: "boolean", order: 139000, defaultValue: "false", subSection: "advanced", showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.recalculateAllOperations =

# if recalcing, see if user exists in target and only add if they exist
# {valueType: "boolean", order: 139050, defaultValue: "false", subSection: "advanced", showEl: "${showAdvanced && recalculateAllOperations}"}
# provisioner.genericProvisioner.onlyAddMembershipsIfUserExistsInTarget =

# enable debug log
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 139100, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.debugLog =

# log all objects verbose
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 139100, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.logAllObjectsVerbose =

# log all objects verbose to log file
# {valueType: "boolean", indent: 1, subSection: "advanced", defaultValue: "true", order: 139101, showEl: "${showAdvanced && logAllObjectsVerbose}"}
# provisioner.genericProvisioner.logAllObjectsVerboseToLogFile =

# log all objects verbose to daemon DB log
# {valueType: "boolean", indent: 1, subSection: "advanced", defaultValue: "true", order: 139102, showEl: "${showAdvanced && logAllObjectsVerbose}"}
# provisioner.genericProvisioner.logAllObjectsVerboseToDaemonDbLog =

# log information about these subject ids (comma separated less than 10)
# {valueType: "string", indent: 1, subSection: "advanced", order: 139103, showEl: "${showAdvanced && logAllObjectsVerbose}"}
# provisioner.genericProvisioner.logAllObjectsVerboseForTheseSubjectIds =

# log information about these group names (comma separated less than 10)
# {valueType: "string", indent: 1, subSection: "advanced", order: 139103, showEl: "${showAdvanced && logAllObjectsVerbose}"}
# provisioner.genericProvisioner.logAllObjectsVerboseForTheseGroupNames =

# keep a log of all commands, and then log to the log file
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 139130, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.logCommandsAlways =

# keep a log of all commands, and if there is an error and if so then log to the log file
# {valueType: "boolean", indent: 1, subSection: "advanced", defaultValue: "false", order: 139160, showEl: "${showAdvanced && !logCommandsAlways}"}
# provisioner.genericProvisioner.logCommandsOnError =

# when there is an error, log max this many of each time (to avoid filling up the logs with redundant entries)
# {valueType: "integer", subSection: "advanced", defaultValue: "10", order: 139180, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.logMaxErrorsPerType =

# if the target should be checked before sending actions.  e.g. if an addMember is made to a provisionable 
# group, then check the target to see if the entity is already a member first.
# default to provisionerDefault.membershipsConvertToGroupSyncThreshold = 500
# {valueType: "integer", order: 139200, subSection: "advanced", showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.membershipsConvertToGroupSyncThreshold =

# In incremental processing, each provisionable group/entity to sync memberships counts as 10, 
# each provisionable membership to sync counts as 1.  If the total score is more than this number, 
# it will convert the incrementals to a a full sync.  e.g. 10000 individual memberships to sync 
# (and not more than 500 in a single group), or 1000 groups to sync, or a combination. 
# -1 means do not convert to full sync
# default to provisionerDefault.scoreConvertToFullSyncThreshold = 10000
# {valueType: "integer", order: 139300, subSection: "advanced", showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.scoreConvertToFullSyncThreshold =

# Read only
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 139400, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.readOnly =

# refresh target group link if less than this amount
# {valueType: "integer", defaultValue: 20, subSection: "advanced", showEl: "${operateOnGrouperGroups && hasTargetGroupLink && showAdvanced}", order: 139500}
# provisioner.genericProvisioner.refreshGroupLinkIfLessThanAmount =

# refresh subject link if less than this amount
# {valueType: "integer", defaultValue: 20, showEl: "${operateOnGrouperEntities && showAdvanced}", order: 140000, subSection: "advanced"}
# provisioner.genericProvisioner.refreshSubjectLinkIfLessThanAmount =

# refresh target user link if less than this amount
# {valueType: "integer", defaultValue: 20, showEl: "${hasTargetEntityLink && operateOnGrouperEntities && showAdvanced}", order: 145000, subSection: "advanced"}
# provisioner.genericProvisioner.refreshEntityLinkIfLessThanAmount =

# Add disabled full sync daemon?
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 154000, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.addDisabledFullSyncDaemon =

# Add disabled incremental sync daemon?
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 155000, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.addDisabledIncrementalSyncDaemon =

# Unresolvable subjects - remove unresolvable subjects
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 156000, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.unresolvableSubjectsRemove =

# Unresolvable subjects - insert if not resolvable
# {valueType: "boolean", subSection: "advanced", defaultValue: "false", order: 157000, showEl: "${showAdvanced && !unresolvableSubjectsRemove}"}
# provisioner.genericProvisioner.unresolvableSubjectsInsert =

# milliseconds to sleep before trying to retrieve values after inserting them in target
# {valueType: "integer", subSection: "advanced", required: false, defaultValue: "0", order: 158000, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.sleepBeforeSelectAfterInsertMillis =

# remove accented characters from attribute values
# {valueType: "boolean", subSection: "advanced", required: false, defaultValue: "false", order: 159000, showEl: "${showAdvanced}"}
# provisioner.genericProvisioner.removeAccentedChars =

########################################
## box provisioner
########################################

# Generic provisioner key suffixes based on regex (comma separated) to ignore for box provisioner. delimiter is "," and U+002C is part of regex and substitute for comma
# {valueType: "string"}
# provisionerPropertiesToIgnore.GrouperBoxProvisioner.keySuffixRegexes =

# Subsections to ignore for box provisioner
# {valueType: "string"}
# provisionerPropertiesToIgnore.GrouperBoxProvisioner.subsections = group,user

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.myBoxProvisioner.class = edu.internet2.middleware.grouper.app.boxProvisioner.GrouperBoxProvisioner

# this is the box external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.boxProvisioner.BoxGrouperExternalSystem"}
# provisioner.myBoxProvisioner.boxExternalSystemConfigId =

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myBoxProvisioner.numberOfMembershipAttributes =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["canSeeManagedUsers", "id", "login", "name", "isExemptFromDeviceLimits", "isExemptFromLoginVerification", "isExternalCollabRestricted", "isPlatformAccessOnly", "isSyncEnabled", "maxUploadSize", "role", "spaceAmount", "spaceUsed", "status", "type"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myBoxProvisioner.targetEntityAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["canInviteAsCollaborator", "description", "externalSyncIdentifier", "groupType", "id", "invitabilityLevel", "memberViewabilityLevel", "name", "provenance", "type"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myBoxProvisioner.targetGroupAttribute.$i$.name =

########################################
## ldap provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.myLdapProvisioner.class = edu.internet2.middleware.grouper.app.ldapProvisioning.LdapSync

# this is the ldap external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.externalSystem.LdapGrouperExternalSystem"}
# provisioner.myLdapProvisioner.ldapExternalSystemConfigId =

# groupAttributes: group ldap object has attribute to hold memberships. 
# entityAttributes: user ldap object has attribute to hold memberships
# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", formElement: "dropdown", optionValues: ["groupAttributes", "entityAttributes"]}
# provisioner.myLdapProvisioner.provisioningType =

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myLdapProvisioner.numberOfMembershipAttributes =

# where users are
# {valueType: "string", subSection: "entity", required: true, order: 58010, showEl: "${operateOnGrouperEntities && selectEntities}"}
# provisioner.myLdapProvisioner.userSearchBaseDn =

# how to find a user
# {valueType: "string", subSection: "entity", order: 58020, showEl: "${operateOnGrouperEntities && selectEntities}"}
# provisioner.myLdapProvisioner.userSearchFilter =

# filter users when searching all
# {valueType: "string", subSection: "entity", order: 58030, showEl: "${operateOnGrouperEntities && selectEntities}"}
# provisioner.myLdapProvisioner.userSearchAllFilter =

# group search base dn, this is below the ldap connection base dn which is in the external system url. e.g. ou=Groups,dc=example,dc=edu
# {valueType: "string", subSection: "group", order: 18600, showEl: "${ operateOnGrouperGroups && (provisioningType == 'groupAttributes' || hasTargetGroupLink) && !onlyLdapGroupDnOverride}"}
# provisioner.myLdapProvisioner.groupSearchBaseDn =

# find a single group. You can use the variable 'targetGroup'. e.g. (gidNumber=${targetGroup.retrieveAttributeValue('gidNumber')})
# e.g. (dn=${targetGroup.getName()})
# {valueType: "string", subSection: "group", order: 18650, showEl: "${ operateOnGrouperGroups && (provisioningType == 'groupAttributes' || hasTargetGroupLink) }"}
# provisioner.myLdapProvisioner.groupSearchFilter =

# find all groups. e.g. (objectClass=posixGroup)
# e.g. (objectClass=groupOfNames)
# {valueType: "string", subSection: "group", order: 18700, showEl: "${ operateOnGrouperGroups && (provisioningType == 'groupAttributes' || hasTargetGroupLink) && !onlyLdapGroupDnOverride }"}
# provisioner.myLdapProvisioner.groupSearchAllFilter =

# If you want a metadata item on groups to allow a DN override
# {valueType: "boolean", order: 18720, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'groupAttributes'}"}
# provisioner.myLdapProvisioner.allowLdapGroupDnOverride =

# If you are only doing DN overrides
# {valueType: "boolean", order: 18721, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'groupAttributes' && allowLdapGroupDnOverride}"}
# provisioner.myLdapProvisioner.onlyLdapGroupDnOverride =

# when doing flat or bushy provisioning, this is the ldap "group" rdn, defaults to "cn"
# {valueType: "string", subSection: "group2", order: 77100, defaultValue: "cn", showEl: "${ operateOnGrouperGroups && provisioningType == 'groupAttributes'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.myLdapProvisioner.groupRdnAttribute =

# when adding users, this is the rdn of the dn (e.g. uid if dn is uid=123,ou=users,ou...)
# {valueType: "string", subSection: "entity2", order: 80150, showEl: "${ operateOnGrouperEntities && makeChangesToEntities && (!customizeEntityCrud || insertEntities)}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.myLdapProvisioner.userRdnAttribute =

# bushy makes an ou for each folder and cn is extension. flat is cn is group name
# {valueType: "string", subSection: "group", order: 18750, required: true, formElement: "dropdown", optionValues: ["bushy", "flat"], showEl: "${ operateOnGrouperGroups && provisioningType == 'groupAttributes' && !onlyLdapGroupDnOverride}"}
# provisioner.myLdapProvisioner.groupDnType =

# when doing bushy provisioning, this is the ldap "folder" rdn, defaults to "ou"
# {valueType: "string", subSection: "group", order: 18760, defaultValue: "ou", showEl: "${ operateOnGrouperGroups && provisioningType == 'groupAttributes' && groupDnType == 'bushy'}"}
# provisioner.myLdapProvisioner.folderRdnAttribute =

# bushy makes an ou for each folder these are the object classes that will be set on creation for the folder, e.g. top, organizationalUnit
# {valueType: "string", subSection: "group", order: 18770, defaultValue: "top, organizationalUnit", showEl: "${ operateOnGrouperGroups && provisioningType == 'groupAttributes' && groupDnType == 'bushy'}", multiple: true}
# provisioner.myLdapProvisioner.folderObjectClasses =

########################################
## sql provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.someSqlProvisioner.class = edu.internet2.middleware.grouper.app.sqlProvisioning.SqlProvisioner

# this is the sql external system config id
# {valueType: "string", order: 20, required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# provisioner.someSqlProvisioner.dbExternalSystemConfigId =

# Last modified column type. This is the database column type. The attribute in the representation is long always. This must exist for all tables being provisioned.
# {valueType: "string", order: 76050, subSection: "general2", formElement: "dropdown", optionValues: ["long", "timestamp"]}
# provisioner.someSqlProvisioner.sqlLastModifiedColumnType =

# Last modified column name e.g. last_modified. In the database, this is either a timestamp or millis since 1970. It's always increasing. This must exist for all tables being provisioned.
# {valueType: "string", order: 76100, required: true, subSection: "general2", showEl: "${sqlLastModifiedColumnType != null}"}
# provisioner.someSqlProvisioner.sqlLastModifiedColumnName =

# Deleted column name. If it's there, it must be of type that can store 'T' or 'F'. This must exist for all tables being provisioned. This column must be required and never null.
# {valueType: "string", order: 76200, subSection: "general2"}
# provisioner.someSqlProvisioner.sqlDeletedColumnName =

# users table to query to lookup users  required if hasTargetEntityLink
# {valueType: "string", order: 49010, subSection: "entity", showEl: "${ operateOnGrouperEntities && (!customizeEntityCrud || selectEntities) }"}
# provisioner.someSqlProvisioner.userTableName =

# users table primary key column of user table
# {valueType: "string", order: 80995, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities) }", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningEntityAttributeDropdownOptions"}
# provisioner.someSqlProvisioner.userPrimaryKey =

# if this is more complicated than just a simple select, put the query here optional, select * from users where ...
# {valueType: "string", order: 81007, subSection: "entity2", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities) && entity2Advanced}"}
# provisioner.someSqlProvisioner.userSearchQuery =

# memberships table where memberships go.  include schema name if necessary
# {valueType: "string", required: true, order: 5605, subSection: "membership", showEl: "${operateOnGrouperMemberships && provisioningType == 'membershipObjects' }"}
# provisioner.someSqlProvisioner.membershipTableName =

# column from membership table which is the foreign key to the group table
# {valueType: "string", required: false, order: 78050, subSection: "membership2", showEl: "${operateOnGrouperMemberships && provisioningType == 'membershipObjects' && operateOnGrouperGroups && (!customizeGroupCrud || selectGroups) }", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningMembershipAttributeDropdownOptions"}
# provisioner.someSqlProvisioner.membershipGroupForeignKeyColumn =

# column from membership table which is the foreign key to the entity table
# {valueType: "string", required: false, order: 78051, subSection: "membership2", showEl: "${operateOnGrouperMemberships && provisioningType == 'membershipObjects' && operateOnGrouperEntities && (!customizeEntityCrud || selectEntities) }", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningMembershipAttributeDropdownOptions"}
# provisioner.someSqlProvisioner.membershipEntityForeignKeyColumn =

# if this is more complicated than just a simple select, put the query here optional, select * from memberships where ...
# {valueType: "string", order: 5630, subSection: "membership", showEl: "${operateOnGrouperMemberships && provisioningType == 'membershipObjects' && membershipAdvancedOptions}"}
# provisioner.someSqlProvisioner.membershipSearchQuery =

# groups table to query to lookup users  required if hasTargetEntityLink
# {valueType: "string", subSection: "group", order: 15010, showEl: "${operateOnGrouperGroups }"}
# provisioner.someSqlProvisioner.groupTableName =

# groups table primary key column of group table
# {valueType: "string", subSection: "group2", order: 79400, showEl: "${operateOnGrouperGroups }", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningGroupAttributeDropdownOptions"}
# provisioner.someSqlProvisioner.groupTableIdColumn =

# Use separate table for group attributes
# {valueType: "boolean", order: 15041, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups}"}
# provisioner.someSqlProvisioner.useSeparateTableForGroupAttributes =

# table to store group attributes
# {valueType: "string", indent: 1, subSection: "group", order: 15042, showEl: "${operateOnGrouperGroups && useSeparateTableForGroupAttributes}"}
# provisioner.someSqlProvisioner.groupAttributesTableName =

# column from group table which is the foreign key in the group attribute table. Include schema name if necessary.
# {valueType: "string", indent: 1, subSection: "group", order: 15043, showEl: "${operateOnGrouperGroups && useSeparateTableForGroupAttributes}"}
# provisioner.someSqlProvisioner.groupAttributesGroupForeignKeyColumn =

# name of the column in group attribute table that will store attribute names. Include schema name if necessary.
# {valueType: "string", indent: 1, subSection: "group", defaultValue: "attribute_name", order: 15044, showEl: "${operateOnGrouperGroups && useSeparateTableForGroupAttributes}"}
# provisioner.someSqlProvisioner.groupAttributesAttributeNameColumn =

# name of the column in group attribute table that will store attribute values. Include schema name if necessary.
# {valueType: "string", indent: 1, subSection: "group", order: 15045, defaultValue: "attribute_value", showEl: "${operateOnGrouperGroups && useSeparateTableForGroupAttributes}"}
# provisioner.someSqlProvisioner.groupAttributesAttributeValueColumn =

# if this is more complicated than just a simple select, put the query here optional, select * from groups where ...
# {valueType: "string", indent: 1, subSection: "group2", order: 79912, showEl: "${operateOnGrouperGroups && group2advanced }"}
# provisioner.someSqlProvisioner.groupSearchQuery =

# Storage type
# {valueType: "string", order: 20001, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$ && useSeparateTableForGroupAttributes}", formElement: "dropdown", optionValues: ["groupTableColumn", "separateAttributesTable"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.someSqlProvisioner.targetGroupAttribute.$i$.storageType =


# Use separate table for entity attributes
# {valueType: "boolean", order: 49011, defaultValue: "false", subSection: "entity", showEl: "${operateOnGrouperEntities && (!customizeEntityCrud || selectEntities) }"}
# provisioner.someSqlProvisioner.useSeparateTableForEntityAttributes =

# table to store entity attributes
# {valueType: "string", indent: 1, subSection: "entity", order: 49012, showEl: "${operateOnGrouperEntities && useSeparateTableForEntityAttributes}"}
# provisioner.someSqlProvisioner.entityAttributesTableName =

# column from entity table which is the foreign key in the entity attribute table. Include schema name if necessary.
# {valueType: "string", indent: 1, subSection: "entity", order: 49013, showEl: "${operateOnGrouperEntities && useSeparateTableForEntityAttributes}"}
# provisioner.someSqlProvisioner.entityAttributesEntityForeignKeyColumn =

# name of the column in entity attribute table that will store attribute names. Include schema name if necessary.
# {valueType: "string", indent: 1, subSection: "entity", defaultValue: "attribute_name", order: 49014, showEl: "${operateOnGrouperEntities && useSeparateTableForEntityAttributes}"}
# provisioner.someSqlProvisioner.entityAttributesAttributeNameColumn =

# name of the column in entity attribute table that will store attribute values. Include schema name if necessary.
# {valueType: "string", indent: 1, subSection: "entity", order: 49015, defaultValue: "attribute_value", showEl: "${operateOnGrouperEntities && useSeparateTableForEntityAttributes}"}
# provisioner.someSqlProvisioner.entityAttributesAttributeValueColumn =

# Storage type
# {valueType: "string", order: 60001, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$ && useSeparateTableForEntityAttributes}", formElement: "dropdown", optionValues: ["entityTableColumn", "separateAttributesTable"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.someSqlProvisioner.targetEntityAttribute.$i$.storageType =

########################################
## scim provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.myScimProvisioner.class = edu.internet2.middleware.grouper.app.scim2Provisioning.GrouperScim2Provisioner

# bearer token external system id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.externalSystem.WsBearerTokenExternalSystem"}
# provisioner.myScimProvisioner.bearerTokenExternalSystemConfigId =

# {valueType: "string", required: true, order: 25, formElement: "dropdown", optionValues: ["AWS", "Github", "generic"]}
# provisioner.myScimProvisioner.scimType =

# accept header. For github use "application/vnd.github.v3+json"
# {valueType: "string", required: false, readOnly: false, order: 30, showEl: "${scimType != 'AWS'}"}
# provisioner.myScimProvisioner.acceptHeader =


# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", readOnly: true}
# provisioner.myScimProvisioner.provisioningType = membershipObjects

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myScimProvisioner.numberOfMembershipAttributes =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["displayName", "id"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myScimProvisioner.targetGroupAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["active", "costCenter", "displayName", "emailType", "emailValue", "emailType2", "emailValue2", "employeeNumber", "externalId", "familyName", "formattedName", "givenName", "id", "middleName", "schemas", "userName", "userType"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myScimProvisioner.targetEntityAttribute.$i$.name =


##############
## Zoom
##############


# endpoint of zoom including the version
# {valueType: "string", defaultValue: "https://api.zoom.us/v2"}
# zoom.myConfigId.endpoint = https://api.zoom.us/v2


# zoom jwt api key
# {valueType: "string"}
# zoom.myConfigId.jwtApiKey = 

# zoom authentication type: jwt or oauth2
# {valueType: "string", formElement: "dropdown", optionValues: ["jwt", "oauth2"]}
# zoom.myConfigId.zoomAuthenticationType = 

# zoom oauth2 endpoint, default is https://zoom.us/
# {valueType: "string"}
# zoom.myConfigId.zoomOauth2endpoint = 

# zoom oauth2 account ID
# {valueType: "string"}
# zoom.myConfigId.zoomOauth2AccountId = 

# zoom oauth2 client ID
# {valueType: "string"}
# zoom.myConfigId.zoomOauth2ClientId = 

# zoom oauth2 client secret
# {valueType: "password", sensitive: true}
# zoom.myConfigId.zoomOauth2ClientSecret = 

# zoom jwt api key
# {valueType: "password", sensitive: true}
# zoom.myConfigId.jwtApiSecretPassword = 

# cache jwt for minutes, must be at least 2, or could be 0 to not cache.  If it is 1 it will be changed to 2.
# {valueType: "integer", defaultValue: "30"}
# zoom.myConfigId.cacheJwtForMinutes = 30

# master account id (used in custom ui)
# {valueType: "string"}
# zoom.myConfigId.masterAccountId = 

# page size when retrieving members, max is 300
# {valueType: "integer", defaultValue: "300"}
# zoom.myConfigId.pageSizeMemberships = 300

# base folder
# {valueType: "string"}
# zoom.myConfigId.folderToProvision = 

# if provisioning groups should remove only
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.groupProvisionRemoveOnly = 

# base folder
# {valueType: "string"}
# zoom.myConfigId.roleFolderToProvision = 

# if provisioning roles should remove only
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.roleProvisionRemoveOnly = 

# subject sources to provision
# {valueType: "string", multiple: true}
# zoom.myConfigId.sourcesForSubjects = 

# ignore user ids in zoom (dont remove them) e.g. admin ids
# {valueType: "string", multiple: true}
# zoom.myConfigId.ignoreUserIds =

# subject attribute to match zoom email address (generally eppn)
# {valueType: "string"}
# zoom.myConfigId.subjectAttributeForZoomEmail = 

# if deleting users, this is the group of users to delete.  Load this group with your grace period policy
# {valueType: "string"}
# zoom.myConfigId.groupNameToDeleteUsers = a:b:c

# if deleting users, this will just log instead of actually deleting
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.logUserDeletesInsteadOfDeleting = false

# if deleting users, this will remove the user from the grouper group (of users to delete), after the deleting occurs (if they have an immediate membership there)
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.removeGrouperMembershipFromDeletedGroupAfterDeleteZoomUser = false

# if deactivating users, this is the group of users to deactivate.  Load this group with your grace period policy
# {valueType: "string"}
# zoom.myConfigId.groupNameToDeactivateUsers = a:b:c

# if deactivating users, this will just log instead of actually deactivating
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.logUserDeactivatesInsteadOfDeactivating = false

# if deactivating users, this will remove the user from the grouper group (of users to deactivate), after the deactivating occurs (if they have an immediate membership there)
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.removeGrouperMembershipFromDeactivatedGroupAfterDeactivateZoomUser = false

# if reactivating users, this is the group of users to reactivate.
# {valueType: "string"}
# zoom.myConfigId.groupNameToReactivateUsers = a:b:c

# if reactivating users, this will assign a license (user type 2)
# {valueType: "boolean", defaultValue: "true"}
# zoom.myConfigId.licenseReactivatedUsers = true

# if delicensing users, this is the group of users to delicense.  
# {valueType: "string"}
# zoom.myConfigId.groupNameToDelicenseUsers = a:b:c

# if delicensing users, this will just log instead of actually delicensing
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.logUserDelicencesInsteadOfDelicensing = false

# if delicensing users, this will remove the user from the grouper group (of users to delicense), after the delicensing occurs (if they have an immediate membership there)
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.removeGrouperMembershipFromDelicensedGroupAfterDelicenseZoomUser = false

# if delicensing phone users, this is the group of phone users to delicense.  
# {valueType: "string"}
# zoom.myConfigId.groupNameToDelicensePhoneUsers = a:b:c

# $$lowerEmailAddresses$$ will be the bind variables to lookup email addresses.  the first col is the email, the second col is the subject id, 
# the third col is the source_id
# e.g. select LOWER_EMAIL_ADDRESS, CHAR_PENN_ID, 'pennperson' as subject_source_id from person_source_email_lookup_v where lower_email_address in ($$lowerEmailAddresses$$)
# {valueType: "string"}
# zoom.myConfigId.emailLookupQuery = 

# database where the email lookup occurs
# {valueType: "string"}
# zoom.myConfigId.emailLookupDbConfigId =

# if there are unresolvables then log them so they can be dealt with
# {valueType: "boolean", defaultValue: "false"}
# zoom.myConfigId.logUnresolvables = false

# proxy requests here, e.g. https://server:1234
# {valueType: "string"}
# zoom.myConfigId.proxyUrl =

# socks or http
# {valueType: "string", formElement: "dropdown", optionValues: ["PROXY_HTTP", "PROXY_SOCKS5"]}
# zoom.myConfigId.proxyType =


#################
## Zoom full provisioning
#################

# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.myZoomFull.class = edu.internet2.middleware.grouper.app.zoom.GrouperZoomFullSync

# zoom full cron, default to 2:20
# {valueType: "string", required: true}
# otherJob.myZoomFull.quartzCron = 0 20 2 * * ?

# links to zoom config id
# {valueType: "string"}
# otherJob.myZoomFull.zoomConfigId = myConfigId

#################
## Zoom incremental provisioning
#################

# esb consumer
# {valueType: "class", required: true, mustExtendClass: "edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer"}
# changeLog.consumer.zoomEsbProd.class = edu.internet2.middleware.grouper.changeLog.esb.consumer.EsbConsumer

# zoom incremental cron, defualt to every hour except 2am (to not conflict with full)
# {valueType: "string"}
# changeLog.consumer.zoomEsbProd.quartzCron = 0 * 0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 * * ?

# zoom publishing class
# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.esb.listener.EsbListenerBase"}
# changeLog.consumer.zoomEsbProd.publisher.class = edu.internet2.middleware.grouper.app.zoom.ZoomEsbPublisher

# el filter
# {valueType: "string"}
# changeLog.consumer.zoomEsbProd.elfilter = (event.sourceId == null || event.sourceId eq 'pennperson') && (event.groupName =~ '^penn\:isc\:ait\:apps\:zoom\:service\:policy\:groups\:.*$' || event.name =~ '^penn\:isc\:ait\:apps\:zoom\:service\:policy\:groups\:.*$' ) && (event.eventType eq 'GROUP_DELETE' || event.eventType eq 'GROUP_ADD' || event.eventType eq 'GROUP_UPDATE' || event.eventType eq 'MEMBERSHIP_DELETE' || event.eventType eq 'MEMBERSHIP_ADD' || event.eventType eq 'MEMBERSHIP_UPDATE')

# add subject attributes
# {valueType: "string", multiple: true}
# changeLog.consumer.zoomEsbProd.publisher.addSubjectAttributes = EPPN

# zoom config id
# {valueType: "string"}
# changeLog.consumer.zoomEsbProd.zoomConfigId = myConfigId

# if you want to bump up the number of change log entries for a particular consumer, you can enter that here, per change log consumer
# defaults to grouper-loader.properties changeLog.changeLogConsumerBatchSize which defaults to 1000
# {valueType: "integer"}
# changeLog.consumer.zoomEsbProd.changeLogConsumerBatchSize =

#################
## Zoom loading
#################

# {valueType: "class", mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase", mustImplementInterface: "org.quartz.Job"}
# otherJob.myZoomLoader.class = edu.internet2.middleware.grouper.app.zoom.GrouperZoomLoader

# zoom full cron, default to every hour at 40 minutes after
# {valueType: "string", required: true}
# otherJob.myZoomLoader.quartzCron = 0 40 * * * ?

# links to zoom config id
# {valueType: "string"}
# otherJob.myZoomLoader.zoomConfigId = myConfigId

# if loading groups from zoom to grouper
# {valueType: "boolean", defaultValue: "false"}
# otherJob.myZoomLoader.zoomLoadGroups = false

# if zoomLoadGroups is true then load groups into this folder
# {valueType: "string"}
# otherJob.myZoomLoader.zoomLoadGroupsFolderName = a:b

# if loading roles from zoom to grouper
# {valueType: "boolean", defaultValue: "false"}
# otherJob.myZoomLoader.zoomLoadRoles = false

# if zoomLoadRoles is true then load roles into this folder
# {valueType: "string"}
# otherJob.myZoomLoader.zoomLoadRolesFolderName = c:d

# if loading user types from zoom to grouper
# {valueType: "boolean", defaultValue: "false"}
# otherJob.myZoomLoader.zoomLoadUserTypes = false

# if zoomLoadUserTypes is true then load userTypes into this folder
# {valueType: "string"}
# otherJob.myZoomLoader.zoomLoadUserTypesFolderName = d:e

# if loading user statuses from zoom to grouper
# {valueType: "boolean", defaultValue: "false"}
# otherJob.myZoomLoader.zoomLoadUserStatuses = false

# if zoomLoadUserStatuses is true then load user statuses into this folder
# {valueType: "string"}
# otherJob.myZoomLoader.zoomLoadUserStatusesFolderName = d:e

# if loading users to the grouper_zoom_user table (v2.6.1+) 
# {valueType: "boolean", defaultValue: "false"}
# otherJob.myZoomLoader.zoomLoadUsersToTable = false

############################################
## Azure external system
## specify the azure connection with user, pass, endpoint etc
## the string after "azureConnector." is the name of the connection, and it should not have
## spaces or other special chars in it
############################################

# azure login base uri to get a token. Should end in a slash.  e.g. https://login.microsoftonline.com/
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.loginEndpoint$"}
# grouper.azureConnector.myAzure.loginEndpoint = https://login.microsoftonline.com/

# azure directory id. eg: 6c4dxxx0d
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.tenantId$"}
# grouper.azureConnector.myAzure.tenantId =

# client id. eg: fd805xxxxdfb
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.clientId"}
# grouper.azureConnector.myAzure.clientId =

# client secret
# {valueType: "password", sensitive: true, regex: "^db\\.([^.]+)\\.clientSecret"}
#grouper.azureConnector.myAzure.clientSecret =

# resource.  generally same as graph endpoint. eg: https://graph.microsoft.com
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.resource$"}
# grouper.azureConnector.myAzure.resource =

# azure resource base uri.  Should include the version and end in a slash, e.g. https://graph.microsoft.com/v1.0/ or https://graph.microsoft.com/beta/
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.resourceEndpoint$"}
# grouper.azureConnector.myAzure.resourceEndpoint = https://graph.microsoft.com/v1.0/

# graph endpoint. eg: https://graph.microsoft.com
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.graphEndpoint$"}
# grouper.azureConnector.myAzure.graphEndpoint =

# graph version. eg: v1.0 or beta
# {valueType: "string", required: true, regex: "^grouper\\.azureConnector\\.([^.]+)\\.graphVersion$"}
# grouper.azureConnector.myAzure.graphVersion =

# group lookup attribute for Custom UI. eg: displayName
# {valueType: "string", regex: "^grouper\\.azureConnector\\.([^.]+)\\.groupLookupAttribute$"}
# grouper.azureConnector.myAzure.groupLookupAttribute =

# group lookup value format for Custom UI. eg: ${group.getName()}
# {valueType: "string", regex: "^grouper\\.azureConnector\\.([^.]+)\\.groupLookupValueFormat$"}
# grouper.azureConnector.myAzure.groupLookupValueFormat =

# require subject attribute for Custom UI. eg: netId
# {valueType: "string", regex: "^grouper\\.azureConnector\\.([^.]+)\\.requireSubjectAttribute$"}
# grouper.azureConnector.myAzure.requireSubjectAttribute =

# subject id value format for Custom UI. eg:  ${subject.getAttributeValue("netId")}@school.edu
# {valueType: "string", regex: "^grouper\\.azureConnector\\.([^.]+)\\.subjectIdValueFormat$"}
# grouper.azureConnector.myAzure.subjectIdValueFormat =

# proxy requests here, e.g. https://server:1234
# {valueType: "string", regex: "^grouper\\.azureConnector\\.([^.]+)\\.proxyUrl$"}
# grouper.azureConnector.myAzure.proxyUrl =

# socks or http
# {valueType: "string", regex: "^grouper\\.azureConnector\\.([^.]+)\\.proxyType$", formElement: "dropdown", optionValues: ["PROXY_HTTP", "PROXY_SOCKS5"]}
# grouper.azureConnector.myAzure.proxyType =

# if you are getting errors, you can temporarily set this to true to log authentication bodies.  Then set back to false so the tokens (secrets) arent logged
# {valueType: "boolean", regex: "^grouper\\.azureConnector\\.([^.]+)\\.logAuthenticationResponseBody$", defaultValue: "false"}
# grouper.azureConnector.myAzure.logAuthenticationResponseBody =

# if this azure connector is enabled
# {valueType: "boolean", regex: "^grouper\\.azureConnector\\.([^.]+)\\.enabled$", defaultValue: "true"}
# grouper.azureConnector.myAzure.enabled =

# How long until the team dynamix authn token expires.  If 0 or -1, then dont cache.  If you change this you need to bounce the daemon.
# {valueType: "integer", required: "true"}
teamDynamixAuthnTokenExpiresSeconds = 60

############################################
## Team dynamix external system
## specify the team dynamix connection with user, pass, endpoint etc
## the string after "teamDynamix." is the name of the connection, and it should not have
## spaces or other special chars in it
############################################

# team dynamix login base uri to get a token. Should end in a slash.  e.g. https://yourTeamDynamixDomain/
# {valueType: "string", required: true, regex: "^grouper\\.teamDynamix\\.([^.]+)\\.url$"}
# grouper.teamDynamix.myTeamDynamix.url = 

# team dynamix beid (tenant id)
# {valueType: "string", required: true, regex: "^grouper\\.teamDynamix\\.([^.]+)\\.beid$"}
# grouper.teamDynamix.myTeamDynamix.beid =

# web services key
# {valueType: "string", required: true, regex: "^grouper\\.teamDynamix\\.([^.]+)\\.webServicesKey"}
# grouper.teamDynamix.myTeamDynamix.webServicesKey =

# expires in seconds
# {valueType: "string", defaultValue: "60", regex: "^grouper\\.teamDynamix\\.([^.]+)\\.expiresInSeconds"}
# grouper.teamDynamix.myTeamDynamix.expiresInSeconds =

# proxy requests here, e.g. https://server:1234
# {valueType: "string", regex: "^grouper\\.teamDynamix\\.([^.]+)\\.proxyUrl$"}
# grouper.teamDynamix.myTeamDynamix.proxyUrl =

# socks or http
# {valueType: "string", regex: "^grouper\\.teamDynamix\\.([^.]+)\\.proxyType$", formElement: "dropdown", optionValues: ["PROXY_HTTP", "PROXY_SOCKS5"]}
# grouper.teamDynamix.myTeamDynamix.proxyType =

# if this team dynamix connector is enabled
# {valueType: "boolean", regex: "^grouper\\.teamDynamix\\.([^.]+)\\.enabled$", defaultValue: "true"}
# grouper.teamDynamix.myTeamDynamix.enabled =


############################################
## WS bearer token external system
## this is a simple URL with an Authorization bearer token secret
############################################

# Base website URL for WS with bearer token authn.  e.g. https://scim.us-east-1.amazonaws.com/abc123/scim/v2/
# {valueType: "string", required: true, regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.endpoint$"}
# grouper.wsBearerToken.myWsBearerToken.endpoint = 

# Bearer token secret, e.g. AWS access token
# {valueType: "password", sensitive: true, required: true, regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.accessTokenPassword$"}
# grouper.wsBearerToken.myWsBearerToken.accessTokenPassword =

# proxy requests here, e.g. https://server:1234
# {valueType: "string", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.proxyUrl$"}
# grouper.wsBearerToken.myWsBearerToken.proxyUrl = 

# socks or http
# {valueType: "string", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.proxyType$", formElement: "dropdown", optionValues: ["PROXY_HTTP", "PROXY_SOCKS5"]}
# grouper.wsBearerToken.myWsBearerToken.proxyType = 

# If the usage of this code supports pageSize, configure it here (e.g. for SCIM)
# {valueType: "integer", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.pageSize$", defaultValue: "50"}
# grouper.wsBearerToken.myWsBearerToken.pageSize = 

# If the usage of this code supports user pageSize, configure it here (e.g. for SCIM), default is pageSize, -1 means dont use paging (not recommended)
# {valueType: "integer", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.pageSize$"}
# grouper.wsBearerToken.myWsBearerToken.userPageSize = 

# If the user of this code supports pageSize, configure it here (e.g. for SCIM), default is pageSize, -1 means dont use paging
# {valueType: "integer", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.pageSize$"}
# grouper.wsBearerToken.myWsBearerToken.groupPageSize = 

# if this WS endpoing connector is enabled
# {valueType: "boolean", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.enabled$", defaultValue: "true"}
# grouper.wsBearerToken.myWsBearerToken.enabled =

# Test URL suffix that returns a 200, e.g. for scim: /Users?count=0
# {valueType: "string", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.testUrlSuffix$"}
# grouper.wsBearerToken.myWsBearerToken.testUrlSuffix = 

# Test URL method, defaults to GET.  Could be POST or whatever.
# {valueType: "string", defaultValue: "GET", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.testHttpMethod$"}
# grouper.wsBearerToken.myWsBearerToken.testHttpMethod = 

# Test URL response code.  Defaults to 200
# {valueType: "integer", defaultValue: "200", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.testHttpResponseCode$"}
# grouper.wsBearerToken.myWsBearerToken.testHttpResponseCode = 

# Test URL response regex to match to see if valid (optional), e.g. for scim: .*totalResults.*
# {valueType: "string", regex: "^grouper\\.myWsBearerToken\\.([^.]+)\\.testUrlResponseBodyRegex$"}
# grouper.wsBearerToken.myWsBearerToken.testUrlResponseBodyRegex = 

########################################
## Azure provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true}
# provisioner.myAzureProvisioner.class = edu.internet2.middleware.grouper.app.azure.GrouperAzureProvisioner

# this is the Azure external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.azure.AzureGrouperExternalSystem"}
# provisioner.myAzureProvisioner.azureExternalSystemConfigId =

# azure is always membershipObjects
# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", formElement: "dropdown", optionValues: ["membershipObjects"]}
# provisioner.myAzureProvisioner.provisioningType =

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myAzureProvisioner.numberOfMembershipAttributes =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["accountEnabled", "displayName", "id", "mailNickname", "onPremisesImmutableId", "userPrincipalName"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myAzureProvisioner.targetEntityAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["description", "displayName", "groupOwners", "groupType", "groupTypeUnified", "id", "mailEnabled", "mailNickname", "securityEnabled", "visibility", "allowOnlyMembersToPost", "hideGroupInOutlook", "subscribeNewGroupMembers", "welcomeEmailDisabled", "resourceProvisioningOptionsTeam", "isAssignableToRole"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myAzureProvisioner.targetGroupAttribute.$i$.name =

# If you want a metadata item on isAssignableToRole
# {valueType: "boolean", order: 18705, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.assignableToRole =

# If you want a metadata item on group type
# {valueType: "boolean", order: 18710, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.azureGroupType =

# If you want a metadata item on group owners
# {valueType: "boolean", order: 18715, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.groupOwners =

# If you want a metadata item on groups to allow only members to post
# {valueType: "boolean", order: 18720, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.allowOnlyMembersToPost =

# If you want a metadata item on groups to set hide group in outtook
# {valueType: "boolean", order: 18750, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.hideGroupInOutlook =

# If you want a metadata item on groups to set subscribe new group members
# {valueType: "boolean", order: 18810, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.subscribeNewGroupMembers =

# If you want a metadata item on groups to have welcome email disabled
# {valueType: "boolean", order: 18820, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.welcomeEmailDisabled =

# If you want a metadata item on groups to have resource provisioning options set as Team
# {valueType: "boolean", order: 18830, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myAzureProvisioner.resourceProvisioningOptionsTeam =

# milliseconds to sleep before trying to retrieve values after inserting them in target
# {valueType: "integer", subSection: "advanced", required: false, defaultValue: "3000", order: 158000, showEl: "${showAdvanced}"}
# provisioner.myAzureProvisioner.sleepBeforeSelectAfterInsertMillis =


########################################
## Duo provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true}
# provisioner.myDuoProvisioner.class = edu.internet2.middleware.grouper.app.duo.GrouperDuoProvisioner

# this is the Duo external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperDuo.DuoGrouperExternalSystem"}
# provisioner.myDuoProvisioner.duoExternalSystemConfigId =

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myDuoProvisioner.numberOfMembershipAttributes =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["description", "name", "id" ], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myDuoProvisioner.targetGroupAttribute.$i$.name =

# load entities to grouper table
# {valueType: "boolean", order: 37650, defaultValue: "false", subSection: "entity", showEl: "${operateOnGrouperEntities && selectEntities && selectAllEntities}"}
# provisioner.myDuoProvisioner.loadEntitiesToGrouperTable =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["alias1", "alias2", "alias3", "alias4", "email", "firstName", "id", "lastName", "loginId", "name"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myDuoProvisioner.targetEntityAttribute.$i$.name =

########################################
## Duo role provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true}
# provisioner.myDuoRoleProvisioner.class = edu.internet2.middleware.grouper.app.duo.role.GrouperDuoRoleProvisioner

# this is the Duo external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperDuo.DuoGrouperExternalSystem"}
# provisioner.myDuoRoleProvisioner.duoExternalSystemConfigId =

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myDuoRoleProvisioner.numberOfMembershipAttributes =

# Insert groups
# {valueType: "boolean", order: 9000, subSection: "group", defaultValue: "false", showEl: "${false}"}
# provisioner.myDuoRoleProvisioner.insertGroups =

# Delete groups
# {valueType: "boolean", order: 9500, defaultValue: "false", subSection: "group", showEl: "${false}"}
# provisioner.myDuoRoleProvisioner.deleteGroups =

# Update groups
# {valueType: "boolean", order: 11500, defaultValue: "false", subSection: "group", showEl: "${false}"}
# provisioner.myDuoRoleProvisioner.updateGroups =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["role"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myDuoRoleProvisioner.targetGroupAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["id", "name", "email", "role", "send_email"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myDuoRoleProvisioner.targetEntityAttribute.$i$.name =


########################################
## Messaging provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true}
# provisioner.myMessagingProvisioner.class = edu.internet2.middleware.grouper.app.messagingProvisioning.GrouperMessagingProvisioner

# messaging type
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValues: ["ActiveMQ", "AWS_SQS", "Grouper_Builtin", "RabbitMQ"]}
# provisioner.myMessagingProvisioner.messagingType =

# this is the messaging external system config id
# {valueType: "string", required: true, order: 21, showEl: "${messagingType == 'ActiveMQ'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperMessagingActiveMQ.ActiveMqGrouperExternalSystem"}
# provisioner.myMessagingProvisioner.messagingActiveMqExternalSystemConfigId =

# this is the messaging external system config id
# {valueType: "string", required: true, order: 22, showEl: "${messagingType == 'AWS_SQS'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperMessagingAWS.SqsGrouperExternalSystem"}
# provisioner.myMessagingProvisioner.messagingAwsSqsExternalSystemConfigId =

# this is the messaging external system config id
# {valueType: "string", required: true, order: 23, showEl: "${messagingType == 'RabbitMQ'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperMessagingRabbitmq.RabbitMqGrouperExternalSystem"}
# provisioner.myMessagingProvisioner.messagingRabbitMqExternalSystemConfigId =

# messaging format type
# {valueType: "string", required: true, formElement: "dropdown", optionValues: ["EsbEventJson"]}
# provisioner.myMessagingProvisioner.messagingFormatType =

# target type - queue or topic
# {valueType: "string", required: true, showEl: "${messagingType != 'AWS_SQS'}", formElement: "dropdown", optionValues: ["queue", "topic"]}
# provisioner.myMessagingProvisioner.queueType =

# queue or topic name
# {valueType: "string", required: true}
# provisioner.myMessagingProvisioner.queueOrTopicName =

# routing key - Valid only for rabbitMq
# {valueType: "string", showEl: "${messagingType == 'RabbitMQ'}"}
# provisioner.myMessagingProvisioner.routingKey =

# Exchange type - Valid only for rabbitMq
# {valueType: "string", showEl: "${messagingType == 'RabbitMQ'}", formElement: "dropdown", optionValues: ["DIRECT", "TOPIC", "HEADERS", "FANOUT"]}
# provisioner.myMessagingProvisioner.exchangeType =

# Set up queue arguments
# {valueType: "boolean", order: 400, defaultValue: "false", subSection: "queueArguments"}
# provisioner.myMessagingProvisioner.setupQueueArguments =

# number of queue arguments
# {valueType: "integer", order: 401, subSection: "queueArguments", defaultValue: "0", showEl:"${setupQueueArguments}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myMessagingProvisioner.numberOfQueueArguments =

# Queue argument key
# {valueType: "string", order: 402, required: true, showEl: "${numberOfQueueArguments > $i$}", repeatGroup: "queueArgument", repeatCount: 20}
# provisioner.myMessagingProvisioner.queueArgument.$i$.key =

# Queue argument value
# {valueType: "string", order: 403, required: true, showEl: "${numberOfQueueArguments > $i$}", repeatGroup: "queueArgument", repeatCount: 20}
# provisioner.myMessagingProvisioner.queueArgument.$i$.value =

# (hardcoded)
# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", formElement: "dropdown", optionValues: ["membershipObjects"]}
# provisioner.myMessagingProvisioner.provisioningType =

# Select memberships
# {valueType: "boolean", order: 1500, defaultValue: "false", subSection: "membership", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectMemberships =

# Delete memberships if not exist in grouper
# {valueType: "boolean", order: 4500, defaultValue: "false", subSection: "membership", showEl: "${false}"}
# provisioner.myMessagingProvisioner.deleteMembershipsIfNotExistInGrouper =

# number of attributes for memberships
# {valueType: "integer", order: 5701, subSection: "membership", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myMessagingProvisioner.numberOfMembershipAttributes =

# Select groups
# {valueType: "boolean", order: 8500, defaultValue: "false", subSection: "group", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectGroups =

# Delete groups if not exist in grouper
# {valueType: "boolean", order: 10000, defaultValue: "false", subSection: "group", showEl: "${false}"}
# provisioner.myMessagingProvisioner.deleteGroupsIfNotExistInGrouper =

# if the groups need to be resolved in target
# {valueType: "boolean", defaultValue: "false", subSection: "group", showEl:"${false}", order: 12000}
# provisioner.myMessagingProvisioner.hasTargetGroupLink =

# Select entities
# {valueType: "boolean", order: 37500, defaultValue: "false", subSection: "entity", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectEntities =

# Select all entities
# {valueType: "boolean", order: 37600, defaultValue: "false", subSection: "entity", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectAllEntities =

# Delete entities if not exist in grouper
# {valueType: "boolean", order: 39500, defaultValue: "false", subSection: "entity", showEl: "${false}"}
# provisioner.myMessagingProvisioner.deleteEntitiesIfNotExistInGrouper =

# if the entities need to be resolved in target
# {valueType: "boolean", defaultValue: "false", showEl:"${false}", order: 53000, subSection: "entity"}
# provisioner.myMessagingProvisioner.hasTargetEntityLink =

# number of attributes for target groups
# {valueType: "integer", order: 19999, subSection: "group", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myMessagingProvisioner.numberOfGroupAttributes =

# number of attributes for target entities
# {valueType: "integer", order: 59000, subSection: "entity", defaultValue: "0", showEl:"${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.myMessagingProvisioner.numberOfEntityAttributes =

# Select all groups during diagnostics
# {valueType: "boolean", order: 78000, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectAllGroupsDuringDiagnostics =

# Select all entities during diagnostics
# {valueType: "boolean", order: 79000, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectAllEntitiesDuringDiagnostics =

# Select all memberships during diagnostics
# {valueType: "boolean", order: 80000, defaultValue: "false", subSection: "provisioningDiagnostics", showEl: "${false}"}
# provisioner.myMessagingProvisioner.selectAllMembershipsDuringDiagnostics =

# Can full sync
# {valueType: "boolean", order: 88000, defaultValue: "false", subSection: "advanced", showEl: "${false}"}
# provisioner.myMessagingProvisioner.canFullSync =

########################################
## Generic provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true}
# provisioner.genericDaoProvisioner.class = edu.internet2.middleware.grouper.app.genericProvisioner.GrouperGenericProvisioner

# If all you need is a DAO class, implement that and put the fully qualified class name here.  e.g. a.b.c.MyDao
# {valueType: "string", required: true, order: 20, mustExtendClass: "edu.internet2.middleware.grouper.app.provisioning.targetDao.GrouperProvisionerTargetDaoBase"}
# provisioner.genericDaoProvisioner.genericProvisionerDaoClassName =


########################################
## Google GCP provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true}
# provisioner.myGoogleProvisioner.class = edu.internet2.middleware.grouper.app.google.GrouperGoogleProvisioner

# this is the google external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.google.GoogleGrouperExternalSystem"}
# provisioner.myGoogleProvisioner.googleExternalSystemConfigId =

# This provisioner must use membership objects
# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", formElement: "dropdown", optionValues: ["membershipObjects"]}
# provisioner.myGoogleProvisioner.provisioningType =

# Default message deny notification text
# {valueType: "string", order: 18001, subSection: "group", showEl: "${operateOnGrouperGroups && selectGroups}"}
# provisioner.myGoogleProvisioner.defaultMessageDenyNotificationText =

# How to handle deleted group
# {valueType: "string", defaultValue: "delete", order: 18002, subSection: "group", showEl:"${operateOnGrouperGroups && customizeGroupCrud && deleteGroups}", formElement: "dropdown", optionValues: ["archive", "delete"]}
# provisioner.myGoogleProvisioner.handleDeletedGroup =


# Message moderation level
# {valueType: "string", order: 18003, subSection: "group", showEl:"${operateOnGrouperGroups && selectGroups}", formElement: "dropdown", optionValues: ["MODERATE_ALL_MESSAGES", "MODERATE_NON_MEMBERS", "MODERATE_NEW_MEMBERS", "MODERATE_NONE"]}
# provisioner.myGoogleProvisioner.messageModerationLevel =

# Reply to 
# {valueType: "string", order: 18004, subSection: "group", showEl:"${operateOnGrouperGroups && selectGroups}", formElement: "dropdown", optionValues: ["REPLY_TO_SENDER", "REPLY_TO_LIST", "REPLY_TO_OWNER", "REPLY_TO_IGNORE", "REPLY_TO_MANAGERS"]}
# provisioner.myGoogleProvisioner.replyTo =

# Send Message Deny Notification
# {valueType: "boolean", order: 18005, subSection: "group", showEl:"${operateOnGrouperGroups && selectGroups}"}
# provisioner.myGoogleProvisioner.sendMessageDenyNotification =

# Spam Moderation Level
# {valueType: "string", order: 18006, subSection: "group", showEl:"${operateOnGrouperGroups && selectGroups}", formElement: "dropdown", optionValues: ["ALLOW", "MODERATE", "SILENTLY_MODERATE", "REJECT"]}
# provisioner.myGoogleProvisioner.spamModerationLevel =

# Name of the attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["allowExternalMembers", "allowGoogleCommunication", "allowWebPosting", "description", "email", "id", "name", "whoCanAdd", "whoCanInvite", "whoCanJoin", "whoCanPostMessage", "whoCanViewGroup", "whoCanViewMembership"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myGoogleProvisioner.targetGroupAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["email", "familyName", "givenName", "id", "orgUnitPath"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myGoogleProvisioner.targetEntityAttribute.$i$.name =

# If you want a metadata item on groups to configure who can add
# {valueType: "boolean", order: 18720, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.whoCanAdd =

# If you want a metadata item on groups to configure who can join the group
# {valueType: "boolean", order: 18750, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.whoCanJoin =

# If you want a metadata item on groups to configure who can view membership
# {valueType: "boolean", order: 18810, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.whoCanViewMembership =

# If you want a metadata item on groups to configure who can view group
# {valueType: "boolean", order: 18820, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.whoCanViewGroup =

# If you want a metadata item on groups to configure who can invite
# {valueType: "boolean", order: 18830, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.whoCanInvite =

# If you want a metadata item on groups to configure allowing external members
# {valueType: "boolean", order: 18840, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.allowExternalMembers =

# If you want a metadata item on groups to configure who can post message
# {valueType: "boolean", order: 18840, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.whoCanPostMessage =

# If you want a metadata item on groups to configure allowing web posting 
# {valueType: "boolean", order: 18840, defaultValue: "false", subSection: "group", showEl: "${operateOnGrouperGroups && provisioningType == 'membershipObjects'}"}
# provisioner.myGoogleProvisioner.allowWebPosting =

# milliseconds to sleep before trying to retrieve values after inserting them in target
# {valueType: "integer", subSection: "advanced", required: false, defaultValue: "15000", order: 158000, showEl: "${showAdvanced}"}
# provisioner.myGoogleProvisioner.sleepBeforeSelectAfterInsertMillis =


###############################################
## provisioner startWiths - sql common
###############################################
 
# this is the sql external system config id
# {order: 50, valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# provisionerStartWith.sqlCommon.dbExternalSystemConfigId =

# this is the sql external system config id
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.sqlCommon.startWith = sqlCommon

# Sql pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null}", optionValues: ["entityTable", "entityTableWithAttributeTable", "entityTableWithAttributeTableAndMemberships", "entityTableMembershipTable", "groupTable", "groupTableWithAttributeTable", "groupTableWithAttributeTableAndMemberships", "groupTableMembershipTable", "groupTableEntityTableMembershipTable", "membershipTable", "other"]}
# provisionerStartWith.sqlCommon.sqlPattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null}", optionValues: ["core",  "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.sqlCommon.userAttributesType =

# Membership structure
# {valueType: "string", order: 200, defaultValue: "membershipObjects", formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null}", optionValues: ["entityAttributes", "groupAttributes", "membershipObjects", "notApplicable"]}
# provisionerStartWith.sqlCommon.membershipStructure =

# subject source entity resolver attributes
# {valueType: "string", order: 300, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.sqlCommon.subjectSourceEntityResolverAttributes =

# has group table
# {valueType: "boolean", order: 400, defaultValue: "false", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null}"}
# provisionerStartWith.sqlCommon.hasGroupTable =

# group table name
# {valueType: "string", order: 500, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable}"}
# provisionerStartWith.sqlCommon.groupTableName =

# group table primary column
# {valueType: "string", order: 600, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable}"}
# provisionerStartWith.sqlCommon.groupTableIdColumn =

# group table primary key value
# {valueType: "string", order: 650, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.sqlCommon.groupTablePrimaryKeyValue =

# group table primary key value translation script
# {valueType: "string", order: 660, required: true, showEl: "${sqlPattern != null && groupTablePrimaryKeyValue == 'script'}"}
# provisionerStartWith.sqlCommon.groupTablePrimaryKeyValueTranslationScript =

# group table column names comma separated
# {valueType: "string", order: 700, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable}"}
# provisionerStartWith.sqlCommon.groupTableColumnNames =

# need group link?
# {valueType: "boolean", order: 800, defaultValue: "false", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable}"}
# provisionerStartWith.sqlCommon.hasTargetGroupLink =

# has group attribute table?
# {valueType: "boolean", order: 900, defaultValue: "false", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable}"}
# provisionerStartWith.sqlCommon.hasGroupAttributeTable =

# group attribute table name
# {valueType: "string", order: 1000, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable}"}
# provisionerStartWith.sqlCommon.groupAttributesTableName =

# column name which is foreign key to group table
# {valueType: "string", order: 1100, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable}"}
# provisionerStartWith.sqlCommon.groupAttributesGroupForeignKeyColumn =

# column name which is the attribute name
# {valueType: "string", order: 1200, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable}"}
# provisionerStartWith.sqlCommon.groupAttributesAttributeNameColumn =

# column name which is the attribute value
# {valueType: "string", order: 1300, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable}"}
# provisionerStartWith.sqlCommon.groupAttributesAttributeValueColumn = 

# membership attribute name
# {valueType: "string", order: 1400, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable && membershipStructure == 'groupAttributes'}"}
# provisionerStartWith.sqlCommon.groupMembershipAttributeName =

# membership attribute value
# {valueType: "string", order: 1500, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable && membershipStructure == 'groupAttributes'}", optionValues: ["email", "entityPrimaryKey", "idIndex", "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.sqlCommon.groupMembershipAttributeValue =

# entity attribute name for memberships
# {valueType: "string", order: 1550, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable && membershipStructure == 'groupAttributes'}"}
# provisionerStartWith.sqlCommon.entityAttributeNameForMemberships =

# membership attribute value translation script
# {valueType: "string", order: 1560, required: true, showEl: "${sqlPattern != null && groupMembershipAttributeValue == 'script'}"}
# provisionerStartWith.sqlCommon.groupMembershipAttributeValueTranslationScript =

# other attribute names in attribute table
# {valueType: "string", order: 1600, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasGroupTable && hasGroupAttributeTable}"}
# provisionerStartWith.sqlCommon.groupOtherAttributeNames =

# has entity table
# {valueType: "boolean", order: 1700, defaultValue: "false", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null}"}
# provisionerStartWith.sqlCommon.hasEntityTable =

# entity table name
# {valueType: "string", order: 1800, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable}"}
# provisionerStartWith.sqlCommon.entityTableName =

# entity table primary column
# {valueType: "string", order: 1900, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable}"}
# provisionerStartWith.sqlCommon.entityTableIdColumn =

# entity table primary key value
# {valueType: "string", order: 2000, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable}", optionValues: ["email", "idIndex", "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2", "uuid"]}
# provisionerStartWith.sqlCommon.entityTablePrimaryKeyValue =

# entity table primary key value translation script
# {valueType: "string", order: 2010, required: true, showEl: "${sqlPattern != null && entityTablePrimaryKeyValue == 'script'}"}
# provisionerStartWith.sqlCommon.entityTablePrimaryKeyValueTranslationScript =

# other entity table column names
# {valueType: "string", order: 2100, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable}"}
# provisionerStartWith.sqlCommon.entityTableColumnNames =

# manage entities
# {valueType: "boolean", order: 2150, required: true, showEl: "${hasEntityTable}"}
# provisionerStartWith.sqlCommon.manageEntities =

# need entity link?
# {valueType: "boolean", order: 2200, defaultValue: "false", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable}"}
# provisionerStartWith.sqlCommon.hasTargetEntityLink =

# has entity attribute table?
# {valueType: "boolean", order: 2300, defaultValue: "false", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable}"}
# provisionerStartWith.sqlCommon.hasEntityAttributeTable =

# entity attribute table name
# {valueType: "string", order: 2400, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable}"}
# provisionerStartWith.sqlCommon.entityAttributesTableName =

# column name which is foreign key to entity table
# {valueType: "string", order: 2500, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable}"}
# provisionerStartWith.sqlCommon.entityAttributesEntityForeignKeyColumn =

# column name which is the attribute name
# {valueType: "string", order: 2600, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable}"}
# provisionerStartWith.sqlCommon.entityAttributesAttributeNameColumn =

# column name which is the attribute value
# {valueType: "string", order: 2700, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable}"}
# provisionerStartWith.sqlCommon.entityAttributesAttributeValueColumn =

# membership attribute name
# {valueType: "string", order: 2800, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable && membershipStructure == 'entityAttributes'}"}
# provisionerStartWith.sqlCommon.entityMembershipAttributeName =

# membership attribute value
# {valueType: "string", order: 2900, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable && membershipStructure == 'entityAttributes'}", optionValues: ["extension", "groupPrimaryKey", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.sqlCommon.entityMembershipAttributeValue =

# group attribute name for memberships
# {valueType: "string", order: 2925, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable && membershipStructure == 'entityAttributes'}"}
# provisionerStartWith.sqlCommon.groupAttributeNameForMemberships =

# membership attribute value translation script
# {valueType: "string", order: 2950, required: true, showEl: "${sqlPattern != null && entityMembershipAttributeValue == 'script'}"}
# provisionerStartWith.sqlCommon.entityMembershipAttributeValueTranslationScript =

# other attribute names in attribute table
# {valueType: "string", order: 3000, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && hasEntityTable && hasEntityAttributeTable}"}
# provisionerStartWith.sqlCommon.entityOtherAttributeNames =

# membership table name
# {valueType: "string", order: 3150, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && membershipStructure == 'membershipObjects'}"}
# provisionerStartWith.sqlCommon.membershipTableName =

# group column 
# {valueType: "string", order: 3200, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && membershipStructure == 'membershipObjects'}"}
# provisionerStartWith.sqlCommon.membershipTableGroupColumn =

# group value 
# {valueType: "string", order: 3300, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && membershipStructure == 'membershipObjects'}", optionValues: ["extension", "groupPrimaryKey", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.sqlCommon.membershipTableGroupValue =

# group attribute to hold the script calculation for memberships
# {valueType: "string", order: 3325, required: true, showEl: "${sqlPattern != null && (membershipTableGroupValue == 'script' || membershipTableGroupValue == 'other')}"}
# provisionerStartWith.sqlCommon.membershipGroupMembershipAttributeName =

# group value translation script
# {valueType: "string", order: 3350, required: true, showEl: "${sqlPattern != null && membershipTableGroupValue == 'script'}"}
# provisionerStartWith.sqlCommon.membershipTableGroupValueTranslationScript =

# entity column 
# {valueType: "string", order: 3400, required: true, showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && membershipStructure == 'membershipObjects'}"}
# provisionerStartWith.sqlCommon.membershipTableEntityColumn =

# entity value 
# {valueType: "string", order: 3500, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null && membershipStructure == 'membershipObjects'}", optionValues: ["email", "entityPrimaryKey", "idIndex", "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2", "uuid"]}
# provisionerStartWith.sqlCommon.membershipTableEntityValue =

# entity attribute to hold the script calculation for memberships
# {valueType: "string", order: 3525, required: true, showEl: "${sqlPattern != null && (membershipTableEntityValue == 'script' || membershipTableEntityValue == 'other')}"}
# provisionerStartWith.sqlCommon.membershipEntityMembershipAttributeName =

# entity value translation script
# {valueType: "string", order: 3550, required: true, showEl: "${sqlPattern != null && membershipTableEntityValue == 'script'}"}
# provisionerStartWith.sqlCommon.membershipTableEntityValueTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 3600, defaultValue: "true", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null}"}
# provisionerStartWith.sqlCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 3700, defaultValue: "true", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null && userAttributesType != null}"}
# provisionerStartWith.sqlCommon.addDisabledIncrementalSyncDaemon =

###############################################
## provisioner startWiths - midpoint start with
###############################################
 
# this is the sql external system config id
# {order: 50, valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# provisionerStartWith.midpointStartWith.dbExternalSystemConfigId =

# pick the start with
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.midpointStartWith.startWith = midpointStartWith

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${dbExternalSystemConfigId != null && sqlPattern != null}", optionValues: ["core",  "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.midpointStartWith.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 300, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.midpointStartWith.subjectSourceEntityResolverAttributes =

# MidPoint tables prefix.  
# {valueType: "string", order: 500, showEl: "${dbExternalSystemConfigId != null userAttributesType != null}"}
# provisionerStartWith.midpointStartWith.midPointTablesPrefix =

# Do you want target attribute to be stored in the group attributes table?
# {valueType: "string", order: 600, defaultValue: "true", showEl: "${dbExternalSystemConfigId != null && userAttributesType != null}"}
# provisionerStartWith.midpointStartWith.midPointHasTargetAttribute =

# List of targets
# {valueType: "string", order: 700, showEl: "${dbExternalSystemConfigId != null && userAttributesType != null}"}
# provisionerStartWith.midpointStartWith.midPointListOfTargets =

# add disabled full sync daemon?
# {valueType: "boolean", order: 3600, defaultValue: "true", showEl: "${dbExternalSystemConfigId != null && userAttributesType != null}"}
# provisionerStartWith.midpointStartWith.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 3700, defaultValue: "true", showEl: "${dbExternalSystemConfigId != null && userAttributesType != null}"}
# provisionerStartWith.midpointStartWith.addDisabledIncrementalSyncDaemon =

################################################
## provisioner startWith - ldap memberships
################################################

# Ldap memberships
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.ldapMemberships.startWith = ldapMemberships

# this is the ldap external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.externalSystem.LdapGrouperExternalSystem"}
# provisionerStartWith.ldapMemberships.ldapExternalSystemConfigId =

# Ldap pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${ldapExternalSystemConfigId != null}", optionValues: ["activeDirectoryGroups", "bushyGroupsWithMembershipDNs", "bushyGroupsWithMembershipSubjectIds", "flatGroupsWithMembershipDNs", "flatGroupsWithMembershipSubjectIds", "groupOfNames", "other", "posixGroups", "usersWithEduPersonAffiliations", "usersWithEduPersonEntitlements", "usersWithMembershipGroupExtensions", "usersWithMembershipGroupNames"]}
# provisionerStartWith.ldapMemberships.ldapPattern =

# Membership structure
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${ldapPattern != null}", optionValues: ["groupAttributes", "entityAttributes"]}
# provisionerStartWith.ldapMemberships.membershipStructure =

# membershipValue is DN? 
# {valueType: "boolean", order: 400, required: true, showEl: "${membershipStructure != null}"}
# provisionerStartWith.ldapMemberships.membershipValueDn =

# Group organization: bushy or flat
# {valueType: "string", order: 500, required: true, formElement: "dropdown", showEl: "${!onlyLdapGroupDnOverride && membershipValueDn != null && membershipStructure == 'groupAttributes'}", optionValues: ["bushy", "flat"]}
# provisionerStartWith.ldapMemberships.groupDnType =

# User attributes type
# {valueType: "string", order: 550, required: true, formElement: "dropdown", showEl: "${groupDnType != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.ldapMemberships.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 600, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.ldapMemberships.subjectSourceEntityResolverAttributes =

# group link needed for another reason?
# {valueType: "boolean", order: 700, defaultValue: "false", showEl: "${membershipStructure != null && membershipStructure != 'groupAttributes' && !membershipValueDn}"}
# provisionerStartWith.ldapMemberships.groupLinkForAnotherReason =

# group base OU
# {valueType: "string", order: 800, required: true, showEl: "${!onlyLdapGroupDnOverride && (groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn)}"}
# provisionerStartWith.ldapMemberships.groupSearchBaseDn =

# Select all groups at once during full sync
# {valueType: "boolean", order: 850, defaultValue: "true", showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.selectAllGroups =

# what attribute is RDN for groups?
# {valueType: "string", order: 900, required: true, showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.groupRdnAttribute =

# what is RDN value for groups?
# {valueType: "string", order: 1000, required: true, formElement: "dropdown", showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}", optionValues: ["extension", "extensionUnderscoreIdIndex",  "id", "idIndex", "idIndexString", "name", "nameBackwardsUnderscoreMax64", "other", "script"]}
# provisionerStartWith.ldapMemberships.rdnValueForGroups =

# Translation script for RDN value for groups
# {valueType: "string", order: 1050, indent: 1, required: true, showEl: "${rdnValueForGroups == 'script'}"}
# provisionerStartWith.ldapMemberships.rdnValueForGroupsTranslationScript =

# Membership attribute name for groups
# {valueType: "string", order: 1100, required: true, showEl: "${membershipStructure == 'groupAttributes'}"}
# provisionerStartWith.ldapMemberships.membershipAttributeNameForGroups =

# Membership value for groups
# {valueType: "string", order: 1120, required: true, formElement: "dropdown", showEl: "${membershipStructure == 'groupAttributes' && !membershipValueDn}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.ldapMemberships.membershipValueForGroups =

# Translation script for membership value for groups
# {valueType: "string", order: 1130, indent: 1, required: true, showEl: "${membershipValueForGroups == 'script'}"}
# provisionerStartWith.ldapMemberships.membershipValueForGroupsTranslationScript =

# Membership attribute default value
# {valueType: "string", order: 1150, showEl: "${membershipStructure == 'groupAttributes' && (ldapPattern == 'bushyGroupsWithMembershipDNs' || ldapPattern == 'flatGroupsWithMembershipDNs' || ldapPattern == 'groupOfNames' || ldapPattern == 'other')}"}
# provisionerStartWith.ldapMemberships.membershipAttributeDefaultValue =

# IdIndex attribute
# {valueType: "string", order: 1300, showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.idIndexAttribute =

# matching search attribute different than RDN or idIndex? boolean default false
# {valueType: "boolean", order: 1400, defaultValue: "false", showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeDifferentThanRdnorIdIndex =

# matching search attribute name for groups
# {valueType: "string", order: 1500, required: true, showEl: "${ (groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn) && (matchingSearchAttributeDifferentThanRdnorIdIndex)}"}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeNameForGroups =

# matching search attribute value for groups
# {valueType: "string", order: 1600, required: true, formElement: "dropdown", showEl: "${ (groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn) && (matchingSearchAttributeDifferentThanRdnorIdIndex)}", optionValues: ["extension", "id", "idIndex", "name", "other", "script"]}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeValueForGroups =

# Translation script for matching search attribute value for groups
# {valueType: "string", order: 1650, indent: 1, required: true, showEl: "${matchingSearchAttributeValueForGroups == 'script'}"}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeValueForGroupsTranslationScript =

# object classes for groups
# {valueType: "string", order: 1700, showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.objectClassesForGroups =

# list other group ldap attributes (not configured yet)
# {valueType: "string", order: 1800, showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.otherGroupLdapAttributes =

# if allow group DN override
# {valueType: "boolean", order: 1900, defaultValue: "false", showEl: "${groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.allowLdapGroupDnOverride =

# if only group DN override
# {valueType: "boolean", order: 1950, defaultValue: "false", showEl: "${allowLdapGroupDnOverride && (groupLinkForAnotherReason || membershipStructure == 'groupAttributes' || membershipValueDn)}"}
# provisionerStartWith.ldapMemberships.onlyLdapGroupDnOverride =

# if need entity link for another reason
# {valueType: "boolean", order: 2000, defaultValue: "false", showEl: "${membershipStructure != null && membershipStructure != 'entityAttributes' && !membershipValueDn}"}
# provisionerStartWith.ldapMemberships.entityLinkForAnotherReason =

# Entity base OU
# {valueType: "string", order: 2100, required: true, showEl: "${entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.userSearchBaseDn =

# Select all entities at once during full sync
# {valueType: "boolean", order: 2150, required: true, showEl: "${entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn || userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.ldapMemberships.selectAllEntities = 

# change entities in LDAP (besides entity attribute if doing entity attributes)?
# {valueType: "boolean", order: 2200, defaultValue: "false", showEl: "${entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.changeEntitiesInLdap =

# RDN attribute for entities
# {valueType: "string", order: 2300, required: true, showEl: "${ (entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn) && (changeEntitiesInLdap)}"}
# provisionerStartWith.ldapMemberships.userRdnAttribute =

# what is RDN value for entities
# {valueType: "string", order: 2400, required: true, formElement: "dropdown", showEl: "${ (entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn) && (changeEntitiesInLdap)}", optionValues: ["other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.ldapMemberships.rdnValueForEntities =

# Translation script for RDN value for entities
# {valueType: "string", order: 2450, indent: 1, required: true, showEl: "${rdnValueForEntities == 'script'}"}
# provisionerStartWith.ldapMemberships.rdnValueForEntitiesTranslationScript =

# Membership attribute name for entities
# {valueType: "string", order: 2500, required: true, showEl: "${membershipStructure == 'entityAttributes'}"}
# provisionerStartWith.ldapMemberships.membershipAttributeNameForEntities =

# Membership value for entities
# {valueType: "string", order: 2600, required: true, formElement: "dropdown", showEl: "${ (entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn) && (!membershipValueDn)}", optionValues: ["extension", "idIndex", "name", "other", "script", "id"]}
# provisionerStartWith.ldapMemberships.membershipValueForEntities =

# Translation script for membership value for entities
# {valueType: "string", order: 2650, indent: 1, required: true, showEl: "${membershipValueForEntities == 'script'}"}
# provisionerStartWith.ldapMemberships.membershipValueForEntitiesTranslationScript =

# matching search attribute different than RDN?
# {valueType: "boolean", order: 2700, defaultValue: "false", showEl: "${ (entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn) && (changeEntitiesInLdap)}"}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeDifferentThanRDN =

# matching/search attribute name for entities
# {valueType: "string", order: 2800, required: true, showEl: "${ (entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn) && (!changeEntitiesInLdap || matchingSearchAttributeDifferentThanRDN)}"}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeNameForEntities =

# matching/search attribute value for entities
# {valueType: "string", order: 2900, required: true, formElement: "dropdown", showEl: "${ (entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn) && (!changeEntitiesInLdap || matchingSearchAttributeDifferentThanRDN)}", optionValues: ["other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeValueForEntities =

# Translation script for matching/search attribute value for entities
# {valueType: "string", order: 2950, indent: 1, required: true, showEl: "${matchingSearchAttributeValueForEntities == 'script'}"}
# provisionerStartWith.ldapMemberships.matchingSearchAttributeValueForEntitiesTranslationScript =

# object classes for entities
# {valueType: "string", order: 3000, showEl: "${entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.objectClassesForEntities =

# list other entity ldap attributes (not configured yet)
# {valueType: "string", order: 3100, showEl: "${entityLinkForAnotherReason || membershipStructure == 'entityAttributes' || membershipValueDn}"}
# provisionerStartWith.ldapMemberships.otherEntityLdapAttributes =

# add disabled full sync daemon?
# {valueType: "boolean", order: 3300, defaultValue: "true", showEl: "${membershipStructure != null}"}
# provisionerStartWith.ldapMemberships.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 3400, defaultValue: "true", showEl: "${membershipStructure != null}"}
# provisionerStartWith.ldapMemberships.addDisabledIncrementalSyncDaemon =

################################################
## provisioner startWith - Azure
################################################

# azure common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.azureCommon.startWith = azureCommon

# this is the azure external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.azure.AzureGrouperExternalSystem"}
# provisionerStartWith.azureCommon.azureExternalSystemConfigId =

# Azure pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${azureExternalSystemConfigId != null}", optionValues: ["manageGroupsManageEntities", "manageGroupsReadonlyEntities", "other"]}
# provisionerStartWith.azureCommon.azurePattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.azureCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.azureCommon.subjectSourceEntityResolverAttributes =

# Select all groups at once during full sync
# {valueType: "boolean", order: 250, required: true, showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.selectAllGroups =

# group display name attribute value
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["extension", "idIndex", "name", "other", "script", "id"]}
# provisionerStartWith.azureCommon.groupDisplayNameAttributeValue =

# group display name translation script
# {valueType: "string", order: 350, required: true, showEl: "${azurePattern != null && groupDisplayNameAttributeValue == 'script'}"}
# provisionerStartWith.azureCommon.groupDisplayNameTranslationScript =

# use group description
# {valueType: "boolean", order: 400, defaultValue: "true", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.useGroupDescription =

# group mailNickname attribute value
# {valueType: "string", order: 500, required: true, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["extension", "idIndex", "name", "other", "script", "id"]}
# provisionerStartWith.azureCommon.mailNicknameAttributeValue =

# group mailNickname translation script
# {valueType: "string", order: 550, required: true, showEl: "${azurePattern != null && mailNicknameAttributeValue == 'script'}"}
# provisionerStartWith.azureCommon.mailNicknameTranslationScript =

# group search/matching attribute
# {valueType: "string", order: 560, required: true, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["displayName", "mailNickname"]}
# provisionerStartWith.azureCommon.groupSearchMatchingAttribute =

# has metadata for 'group type'
# {valueType: "boolean", order: 600, defaultValue: "true", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForGroupType =


# has metadata for 'group owners'
# {valueType: "boolean", order: 650, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForGroupOwners =

# has metadata for allowOnlyMembersToPost
# {valueType: "boolean", order: 700, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForAllowOnlyMembersToPost =

# has metadata for hideGroupInOutlook
# {valueType: "boolean", order: 800, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForHideGroupInOutlook =

# has metadata for subscribeNewGroupMembers
# {valueType: "boolean", order: 900, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForSubscribeNewGroupMembers =

# has metadata for welcomeEmailDisabled
# {valueType: "boolean", order: 1000, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForWelcomeEmailDisabled =

# has metadata for resourceProvisioningOptionsTeam
# {valueType: "boolean", order: 1100, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.hasMetadataForResourceProvisioningOptionsTeam =

# Select all entities at once during full sync
# {valueType: "boolean", order: 1150, required: true, showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.selectAllEntities =

# Entity user principal name
# {valueType: "string", order: 1200, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.azureCommon.entityUserPrincipalName =

# Entity user principal name translation script
# {valueType: "string", order: 1250, required: true, showEl: "${azurePattern != null && entityUserPrincipalName == 'script'}"}
# provisionerStartWith.azureCommon.entityUserPrincipalNameTranslationScript =

# Entity mail nickname
# {valueType: "string", order: 1300, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.azureCommon.entityMailNickname =

# Entity mail nickname translation script
# {valueType: "string", order: 1350, required: true, showEl: "${azurePattern != null && entityMailNickname == 'script'}"}
# provisionerStartWith.azureCommon.entityMailNicknameTranslationScript =

# Entity on premises immutable ID
# {valueType: "string", order: 1400, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.azureCommon.entityOnPremisesImmutableId =

# Entity on premises immutable ID translation script
# {valueType: "string", order: 1450, required: true, showEl: "${azurePattern != null && entityOnPremisesImmutableId == 'script'}"}
# provisionerStartWith.azureCommon.entityOnPremisesImmutableIdTranslationScript =

# Manage entities in Azure?
# {valueType: "boolean", order: 1500, defaultValue: "false", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.manageEntitiesInAzure =

# Entity display name
# {valueType: "string", order: 1600, required: true, formElement: "dropdown", showEl: "${azurePattern != null && manageEntitiesInAzure == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.azureCommon.entityDisplayName =

# Entity display name translation script
# {valueType: "string", order: 1650, required: true, showEl: "${azurePattern != null && entityDisplayName == 'script'}"}
# provisionerStartWith.azureCommon.entityDisplayNameTranslationScript =

# Entity search/matching attribute
# {valueType: "string", order: 1660, required: true, formElement: "dropdown", showEl: "${azurePattern != null}", optionValues: ["displayName", "mailNickname", "onPremisesImmutableId", "userPrincipalName"]}
# provisionerStartWith.azureCommon.entitySearchMatchingAttribute =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${azurePattern != null}"}
# provisionerStartWith.azureCommon.addDisabledIncrementalSyncDaemon =


################################################
## provisioner startWith - Duo
################################################

# duo common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.duoCommon.startWith = duoCommon

# this is the duo external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperDuo.DuoGrouperExternalSystem"}
# provisionerStartWith.duoCommon.duoExternalSystemConfigId =

# Duo pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${duoExternalSystemConfigId != null}", optionValues: ["manageGroupsManageEntities", "manageGroupsReadonlyEntities", "manageEntities", "other"]}
# provisionerStartWith.duoCommon.duoPattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${duoPattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.duoCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.duoCommon.subjectSourceEntityResolverAttributes =

# Select all groups at once during full sync
# {valueType: "boolean", order: 230, defaultValue: "false", showEl: "${duoPattern != null}"}
# provisionerStartWith.duoCommon.selectAllGroups =

# manage groups
# {valueType: "boolean", order: 250, defaultValue: "false", showEl: "${duoPattern != null}"}
# provisionerStartWith.duoCommon.manageGroups =

# group name attribute value                                                                                       
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${manageGroups == true}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.duoCommon.groupNameAttributeValue =

# group name translation script
# {valueType: "string", order: 350, required: true, showEl: "${duoPattern != null && groupNameAttributeValue == 'script'}"}
# provisionerStartWith.duoCommon.groupNameTranslationScript =

# use group description
# {valueType: "boolean", order: 400, defaultValue: "true", showEl: "${manageGroups == true}"}
# provisionerStartWith.duoCommon.useGroupDescription =

# manage entities
# {valueType: "boolean", order: 500, defaultValue: "false", showEl: "${duoPattern != null}"}
# provisionerStartWith.duoCommon.manageEntities =

# Select all entities at once during full sync
# {valueType: "boolean", order: 550, required: true, showEl: "${duoPattern != null}"}
# provisionerStartWith.duoCommon.selectAllEntities =

# Entity user name
# {valueType: "string", order: 600, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoCommon.entityUserName =

# Entity username translation script
# {valueType: "string", order: 650, required: true, showEl: "${duoPattern != null && entityUserName == 'script'}"}
# provisionerStartWith.duoCommon.entityUserNameTranslationScript =

# Entity name 
# {valueType: "string", order: 700, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoCommon.entityNameSubjectAttribute =

# Entity name translation script
# {valueType: "string", order: 750, required: true, showEl: "${duoPattern != null && entityNameSubjectAttribute == 'script'}"}
# provisionerStartWith.duoCommon.entityNameTranslationScript =

# Entity last name
# {valueType: "string", order: 800, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectAttribute", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoCommon.entityLastName =

# Entity last name subject attribute
# {valueType: "string", order: 825, required: true, showEl: "${duoPattern != null && entityLastName == 'subjectAttribute'}"}
# provisionerStartWith.duoCommon.subjectLastNameAttribute =

# Entity last name translation script
# {valueType: "string", order: 850, required: true, showEl: "${duoPattern != null && entityLastName == 'script'}"}
# provisionerStartWith.duoCommon.entityLastNameTranslationScript =

# Entity first name subject attribute
# {valueType: "string", order: 875, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectAttribute", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoCommon.entityFirstName =

# Entity first name subject attribute
# {valueType: "string", order: 900, required: true, showEl: "${duoPattern != null && entityFirstName == 'subjectAttribute'}"}
# provisionerStartWith.duoCommon.subjectFirstNameAttribute =

# Entity first name translation script
# {valueType: "string", order: 925, required: true, showEl: "${duoPattern != null && entityFirstName == 'script'}"}
# provisionerStartWith.duoCommon.entityFirstNameTranslationScript =

# Entity email subject attribute
# {valueType: "string", order: 1000, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoCommon.entityEmailSubjectAttribute =

# Entity email translation script
# {valueType: "string", order: 1050, required: true, showEl: "${duoPattern != null && entityEmailSubjectAttribute == 'script'}"}
# provisionerStartWith.duoCommon.entityEmailTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${duoPattern != null}"}
# provisionerStartWith.duoCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${duoPattern != null}"}
# provisionerStartWith.duoCommon.addDisabledIncrementalSyncDaemon =


################################################
## provisioner startWith - Duo Role
################################################

# duo role common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.duoRoleCommon.startWith = duoRoleCommon

# this is the duo external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperDuo.DuoGrouperExternalSystem"}
# provisionerStartWith.duoRoleCommon.duoExternalSystemConfigId =

# Duo pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${duoExternalSystemConfigId != null}", optionValues: ["manageRolesManageEntities", "manageRolesReadonlyEntities", "other"]}
# provisionerStartWith.duoRoleCommon.duoRolePattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${duoRolePattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.duoRoleCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.duoRoleCommon.subjectSourceEntityResolverAttributes =

# group name attribute value                                                                                       
# {valueType: "string", order: 300, required: true, formElement: "dropdown", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.duoRoleCommon.roleAttributeValue =

# group name translation script
# {valueType: "string", order: 350, required: true, showEl: "${duoRolePattern != null && roleAttributeValue == 'script'}"}
# provisionerStartWith.duoRoleCommon.roleTranslationScript =

# manage entities
# {valueType: "boolean", order: 500, defaultValue: "false", showEl: "${duoRolePattern != null}"}
# provisionerStartWith.duoRoleCommon.manageEntities =

# Select all entities at once during full sync
# {valueType: "boolean", order: 550, required: true, showEl: "${duoRolePattern != null}"}
# provisionerStartWith.duoRoleCommon.selectAllEntities =

# Entity name subject attribute
# {valueType: "string", order: 700, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoRoleCommon.entityNameSubjectAttribute =

# Entity name translation script
# {valueType: "string", order: 750, required: true, showEl: "${duoRolePattern != null && entityNameSubjectAttribute == 'script'}"}
# provisionerStartWith.duoRoleCommon.entityNameTranslationScript =

# Entity email subject attribute
# {valueType: "string", order: 1000, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.duoRoleCommon.entityEmailSubjectAttribute =

# Entity email translation script
# {valueType: "string", order: 1050, required: true, showEl: "${duoRolePattern != null && entityEmailSubjectAttribute == 'script'}"}
# provisionerStartWith.duoRoleCommon.entityEmailTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${duoRolePattern != null}"}
# provisionerStartWith.duoRoleCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${duoRolePattern != null}"}
# provisionerStartWith.duoRoleCommon.addDisabledIncrementalSyncDaemon =


################################################
## provisioner startWith - box
################################################

# box common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.boxCommon.startWith = boxCommon

# this is the box external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.boxProvisioner.BoxGrouperExternalSystem"}
# provisionerStartWith.boxCommon.boxExternalSystemConfigId =

# Box pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${boxExternalSystemConfigId != null}", optionValues: ["manageGroupsManageEntities", "manageGroupsReadonlyEntities", "manageEntities", "other"]}
# provisionerStartWith.boxCommon.boxPattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${boxPattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.boxCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.boxCommon.subjectSourceEntityResolverAttributes =

# Select all groups at once during full sync
# {valueType: "boolean", order: 230, defaultValue: "false", showEl: "${boxPattern != null}"}
# provisionerStartWith.boxCommon.selectAllGroups =

# manage groups
# {valueType: "boolean", order: 250, defaultValue: "false", showEl: "${boxPattern != null}"}
# provisionerStartWith.boxCommon.manageGroups =

# group name attribute value                                                                                       
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${manageGroups == true}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.boxCommon.groupNameAttributeValue =

# group name translation script
# {valueType: "string", order: 350, required: true, showEl: "${boxPattern != null && groupNameAttributeValue == 'script'}"}
# provisionerStartWith.boxCommon.groupNameTranslationScript =

# use group description
# {valueType: "boolean", order: 400, defaultValue: "true", showEl: "${manageGroups == true}"}
# provisionerStartWith.boxCommon.useGroupDescription =

# manage entities
# {valueType: "boolean", order: 500, defaultValue: "false", showEl: "${boxPattern != null}"}
# provisionerStartWith.boxCommon.manageEntities =

# Select all entities at once during full sync
# {valueType: "boolean", order: 550, required: true, showEl: "${boxPattern != null}"}
# provisionerStartWith.boxCommon.selectAllEntities =

# Entity name subject attribute
# {valueType: "string", order: 700, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.boxCommon.entityNameSubjectAttribute =

# Entity name translation script
# {valueType: "string", order: 750, required: true, showEl: "${boxPattern != null && entityNameSubjectAttribute == 'script'}"}
# provisionerStartWith.boxCommon.entityNameTranslationScript =

# Entity email subject attribute
# {valueType: "string", order: 1000, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.boxCommon.entityLoginSubjectAttribute =

# Entity email translation script
# {valueType: "string", order: 1050, required: true, showEl: "${boxPattern != null && entityLoginSubjectAttribute == 'script'}"}
# provisionerStartWith.boxCommon.entityLoginTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${boxPattern != null}"}
# provisionerStartWith.boxCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${boxPattern != null}"}
# provisionerStartWith.boxCommon.addDisabledIncrementalSyncDaemon =

################################################
## provisioner startWith - Google
################################################

# google common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.googleCommon.startWith = googleCommon

# this is the google external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.google.GoogleGrouperExternalSystem"}
# provisionerStartWith.googleCommon.googleExternalSystemConfigId =

# Google pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${googleExternalSystemConfigId != null}", optionValues: ["manageGroupsManageEntities", "manageGroupsReadonlyEntities", "manageEntities", "other"]}
# provisionerStartWith.googleCommon.googlePattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${googlePattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.googleCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.googleCommon.subjectSourceEntityResolverAttributes =

# Select all groups at once during full sync
# {valueType: "boolean", order: 230, defaultValue: "false", showEl: "${googlePattern != null}"}
# provisionerStartWith.googleCommon.selectAllGroups =

# manage groups
# {valueType: "boolean", order: 250, defaultValue: "false", showEl: "${googlePattern != null}"}
# provisionerStartWith.googleCommon.manageGroups =

# group name attribute value                                                                                       
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${manageGroups == true}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.googleCommon.groupNameAttributeValue =

# group name translation script
# {valueType: "string", order: 350, required: true, showEl: "${googlePattern != null && groupNameAttributeValue == 'script'}"}
# provisionerStartWith.googleCommon.groupNameTranslationScript =

# group email attribute value                                                                                       
# {valueType: "string", order: 360, required: true, formElement: "dropdown", showEl: "${manageGroups == true}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.googleCommon.groupEmailAttributeValue =

# group email translation script
# {valueType: "string", order: 370, required: true, showEl: "${googlePattern != null && groupEmailAttributeValue == 'script'}"}
# provisionerStartWith.googleCommon.groupEmailTranslationScript =

# use group description
# {valueType: "boolean", order: 400, defaultValue: "true", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.useGroupDescription =

# has metadata for 'who can add'
# {valueType: "boolean", order: 410, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForWhoCanAdd = 

# has metadata for 'who can join'
# {valueType: "boolean", order: 420, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForWhoCanJoin = 

# has metadata for 'who can view membership'
# {valueType: "boolean", order: 430, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForWhoCanViewMembership = 

# has metadata for 'who can view group'
# {valueType: "boolean", order: 440, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForWhoCanViewGroup = 

# has metadata for 'who can invite'
# {valueType: "boolean", order: 450, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForWhoCanInvite = 

# has metadata for 'allow external members'
# {valueType: "boolean", order: 460, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForAllowExternalMembers = 

# has metadata for 'who can post message'
# {valueType: "boolean", order: 470, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForWhoCanPostMessage = 

# has metadata for 'allow web hosting'
# {valueType: "boolean", order: 480, defaultValue: "false", showEl: "${manageGroups == true}"}
# provisionerStartWith.googleCommon.hasMetadataForAllowWebHosting = 

# manage entities
# {valueType: "boolean", order: 500, defaultValue: "false", showEl: "${googlePattern != null}"}
# provisionerStartWith.googleCommon.manageEntities =

# Select all entities at once during full sync
# {valueType: "boolean", order: 550, required: true, showEl: "${googlePattern != null}"}
# provisionerStartWith.googleCommon.selectAllEntities =

# Entity email subject attribute
# {valueType: "string", order: 560, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.googleCommon.entityEmailSubjectAttribute =

# Entity email translation script
# {valueType: "string", order: 570, required: true, showEl: "${googlePattern != null && entityEmailSubjectAttribute == 'script'}"}
# provisionerStartWith.googleCommon.entityEmailTranslationScript =

# Entity family name
# {valueType: "string", order: 600, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectAttribute", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.googleCommon.entityFamilyName =

# Entity family name subject attribute
# {valueType: "string", order: 601, required: true, showEl: "${googlePattern != null && entityFamilyName == 'subjectAttribute'}"}
# provisionerStartWith.googleCommon.subjectLastNameAttribute =

# Entity family name translation script
# {valueType: "string", order: 650, required: true, showEl: "${googlePattern != null && entityFamilyName == 'script'}"}
# provisionerStartWith.googleCommon.entityFamilyNameTranslationScript =

# Entity given name subject attribute
# {valueType: "string", order: 700, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectAttribute", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.googleCommon.entityGivenName =

# Entity given name subject attribute
# {valueType: "string", order: 701, required: true, showEl: "${googlePattern != null && entityGivenName == 'subjectAttribute'}"}
# provisionerStartWith.googleCommon.subjectFirstNameAttribute =

# Entity given name translation script
# {valueType: "string", order: 750, required: true, showEl: "${googlePattern != null && entityGivenName == 'script'}"}
# provisionerStartWith.googleCommon.entityGivenNameTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${googlePattern != null}"}
# provisionerStartWith.googleCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${googlePattern != null}"}
# provisionerStartWith.googleCommon.addDisabledIncrementalSyncDaemon =


################################################
## provisioner startWith - Remedy
################################################

# remedy common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.remedyCommon.startWith = remedyCommon

# this is the remedy external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.remedy.RemedyGrouperExternalSystem"}
# provisionerStartWith.remedyCommon.remedyExternalSystemConfigId =

# Remedy pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${remedyExternalSystemConfigId != null}", optionValues: ["manageGroupsManageEntities", "manageGroupsReadonlyEntities", "manageEntities", "other"]}
# provisionerStartWith.remedyCommon.remedyPattern =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${remedyPattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.remedyCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.remedyCommon.subjectSourceEntityResolverAttributes =

# Select all groups at once during full sync
# {valueType: "boolean", order: 230, defaultValue: "false", showEl: "${remedyPattern != null}"}
# provisionerStartWith.remedyCommon.selectAllGroups =

# manage groups
# {valueType: "boolean", order: 250, defaultValue: "false", showEl: "${remedyPattern != null}"}
# provisionerStartWith.remedyCommon.manageGroups =

# group name attribute value                                                                                       
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${manageGroups == true}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.remedyCommon.permissionGroupAttributeValue =

# group name translation script
# {valueType: "string", order: 350, required: true, showEl: "${remedyPattern != null && groupNameAttributeValue == 'script'}"}
# provisionerStartWith.remedyCommon.permissionGroupTranslationScript =

# manage entities
# {valueType: "boolean", order: 500, defaultValue: "false", showEl: "${remedyPattern != null}"}
# provisionerStartWith.remedyCommon.manageEntities =

# Select all entities at once during full sync
# {valueType: "boolean", order: 550, required: true, showEl: "${remedyPattern != null}"}
# provisionerStartWith.remedyCommon.selectAllEntities =

# Entity remedy login id
# {valueType: "string", order: 600, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.remedyCommon.loginId =

# Entity remedy login id translation script
# {valueType: "string", order: 650, required: true, showEl: "${remedyPattern != null && entityUserName == 'script'}"}
# provisionerStartWith.remedyCommon.loginIdTranslationScript =

# Entity username translation script
# {valueType: "string", order: 650, required: true, showEl: "${remedyPattern != null && entityUserName == 'script'}"}
# provisionerStartWith.remedyCommon.loginIdTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${remedyPattern != null}"}
# provisionerStartWith.remedyCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${remedyPattern != null}"}
# provisionerStartWith.remedyCommon.addDisabledIncrementalSyncDaemon =

################################################
## provisioner startWith - messaging
################################################

# messaging common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.messagingCommon.startWith = messagingCommon

# User attributes type
# {valueType: "string", order: 30, required: true, formElement: "dropdown", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.messagingCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 35, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.messagingCommon.subjectSourceEntityResolverAttributes =

# messaging type
# {valueType: "string", required: true, order: 50, formElement: "dropdown", optionValues: ["ActiveMQ", "AWS_SQS", "Grouper_Builtin", "RabbitMQ"]}
# provisionerStartWith.messagingCommon.messagingType =

# this is the messaging external system config id
# {valueType: "string", required: true, order: 75, showEl: "${messagingType == 'ActiveMQ'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperMessagingActiveMQ.ActiveMqGrouperExternalSystem"}
# provisionerStartWith.messagingCommon.messagingActiveMqExternalSystemConfigId =

# this is the messaging external system config id
# {valueType: "string", required: true, order: 100, showEl: "${messagingType == 'AWS_SQS'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperMessagingAWS.SqsGrouperExternalSystem"}
# provisionerStartWith.messagingCommon.messagingAwsSqsExternalSystemConfigId =

# this is the messaging external system config id
# {valueType: "string", required: true, order: 125, showEl: "${messagingType == 'RabbitMQ'}", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouperMessagingRabbitmq.RabbitMqGrouperExternalSystem"}
# provisionerStartWith.messagingCommon.messagingRabbitMqExternalSystemConfigId =

# target type - queue or topic
# {valueType: "string", required: true, order: 150, showEl: "${messagingType != null && messagingType != 'AWS_SQS'}", formElement: "dropdown", optionValues: ["queue", "topic"]}
# provisionerStartWith.messagingCommon.queueType =

# queue or topic name
# {valueType: "string", required: true, order: 175, showEl: "${messagingType != null}"}
# provisionerStartWith.messagingCommon.queueOrTopicName =

# routing key - Valid only for rabbitMq
# {valueType: "string", order: 200, showEl: "${messagingType == 'RabbitMQ'}"}
# provisionerStartWith.messagingCommon.routingKey =

# Exchange type - Valid only for rabbitMq
# {valueType: "string", showEl: "${messagingType == 'RabbitMQ'}", formElement: "dropdown", optionValues: ["DIRECT", "TOPIC", "HEADERS", "FANOUT"]}
# provisionerStartWith.messagingCommon.exchangeType =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${messagingType != null}"}
# provisionerStartWith.messagingCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${messagingType != null}"}
# provisionerStartWith.messagingCommon.addDisabledIncrementalSyncDaemon =


################################################
## provisioner startWith - Scim 2
################################################

# scim common
# {valueType: "string", order: 25, readOnly: true}
# provisionerStartWith.scimCommon.startWith = scimCommon

# bearer token external system id
# {valueType: "string", required: true, order: 30, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.externalSystem.WsBearerTokenExternalSystem"}
# provisionerStartWith.scimCommon.bearerTokenExternalSystemConfigId =

# Scim pattern
# {valueType: "string", order: 50, required: true, formElement: "dropdown", showEl: "${bearerTokenExternalSystemConfigId != null}", optionValues: ["awsGroupsEntitiesMemberships", "githubEntities", "other"]}
# provisionerStartWith.scimCommon.scimPattern =

# Scim type
# {valueType: "string", order: 60, required: true, formElement: "dropdown", showEl: "${scimPattern != null}", optionValues: ["AWS", "Github", "generic"]}
# provisionerStartWith.scimCommon.scimType =

# User attributes type
# {valueType: "string", order: 100, required: true, formElement: "dropdown", showEl: "${scimPattern != null}", optionValues: ["core", "entityResolver", "subjectSource", "subjectSourceAndEntityResolver"]}
# provisionerStartWith.scimCommon.userAttributesType =

# subject source entity resolver attributes
# {valueType: "string", order: 200, required: true, showEl: "${userAttributesType == 'subjectSource' || userAttributesType == 'subjectSourceAndEntityResolver'}"}
# provisionerStartWith.scimCommon.subjectSourceEntityResolverAttributes =

# Select all groups at once during full sync
# {valueType: "boolean", order: 230, defaultValue: "false", showEl: "${scimPattern != null && scimType != 'Github'}"}
# provisionerStartWith.scimCommon.selectAllGroups =

# manage groups
# {valueType: "boolean", order: 250, defaultValue: "false", showEl: "${scimPattern != null && scimType != 'Github'}"}
# provisionerStartWith.scimCommon.manageGroups =

# group display name attribute value                                                                                       
# {valueType: "string", order: 300, required: true, formElement: "dropdown", showEl: "${manageGroups == true && scimType != 'Github'}", optionValues: ["extension", "idIndex", "name", "other", "script", "uuid"]}
# provisionerStartWith.scimCommon.groupDisplayNameAttributeValue =

# group display name translation script
# {valueType: "string", order: 350, required: true, showEl: "${scimPattern != null && groupDisplayNameAttributeValue == 'script'}"}
# provisionerStartWith.scimCommon.groupDisplayNameTranslationScript =

# manage entities
# {valueType: "boolean", order: 500, defaultValue: "false", showEl: "${scimPattern != null}"}
# provisionerStartWith.scimCommon.manageEntities =

# Select all entities at once during full sync
# {valueType: "boolean", order: 550, required: true, showEl: "${scimPattern != null}"}
# provisionerStartWith.scimCommon.selectAllEntities =

# Entity email subject attribute
# {valueType: "string", order: 560, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.scimCommon.entityEmailSubjectAttribute =

# Entity email translation script
# {valueType: "string", order: 570, required: true, showEl: "${scimPattern != null && entityEmailSubjectAttribute == 'script'}"}
# provisionerStartWith.scimCommon.entityEmailTranslationScript =

# Subject last name attribute
# {valueType: "string", order: 770, showEl: "${manageEntities == true && (scimType == 'AWS' or scimType == 'Github')}"}
# provisionerStartWith.scimCommon.subjectLastNameAttribute =

# Subject first name attribute
# {valueType: "string", order: 780, showEl: "${manageEntities == true && (scimType == 'AWS' or scimType == 'Github')}"}
# provisionerStartWith.scimCommon.subjectFirstNameAttribute =

# Entity username attribute
# {valueType: "string", order: 800, required: true, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.scimCommon.entityUsername =

# Entity username translation script
# {valueType: "string", order: 850, required: true, showEl: "${scimPattern != null && entityUsername == 'script'}"}
# provisionerStartWith.scimCommon.entityUsernameTranslationScript =

# Entity display name attribute
# {valueType: "string", order: 900, formElement: "dropdown", showEl: "${manageEntities == true}", optionValues: ["email", "idIndex", "name",  "other", "script", "subjectId", "subjectIdentifier0", "subjectIdentifier1", "subjectIdentifier2"]}
# provisionerStartWith.scimCommon.entityDisplayName =

# Entity display name translation script
# {valueType: "string", order: 950, required: true, showEl: "${scimPattern != null && entityDisplayName == 'script'}"}
# provisionerStartWith.scimCommon.entityDisplayNameTranslationScript =

# add disabled full sync daemon?
# {valueType: "boolean", order: 1700, defaultValue: "true", showEl: "${scimPattern != null}"}
# provisionerStartWith.scimCommon.addDisabledFullSyncDaemon =

# add disabled incremental sync daemon?
# {valueType: "boolean", order: 1800, defaultValue: "true", showEl: "${scimPattern != null}"}
# provisionerStartWith.scimCommon.addDisabledIncrementalSyncDaemon =


#####################################################
## subject change daemon
#####################################################
 
# set this for subject change daemon
# {valueType: "class", readOnly: true, mustExtendClass: "edu.internet2.middleware.grouper.app.loader.OtherJobBase"}
# otherJob.mySubjectChangeId.class = edu.internet2.middleware.grouper.app.usdu.SubjectChangeDaemon
 
# cron string
# {valueType: "cron", required: true}
# otherJob.mySubjectChangeId.quartzCron =
 
# which source to update subjects for
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.subjectSourceId$", required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.subject.provider.SourceManagerOptionValueDriver"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.subjectSourceId =
  
# database external system config id to hit, default to "grouper"
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.database$", formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.database =
 
# table with subject changes that need to be handled by this job, e.g. some_table.  or you can qualify by schema: some_schema.another_table
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.table$", required: true}
# otherJob.mySubjectChangeId.subjectChangeDaemon.table =
  
# look up subjects by id or identifier
# {valueType: "string", required: true, regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.useSubjectIdOrIdentifier$", formElement: "dropdown", optionValues: ["subjectId", "subjectIdentifier"]}
# otherJob.mySubjectChangeId.subjectChangeDaemon.useSubjectIdOrIdentifier =  
  
# subject id column
# {valueType: "string", required: true, showEl: "${subjectChangeDaemon.useSubjectIdOrIdentifier == 'subjectId'}",  regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.columnSubjectId$"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.columnSubjectId =  
 
# if finding subjects by identifier, this is the column that represents the identifier
# {valueType: "string", required: true, showEl: "${subjectChangeDaemon.useSubjectIdOrIdentifier == 'subjectIdentifier'}", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.columnSubjectIdentifier$"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.columnSubjectIdentifier =
 
# primary key column, e.g. col1
# {valueType: "string", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.columnPrimaryKey$", required: true}
# otherJob.mySubjectChangeId.subjectChangeDaemon.columnPrimaryKey =
 
# should processed rows by deleted
# {valueType: "boolean", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.deleteProcessedRows$", defaultValue: "false"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.deleteProcessedRows =
  
# name of a column that contains the timestamp of when a row is inserted
# {valueType: "string", required: true,  regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.columnCreateTimestamp$"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.columnCreateTimestamp =
  
# name of a column that would be updated with the timestamp of when a row has been processed
# {valueType: "string", required: true, showEl: "${subjectChangeDaemon.deleteProcessedRows == false}", regex: "^otherJob\\.([^.]+)\\.subjectChangeDaemon\\.columnProcessedTimestamp$"}
# otherJob.mySubjectChangeId.subjectChangeDaemon.columnProcessedTimestamp =

########################################
## midpoint provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.someMidpointProvisioner.class = edu.internet2.middleware.grouper.app.midpointProvisioning.MidPointProvisioner

# this is the sql external system config id
# {valueType: "string", order: 20, required: true, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.loader.db.DatabaseGrouperExternalSystem"}
# provisioner.someMidpointProvisioner.dbExternalSystemConfigId =

# this is the prefix for table names
# {valueType: "string", order: 50}
# provisioner.someMidpointProvisioner.midPointTablesPrefix =

# Do you want target attribute to be stored in the group attributes table?
# {valueType: "boolean", order: 60, defaultValue: "true"}
# provisioner.someMidpointProvisioner.midPointHasTargetAttribute = 

# comma separated list of targets
# {valueType: "string", order: 70, showEl: "${midPointHasTargetAttribute}"}
# provisioner.someMidpointProvisioner.midPointListOfTargets =

# provisioning type
# {valueType: "string", required: true, order: 1000, subSection: "membership", showEl: "${operateOnGrouperMemberships}", formElement: "dropdown", optionValues: ["membershipObjects"]}
# provisioner.someMidpointProvisioner.provisioningType =

# number of attributes for memberships
# {valueType: "integer", order: 5700, subSection: "membership", defaultValue: "0", showEl: "${false}", formElement: "dropdown", optionValues: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"] }
# provisioner.someMidpointProvisioner.numberOfMembershipAttributes =

# if the groups need to be resolved in target
# {valueType: "boolean", defaultValue: "false", subSection: "group", showEl: "${false}", order: 12000}
# provisioner.someMidpointProvisioner.hasTargetGroupLink =

# if the entities need to be resolved in target
# {valueType: "boolean", defaultValue: "false", showEl:"${false}", order: 53000, subSection: "entity"}
# provisioner.someMidpointProvisioner.hasTargetEntityLink =

# Matching ID expression
# {valueType: "string", order: 76510, subSection: "membership2", showEl: "${false}"}
# provisioner.someMidpointProvisioner.membershipMatchingIdExpression =

# generally the matching attribute(s) are the same as the search attributes, but they can be different
# {valueType: "boolean", defaultValue: "true", order: 77220, subSection: "group2", showEl: "${false}"}
# provisioner.someMidpointProvisioner.groupMatchingAttributeSameAsSearchAttribute = 

# how many group matching attributes
# {valueType: "integer", required: true, order: 77222, subSection: "group2", showEl: "${false}", formElement: "dropdown",  optionValues: ["1", "2", "3"] }
# provisioner.someMidpointProvisioner.groupMatchingAttributeCount = 

# Target group link - has groupAttributeValueCache?
# {valueType: "boolean", defaultValue: "false", subSection: "group2", showEl: "${false}", order: 78001}
# provisioner.someMidpointProvisioner.groupAttributeValueCacheHas =

# generally the matching attribute(s) are the same as the search attributes, but they can be different
# {valueType: "boolean", defaultValue: "true", order: 80220, subSection: "entity2", showEl: "${false}"}
# provisioner.someMidpointProvisioner.entityMatchingAttributeSameAsSearchAttribute =

# how many entity matching attributes
# {valueType: "integer", required: true, order: 80222, subSection: "entity2", showEl: "${false}", formElement: "dropdown",  optionValues: ["1", "2", "3"] }
# provisioner.someMidpointProvisioner.entityMatchingAttributeCount = 

# Target entity link - has entityAttributeValueCache?
# {valueType: "boolean", defaultValue: "false", subSection: "entity2", showEl: "${false}", order: 80301}
# provisioner.someMidpointProvisioner.entityAttributeValueCacheHas =

########################################
## institution specific provisioners
########################################

# This is the provisioner configuration class that extends edu.internet2.middleware.grouper.app.provisioning.ProvisioningConfiguration
# {valueType: "string", regex: "^grouperExtraProvisionerConfiguration\\.[^.]+\\.class$", mustExtendClass: "edu.internet2.middleware.grouper.app.provisioning.ProvisioningConfiguration"}
# grouperExtraProvisionerConfiguration.<configId>.class =


########################################
## remedy provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.myRemedyProvisioner.class = edu.internet2.middleware.grouper.app.remedyV2.GrouperRemedyProvisioner

# this is the remedy external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.remedy.RemedyGrouperExternalSystem"}
# provisioner.myRemedyProvisioner.remedyExternalSystemConfigId =

# Name of the group attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["permissionGroup", "permissionGroupId"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myRemedyProvisioner.targetGroupAttribute.$i$.name =

# Name of the entity attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["personId", "remedyLoginId"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myRemedyProvisioner.targetEntityAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 76710, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$}", formElement: "dropdown", optionValues: ["permissionGroup", "permissionGroupId", "personId", "remedyLoginId"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.myRemedyProvisioner.targetMembershipAttribute.$i$.name =

########################################
## remedy digital marketplace provisioner
########################################

# provisioner class
# {valueType: "class", required: true, readOnly: true, order: 10}
# provisioner.myDigitalMarketplaceProvisioner.class = edu.internet2.middleware.grouper.app.remedyV2.digitalMarketplace.GrouperDigitalMarketplaceProvisioner

# this is the remedy external system config id
# {valueType: "string", required: true, order: 20, formElement: "dropdown", optionValuesFromClass: "edu.internet2.middleware.grouper.app.remedy.RemedyDigitalMarketplaceGrouperExternalSystem"}
# provisioner.myDigitalMarketplaceProvisioner.digitalMarketplaceExternalSystemConfigId =

# Name of the group attribute
# {valueType: "string", order: 21000, required: true, showEl: "${operateOnGrouperGroups && numberOfGroupAttributes > $i$}", formElement: "dropdown", optionValues: ["comments", "groupName", "groupType", "longGroupName"], repeatGroup: "targetGroupAttribute", repeatCount: 20}
# provisioner.myDigitalMarketplaceProvisioner.targetGroupAttribute.$i$.name =

# Name of the entity attribute
# {valueType: "string", order: 61000, required: true, showEl: "${operateOnGrouperEntities && numberOfEntityAttributes > $i$}", formElement: "dropdown", optionValues: ["loginName", "userId"], repeatGroup: "targetEntityAttribute", repeatCount: 20}
# provisioner.myDigitalMarketplaceProvisioner.targetEntityAttribute.$i$.name =

# Name of the attribute
# {valueType: "string", order: 76710, required: true, showEl: "${operateOnGrouperMemberships && numberOfMembershipAttributes > $i$}", formElement: "dropdown", optionValues: ["groupName", "loginName"], repeatGroup: "targetMembershipAttribute", repeatCount: 20}
# provisioner.myDigitalMarketplaceProvisioner.targetMembershipAttribute.$i$.name =
