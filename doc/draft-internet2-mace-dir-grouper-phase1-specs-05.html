<html>
<head>
  <title>Grouper Phase 1 Specifications - Draft 05</title>
  <style>
<!--
#section { }
#subsection { }
#table {
  border: 1px solid black;
  border-collapse: collapse;
}
#td {
  padding: 3px;
}
#title {
}
#toc {
}
-->
  </style>
</head>
<body>
<div id="summary">
draft-internet2-mace-dir-grouper-phase1-specs-05.html<br />
11 April 2005<br />
Tom Barton &amp; blair christensen, editors<br />
The University of Chicago<br />
Comments to: tbarton@uchicago.edu or blair@uchicago.edu
</div>
<div id="title">
<h2>Grouper Phase 1 Specifications</h2>
</div>
<div id="toc">
<h3>Table of Contents</h3
<ol>
  <li><a href="#heading_Intro">Introduction to Grouper phase 1</a></li>
  <li><a href="#heading_2_Comp">Components &amp; architecture</a></li>
  <li><a href="#heading_3_data">Groups Registry data model</a></li>
  <li><a href="#heading_4_membership">Representing membership</a></li>
  <li><a href="#heading_5_privs">Grouper API naming and access privileges</a></li>
  <li><a href="#heading_6_baseType">Definition of the "base" group type</a></li>
  <li><a href="#heading_7_security">Grouper security</a></li>
  <li><a href="#heading_8_defaultInts">Default implementation of the
    Naming &amp; Access Interfaces</a></li>
  <li><a href="#heading_9_classes">Grouper API classes and
    methods</a></li>
  <li><a href="#heading_10_logging">Logging specifications</a></li>
  <li><a href="#heading_11_membersTable">Members table maintenance
    program</a></li>
  <li><a href="#heading_12_config">Configurable options</a></li>
  <li><a href="#heading_13_DBdetails">Database creation script
    details</a></li>
  <li><a href="#heading_14_refs">References</a></li>
  <li><a href="#heading_15_acks">Acknowledgments</a></li>
</ol>
</div>

<h4>
<a name="heading_Intro"></a>1.
Introduction to Grouper phase 1</h4>
Grouper v1 will be produced in three phases, as
described in [1]. This document defines the phase 1 functional
specification in some detail. We'll start with a brief review of
Grouper's architecture - its major components and how those fit into an
implementation site's infrastructure - and then introduce the
underlying data model, the roles &amp; privileges internal to Grouper,
define its "base group type", how its security is structured, and
continue on to elaborate the classes and methods of the Groups API java
implementation. The specification will conclude with several sections
of miscellany.<br>
<br>
Phase 1 implements basic groups management capabilities - creation,
update, and removal of groups from the Groups Registry, subgroups,
export and limited querying capabilities, a graphical user interface
for manual groups management, and logging. It will also include sample
batch programs for loading data into and extracting data out of the
Groups Registry.<br>
<br>
Three internal functions of Grouper phase 1 are abstracted to enable
sites to provide local alternatives to the default implementation.
These are the Access and Naming Interfaces, which informs the
Grouper API of the
group management privileges a subject has, and the Subject
Interface, which translates between identifiers chosen by sites for
member objects and an alternate form of identifying the same real world
subjects. For example, a member identifier might consist of a long,
opaque string of hex digits that persistently identifies its real world
subject, while more familiar usernames are used by people and systems
external to Grouper to identify group members.<br>
<br>
At points it may be wise to look ahead towards phases 2 and 3, to be
sure that phase 1 design choices don't make it too hard to meet
functional requirements of these phases. Phase 2 adds support for
compound groups, i.e., specifying membership in terms of unions,
intersections, and complements of memberships of other groups. It's at
this point that we also ensure that Grouper v1 will meet requirements
to integrate with Signet, the privilege management system being
developed for Internet2/MACE by Stanford University that is a
derivative of their Authority Manager. Phase 3 adds support for aging
of groups and of group memberships, and includes abstraction of a
fourth function internal to Grouper, the Last Activity Interface, which
is
used to determine when a group has become "stale".<br>
<br>
This version of the phase 1 specification does not address the
graphical user interface.<br>

<h4> <a name="heading_2_Comp"></a>2.
Components &amp; architecture</h4>
<a href="#Figure_1">Figure 1</a> below labels the main components of
Grouper v1 and shows
them in relation to the rest of an illustrative site's identity
management infrastructure. It is a simplification of the architecture
presented in [2]. The Groups Registry is a relational database that
houses all group information. The API mediates all access to the
Registry. Loaders are used to determine updates to groups and their
memberships from automated sources of identity information. UIs are
used for distributed manual management of groups and their memberships.
Provisioning connectors extract selected group information from the
Registry and repose it where it is needed to support run-time
operations of a site's applications and services.<br>
<a name="Figure_1"></a><br>
<div style="text-align: center;"><img src="gag6.gif" title=""
 alt="Grouper v1 components" style="width: 591px; height: 338px;"><br>
<br>
Figure 1: Grouper v1 components
(shaded) and articulating elements. <br>
<div style="text-align: left;"><br>
The shaded elements will be delivered as part of Grouper v1 (although
it is expected that sites will use their favorite relational database
technology to house the Registry). Loaders,
provisioning connectors, and alternate Groups Manager UIs are being
solicited for contribution. It is likely that the University of Chicago
will contribute an LDAP provisioning connector, for example.<br>
<br>
Two details in <a href="#Figure_1">Figure 1</a> deserve comment. First
is the multiplicity of
Groups Manager UIs. These reflect a capability of the underlying data
model that allows a site to extend the set of group fields and group
types. It is possible to define new fields, associate them with new
group "types", and create and manage groups of these types. Where this
is
done, it may be necessary to provide UIs designed to manage groups of
the new types. However, Grouper v1 will only deliver the capability to
manage groups of a single "base" type.<br>
<br>
The second detail is the nature of the arrows emanating from two of the
provisioning connectors. Both "member data" and "group data" are
depicted as updated information being provisioned in this illustrative
site. This reflects how the site may choose to represent group
information - as some mix of "group objects", which list their members,
and group membership pointers or forward references, which are stored
alongside other information about member objects. Provisioning
connectors are responsible for determining which types of
representation are maintained for a given group, and for maintaining
referential integrity between different representations of the same
group. <br>
</div>
</div>
<h4>
<a name="heading_3_data"></a>3. Groups
Registry data model<br>
</h4>
<div style="text-align: center;">
<div style="text-align: left;">This section serves to orient the reader
to the underlying data model. Some of the details of this structure
will be explained here, but more will be provided below, in the context
of specifying how each of the API's methods work. Note that all table
names have been "firewalled" from possible conflict with RDBMS system
table names by using a prefix of "grouper_" on all table names.<br>
<br>
The central table is grouper_group, which lists the groupIDs of each
group in the Registry. GroupIDs are assigned and managed by Grouper -
they are its native and persistent group
identifiers.
The "compoundExpr" and "flattenedExpr" columns in the grouper_group
table are speculative support for Grouper phase 2, and so can be
ignored for now.<br>
<br>
Information about each group is contained in associated rows of the
grouper_membership and
grouper_metadata tables. The grouper_membership table contains all
fields whose
values
are lists of member references, and grouper_metadata contains all
other fields (currently limited to single-values). The "groupField"
column of the
grouper_membership table identifies which list of member references
each row pertains to. Likewise, the "groupField" column in the
grouper_metadata table identifies which field each row
refers to. More will be said about representation of
membership below.<br>
<br />
Most externally exposed management
functions refer to a group by its name rather than by its groupID
value. The name is a field stored in the grouper_metadata table. Group
names are meant to be
something like a common name - a readable and perhaps semantically
meaningful string of characters that is unique among other group names.
Much more is said below about conventions
for names of groups.<br />
<br>
The grouper_schema table identifies the set of group types that
each
group has. The set of group types available in the system is expressed
in three tables: grouper_types, grouper_fields, and grouper_typeDefs.
Grouper v1 will ship with a single group type named "base". Thus, its
grouper_fields table will list the fields included in the base type,
the grouper_typeDefs table will associate all of those fields with the
"base" type, and the grouper_types table will have a single row
identifying "base" as the sole type being managed by Grouper. Sites can
extend these tables to support additional types of groups if they wish.<br>
<a name="Figure_2"></a><br>
</div>
<img src="groupsRegERD3-5.gif" title="" alt="groups registry ERD v3.5"
 style="width: 657px; height: 566px;"><br>
<br>
Figure 2: Groups Registry Entity
Relationship Diagram. Grayed out tables not under discussion in phase 1.<br>

<div style="text-align: left;"><br>
The grouper_members table is present to support the default
implementation of the Subject Interface. Group members that are
external to Grouper (i.e., not other groups) are identified by their
site-supplied memberID. The columns of this table associate a
"presentationID" to each memberID. This enables sites to maintain
groups
by reference to persistent identifiers (the memberID column) yet refer
to members also by other, perhaps more lucent or changeable,
identifiers such as
usernames (the presentationID column). A batch program is supplied with
Grouper to maintain this table until such time as a site re-implements
the Subject Interface, for example, to refer to an LDAP directory
service for that function.<br>
<br>
The grouper_session table is used to track simultaneous use of the API
and facilitates some logging. The grouper_aging and grouper_factor
tables are speculative support for functional requirements in Grouper
phases 2 and 3 and can be ignored for now.<br>
</div>
</div>
<h4><a name="heading_4_membership"></a>4.  Representing membership<br></h4>
Group members are
identified either by
memberIDs that are assigned outside of Grouper or by Grouper-issued
groupIDs. Separate
columns are used for them
in the grouper_membership table to keep them separate, but there is a
common
index
across both columns to simplify searching for a member reference that
may be of either sort. Each row of the grouper_membership table will
have a value in only one or the other column - not both. Certain API
methods also provide support for occasions on which it is necessary to
distinguish between a member reference that is a memberID and one that
is a groupID.<br>
<br>
Grouper maintains a "flattened" representation of group membership at
all times. This is a statement about how subgroups are represented in
the data model. To explain, let's first be clear about some
terminology. The relationship "is a member of" can be modeled as a link
in a directed graph whose nodes are groups and members. For example, in
<a href="#Figure_3">Figure 3</a> the object "C" is a member of both "A"
and "B".<br>
<a name="Figure_3"></a><br>
<div style="text-align: center;"><img src="digraph.gif" title=""
 alt="subgroup digraph" style="height: 193px; width: 229px;"><br>
<br>
Figure 3: A digraph illustrating
membership.<br>
</div>
<br>
One can follow links around the digraph - each such walk is called a
"path". The length of a path is the number of links it traverses. With
this notion, paths of length 1 represent "immediate memberships" and
paths of length at least one connect nodes having an "effective
membership" relationship. Of course, it is possible to have both. For
example, "C" is an immediate member of "A" while "F" is an effective
member of "A", and "E" is both an immediate and an effective member of
"A".<br>
<br>
Back to what is meant by a "flattened" representation. This means that
each membership, either immediate or effective, is represented by a
single row in the grouper_membership table. Specifically, there is
exactly one row signifying the membership of M in G if there is a path
of any length starting at M and ending at G. As loaders or UIs add a
member to a group, the effective memberships that also result are
determined at that time, and rows expressing them are added to the
table as needed. Likewise, as a member is removed from a group,
appropriate rows expressing effective membership are removed from the
table. Similar impact on effective membership is tracked when a group
is made a subgroup of another group, and when a group is removed from
the membership of another group. The "isImmediate" column of the
grouper_membership table indicates
whether M is an immediate member of G, whether or not it is also an
effective member.<br>
<br>
<a name="via_set"></a>The notion of a "via set" is used to support the
management of the
grouper_membership table. For a membership (M in G), consider the set
of paths from M to G of length greater than 1. The set of all "first
steps" along these paths is a set of immediate memberships that M has.
These "qualify" M's effective membership in G - you can get from M to G
"via" any one of these first-step groups. For example, in <a
 href="#Figure_3">Figure 3</a>
above the via set of ("F" in "B") is {"C", "D"}. If M is an immediate
and not also an effective member of G, then the via set for this
membership is empty.<br>
<br>
The via
set is maintained by the algorithm that determines changes to
effective membership consequent to a change in immediate membership of
a group. As new immediate memberships cause
new effective memberships or new qualifications for existing effective
memberships, groups are added to affected via sets. As immediate
memberships are removed, corresponding groups are removed from affected
via sets. A row
representing an effective membership in the membership table whose
"isImmediate" column is FALSE is removed
when the last group in the via set for that membership is removed.<br>
<br>
[ The data model in <a
 href="#Figure_2">Figure 2</a>
represents via sets in the grouper_via
table, but it might prove expedient to represent one as a string
listing
the groupIDs in the via set in a "via" column in the grouper_membership
table - we're still thinking about which way to do it. ]<br>
<br>
With a flattened grouper_membership table and with via sets associated
with each effective membership, two purposes are served. First, there
is
no need to recurse over subgroups at export time or query time,
optimizing reporting on immediate and effective membership. Second, the
via set can be used to give a clue to a human using a UI about how a
member's
effective membership is established, and so avoid having to search
through the
subgraph of subgroups of a group if they intend to remove that
membership.<br>
<h4>
<a name="heading_5_privs"></a>5.
Grouper API naming and access privileges<br>
</h4>
<p>Each subject that exercises the Grouper API is constrained in what
it can do with the Groups Registry by the privilege(s) it has with
respect to each group. These privileges are divided into two classes:
those bearing on the creation of new groups, and those constraining
what can be done to an existing group. The Naming Interface provides
management of group naming rights and the Access Interface provides
management of access privileges to existing groups.<br>
</p>
A list of Grouper privileges and
their definitions follows. Some of the definitions refer to a "security
class". This is a bit of metadata about each of a group's fields that
is specified with each field declaration further below. <br>
<a name="Table_1"></a><br>
<table style="text-align: left; width: 100%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Privilege<br>
      </td>
      <td style="vertical-align: top;">Interface<br>
      </td>
      <td style="vertical-align: top;">Description<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">CREATE<br>
      </td>
      <td style="vertical-align: top;">Naming<br>
      </td>
      <td style="vertical-align: top;">Can create a group with a
specified name stem.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">STEM<br>
      </td>
      <td style="vertical-align: top;">Naming<br>
      </td>
      <td style="vertical-align: top;">Can grant and revoke CREATE
privilege for a specified name stem, and can grant and revoke STEM
privilege for
a subordinate stem if the configuration enables hierarchical group
naming.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 40px;">VIEW<br>
      </td>
      <td style="vertical-align: top;">Access<br>
      </td>
      <td style="vertical-align: top;">The group is not suppressed from
appearing in listings &amp;
searches, and it may be added to another group's list fields.
Essentially, the group
is invisible to non-VIEWers but may be seen and referred to by VIEWers.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ<br>
      </td>
      <td style="vertical-align: top;">Access<br>
      </td>
      <td style="vertical-align: top;">Can read all fields of
"membership" or "basic" security class about the group.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">UPDATE<br>
      </td>
      <td style="vertical-align: top;">Access<br>
      </td>
      <td style="vertical-align: top;">Can update all fields of
"membership" security class, and can grant and revoke VIEW, READ,
UPDATE, OPTIN,
and OPTOUT
privilege for the group.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ADMIN<br>
      </td>
      <td style="vertical-align: top;">Access<br>
      </td>
      <td style="vertical-align: top;">Can modify all group fields,
including fields of "administrative" security class, can grant and
revoke all
access privileges, can rename the group, and can delete the group.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OPTIN<br>
      </td>
      <td style="vertical-align: top;">Access<br>
      </td>
      <td style="vertical-align: top;">Can add oneself as a member of
the group.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OPTOUT<br>
      </td>
      <td style="vertical-align: top;">Access<br>
      </td>
      <td style="vertical-align: top;">Can remove oneself from the
membership of the group.<br>
      </td>
    </tr>
  </tbody>
</table>
<div style="text-align: center;">Table
1: Grouper Naming &amp; Access Privileges<br>
</div>
<p>Thus, UPDATERs administer membership of a group,
including management of membership information, delegation of
management of
membership information, and management of visibility of
group information. Group visibility or privacy requirements are met by
management of&nbsp; VIEW (those who can see a group) and READ (those
who can read a group's information) privileges. The
management of essential group metadata, including its name, and
the ability to override administration of membership is reserved for
ADMINs. This access privilege model also supports
groups for which administratively determined groups of subjects can
autonomously opt-in or opt-out of the group's membership. For example,
one group might be
established whose members are those entitled to use a particular
service, and a second group, for which all members of the first group
are given OPTIN privilege, is used as a basis for run-time
admission to the service. Only subjects that have opted-in are actually
enabled to use the service. Another example mimics the behavior of
mail lists: the set of subjects
entitled to subscribe are given OPTIN privilege (perhaps all members of
the
university community), and all members of the group are given OPTOUT
privilege, thereby allowing all subscribers to autonomously opt-out.<br>
</p>
<p>All group names in Grouper have two parts: stem and descriptor.
These are concatenated into a string, separated by a configurable stem
delimiter character, to form the name of the group. We'll use the colon
character ":" in this document as the stem delimiter. For example, the
name "uofc:faculty" has a stem of "uofc" and a descriptor of "faculty".
This naming model and the associated naming privileges are chosen in
recognition of the fact that people will try to infer the meaning of a
group and its source of authority from its name (hmm, "uofc:faculty"
seems like it must be all faculty at the University of Chicago). The
naming model enables management of authority over the set of stems in
use (STEM privilege) and over who may create new groups or rename old
ones starting with which stems (CREATE privilege).<br>
</p>
<p>The naming privilege model also supports hierarchical delegation of
limited naming authority. If so enabled in the configuration, the space
of stems is not flat but hierarchical, with a configurable character
delimiting hierarchical stem parts. We'll use the hyphen character "-"
in this document for illustration. For example, "uofc-bsd" is a stem
subordinate to "uofc", and "uofc-bsd-obgyn" is subordinate to
"uofc-bsd". When hierarchical stems are enabled, the STEM privilege can
also be used to delegate STEM privilege to a subordinate stem. For
example, a person with STEM privilege for "uofc-bsd" can assign to
another person STEM privilege for the subordinate stem
"uofc-bsd-obgyn", thereby delegating the ability to manage groups named
"uofc-bsd-obgyn:*" and "uofc-bsd-obgyn-*:*". <br>
</p>
<p>The API enforces uniqueness of group names across the Groups
Registry as well as uniqueness of all stems of group names. <br>
</p>
<p>The following characters are deemed
illegal for use in names of groups, unless chosen as the stem hierarchy
delimiter: "/", "\", "|", "?", "*", ";", ",". Stems and
descriptors may not contain the stem delimiter character.<br>
</p>
<p>Grouper's default implementation
of the Naming and Access Interfaces is described
further below,
as well as how each privilege is mapped to field-level information
about each group. <br>
</p>
<p></p>
<h4><a name="heading_6_baseType"></a>6.  Definition of the "base" group type</h4>
All groups in the Groups Registry have a base type. The
essential fields of groups of base type are:<br>
<a name="Table_2"></a><br>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td style="vertical-align: top; ;">groupField<br>
      </td>
      <td style="vertical-align: top; ;">security class<br>
      </td>
      <td style="vertical-align: top; ;">Description<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">name </td>
      <td style="vertical-align: top;">basic</td>
      <td style="vertical-align: top;">string name. Uniqueness enforced
within the Groups Registry.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">description </td>
      <td style="vertical-align: top;">basic<br>
      </td>
      <td style="vertical-align: top;">arbitrary string, perhaps used
to aid humans in understanding the semantics of this group.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">members </td>
      <td style="vertical-align: top;">membership<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs), those who "belong" to this group.</td>
    </tr>
  </tbody>
</table>
<div style="text-align: center;">Table
2: Fields for base type<br>
</div>
<br>
In addition, to support Grouper's default implementation of the Access
Interface (described below), the following fields are also part of the
base
group type:<br>
<a name="Table_3"></a><br>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td style="vertical-align: top; ;">groupField<br>
      </td>
      <td style="vertical-align: top; ;">security class</td>
      <td style="vertical-align: top; ;">Description<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">viewers </td>
      <td style="vertical-align: top;">membership<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs) with VIEW privilege for
this group. An empty list either means "nobody" or "everyone" depending
on the configuration.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">readers </td>
      <td style="vertical-align: top;">membership<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs) with READ privilege for
this group. An empty list either means "nobody" or "everyone" depending
on the configuration. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">updaters </td>
      <td style="vertical-align: top;">membership<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs) with UPDATE privilege for this group. An empty list means
"nobody".</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">admins </td>
      <td style="vertical-align: top;">administrative<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs)
with ADMIN privilege for this group. An empty list means "nobody".</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">optins </td>
      <td style="vertical-align: top;">membership<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs) with OPTIN privilege for this group. An empty list means
"nobody".</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">optouts </td>
      <td style="vertical-align: top;">membership<br>
      </td>
      <td style="vertical-align: top;">list of members (memberIDs or
groupIDs) with OPTOUT privilege for this group. An empty list means
"nobody".</td>
    </tr>
  </tbody>
</table>
<div style="text-align: center;">Table
3: Additional base type fields that list privileges for the default
Access Interface<br>
</div>
<br>
The members, viewers, readers, updaters, deleters, optins, and
optouts lists are all
represented in the grouper_membership table.
With regard to the privilege lists in <a href="#Table_3">Table 3</a>,
being in the
grouper_membership table enables any group of subjects to be identified
as having the corresponding
privilege with respect to the group.<br>
<br>
The name and description fields
are stored in the grouper_metadata table.<br>
<br>
Being lists, viewers,
readers, updaters, admins, optins, and optouts may
contain a mix of memberIDs
and groupIDs. Appearance of a groupID in any of these lists means that
all effective members of that group are to be counted as having the
privilege conveyed by being in that list. <br>
<h4><a
 name="heading_7_security"></a>7.
Grouper
security</h4>
<p>There is a fundamental issue of what identifiers are
used for
subjects
of Grouper security. To
avoid
the need to manage passwords within the Groups Registry, authentication
to a Groups Manager UI is presumed to occur outside of the Grouper API.
The UI
must present a
subject identifier to the API that resolves to a memberID by use of the
Subject Interface. For the default Subject Interface implementation,
this
supports the circumstance in which either
memberIDs or presentationIDs are used to authenticate to the UI. <br>
</p>
<p>Loaders and provisioning connectors must have memberIDs assigned in
the members table to enable the security
model to also apply to them. However, no API-mediated
authentication of those identifiers will occur - it is assumed that the
site will use local measures to restrict access to the API process
itself. Thus, loaders, provisioning connectors, and UIs are trusted by
the API,
and subject identifiers are accepted from these sources by the API.<br>
</p>
Read and write
access is declared for each field using columns in the
grouper_fields
table
named "readPriv" and "writePriv". Each identifies a single privilege
that
a subject must have in order to be granted read or read/write access to
the associated field. For the base
type, the per field security declaration is as follows, specified
as rows of the fields table. These implement the "security class"
specification used in Tables <a href="#Table_1">1</a>, <a
 href="#Table_2">2</a>, and <a href="#Table_3">3</a> above, and can be
changed by
an implementation
site.<br>
<a name="Table_4"></a><br>
<table border="1" style="width: 100%;" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td>groupField </td>
      <td>readPriv </td>
      <td>writePriv </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">name<br>
      </td>
      <td style="vertical-align: top;">READ<br>
      </td>
      <td style="vertical-align: top;">ADMIN<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">description<br>
      </td>
      <td style="vertical-align: top;">READ</td>
      <td style="vertical-align: top;">ADMIN</td>
    </tr>
    <tr>
      <td>members </td>
      <td>READ</td>
      <td>UPDATE</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">viewers<br>
      </td>
      <td style="vertical-align: top;">UPDATE</td>
      <td style="vertical-align: top;">UPDATE</td>
    </tr>
    <tr>
      <td>readers </td>
      <td>UPDATE</td>
      <td>UPDATE</td>
    </tr>
    <tr>
      <td>updaters </td>
      <td>UPDATE</td>
      <td>UPDATE</td>
    </tr>
    <tr>
      <td>admins</td>
      <td>ADMIN</td>
      <td>ADMIN</td>
    </tr>
    <tr>
      <td>optins<br>
      </td>
      <td>READ</td>
      <td>UPDATE</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">optouts<br>
      </td>
      <td style="vertical-align: top;">READ</td>
      <td style="vertical-align: top;">UPDATE</td>
    </tr>
  </tbody>
</table>
<div style="text-align: center;">Table
4: Field level access mapping<br>
</div>
<p>This arrangement enables the security model to be declared for new
fields that may be
a part of a new group type. </p>
<h4><big><a
 name="heading_8_defaultInts"></a>8. Default implementation of
the Naming &amp; Access Interfaces<br>
</h4>
Not surprisingly, Grouper's default implementation of these interfaces
will leverage Grouper's core competency: groups will be used to aid in
naming and access management.<br>
<br>
The default naming interface within Grouper distinguishes between
"personal" groups and all others in terms of how it provisions CREATE
and STEM privileges within the Groups Registry. Two configurable
options
are whether personal group creation is enabled, and if so, under what
stem are all personal groups subordinated. For discussion assume that
this stem is the string "personal". To a subject identified as
"presentationID", say, Grouper then grants CREATE privilege for the
stem "personal-presentationID", permitting that subject to create
groups named "personal-presentationID:aDescriptor". No STEM privileges
are granted in support of personal groups, which means that individuals
may not delegate to others any ability to create or rename groups
within their personal group namespace. <br>
<br>
For all other groups, Grouper relies on a set of "grouperCreator"
groups to provision CREATE and STEM privileges. Subjects that are
effective members of the group named "grouperCreator:aStem" are granted
CREATE privilege for the stem "aStem". If hierarchical stems are
disabled in the configuration, the same subjects are also granted STEM
privilege. If hierarchical stems are enabled, subjects that are
effective members of the group named "grouperCreator:aStem-" are
granted STEM privilege for the stem "aStem". For discussion, "-" is
assumed to be the configured stem delimiter character.<br>
<p>To bootstrap the ability to create groups named with stems other
than those conveying personal authority, Grouper ships with a group
named
"grouperCreator:grouperCreator" containing a single member named
"grouperSystem", and grouperSystem appears in the as-shipped members
table. Hence, the API can be accessed as the grouperSystem subject to
create other groups with stem "grouperCreator", thereby allowing the
API or UI to be used to create new stems, assign subjects the privilege
to create groups named with those stems, and delegate stem creation
privileges. Other subjects can be added to this group to make them also
fully authoritative over group naming privileges for non-personal
groups.<br>
</p>
<p>The default access interface within Grouper uses the list-type
groupFields defined in <a href="#Table_3">Table 3</a> above to
determine who has which access
privileges. Except for the exceptions noted below, a subject has a
given access privilege if and only if they effectively belong to the
corresponding list. For example, a subject has the UPDATE privilege
with respect to a group precisely when they are effectively a member of
that group's "updaters" list. It also follows that no one has an access
privilege if the associated list is empty. There are two configurable
exceptions to this rule. Empty "viewers" or "readers" lists can be
configured to mean either "nobody" or "everyone", allowing a site to
determine their own approach to default VIEWing and READing privilege:
either default-permit or default-deny.<br>
</p>
<p>The grant and revoke methods for Grouper's default naming and access
interfaces support reference to individual subjects and to groups.
Thus, the full capability of Grouper to manage lists, including
effective membership, subgroups, and compound groups, can be used to
facilitate the management of privilege assignment.&nbsp;
</p>
<p style="color: rgb(0, 0, 0);">The "grouperSystem" internal
subject described above always has
CREATE and STEM privileges for all name stems, and ADMIN privilege to
all groups - the API will not actually query the Naming or Access
Interfaces to
determine the privileges of this distinguished subject.</p>
<h4><a name="heading_9_classes"></a>9.
Grouper API
classes and methods</h4>
<h4></h4>
<p>Most API operations act as a set of interactions among java objects
of
three classes: GrouperGroup, GrouperMember, and GrouperSession. Each
GrouperGroup object represents a single group - either an existing one
in the Groups
Registry, or a new one to be added to the Groups Registry. A
GrouperMember
object represents a single member object which might itself be a group.
A GrouperSession object is
instantiated to initialize an API session for a subject. Methods
supporting naming &amp; access privileges and subject lookup are
encapsulated within GrouperSession objects. <br>
</p>
<p><font class="FrameItemFont">The full list of classes and interfaces
follows, together with brief descriptions of each. </font><font
 class="FrameItemFont">Short paragraphs further below orient
the reader to the role of each class in the API</font><font
 class="FrameItemFont"> </font><font class="FrameItemFont">and
highlight certain methods</font><font class="FrameItemFont">
associated with each class. A more detailed and comprehensive technical
specification is
contained in the <a
 href="http://middleware.internet2.edu/dir/groups/grouper/javadoc/">Grouper
API javadoc</a>, and
<a href="http://middleware.internet2.edu/dir/groups/grouper/examples/">examples
of java code</a> exercising some of the main functions of the API
should help to further clarify its use.<br>
</font></p>
<p><font class="FrameItemFont">The API as documented in this version of
the Grouper Phase 1 specification is considered to be not yet stable.
That is, although we don't expect there to be any further huge changes
to the public API, there will yet be several substantial ones. We
haven't quite completed its first thorough going-over, and some
corrections already identified haven't yet been reflected in the
javadoc.<br>
</font></p>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td style="vertical-align: top; ;">Class<br>
      </td>
      <td style="vertical-align: top; ;">Description<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">Grouper
      </font><a href="#class_Grouper"><font class="FrameItemFont"><br>
      </font></a></td>
      <td style="vertical-align: top;">Initialize the API by reading
configuration and constructing an executive GrouperSession object.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperSession</font></td>
      <td style="vertical-align: top;">Initialize an API session for a
subject, establish a JDBC connection to the Groups Registry for this
session, encapsulate methods for subject lookup and naming &amp; access
privilege management.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperGroup</font></td>
      <td style="vertical-align: top;">Represents a group's data and
management methods.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperMember<br>
      </font></td>
      <td style="vertical-align: top;">Represents an object, either an
individual or a group, that can be a member of a group.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">InternalGrouperNaming<br>
      </font></td>
      <td style="vertical-align: top;">Default implementation of the
GrouperNaming interface.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">InternalGrouperAccess
      <br>
      </font></td>
      <td style="vertical-align: top;">Default implementation of the
GrouperAccess interface.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">InternalGrouperSubject<br>
      </font></td>
      <td style="vertical-align: top;">Default implementation of the
GrouperSubject interface.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperStem<br>
      </font></td>
      <td style="vertical-align: top;">Represents a string that can
serve as the stem portion of a group name. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperDescriptor<br>
      </font></td>
      <td style="vertical-align: top;">Represents a string that can
serve as the descriptor portion of a group name.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperPrivileges<br>
      </font></td>
      <td style="vertical-align: top;">Represents an enumeration of
Grouper naming and access privileges.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperFieldPrivileges<br>
      </font></td>
      <td style="vertical-align: top;">Represents an enumeration of
Grouper groupField level access privileges.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperType
      </font></td>
      <td style="vertical-align: top;">Represents a row in the
grouper_types table.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperTypeDef
      </font></td>
      <td style="vertical-align: top;">Represents a row in the
grouper_typeDefs table.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperField
      </font></td>
      <td style="vertical-align: top;">Represents a row in the
grouper_fields table</td>
    </tr>
  </tbody>
</table>
<div style="text-align: center;">Table
5: Grouper phase 1 classes<br>
<br>
</div>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td style="vertical-align: top; ;">Interface<br>
      </td>
      <td style="vertical-align: top; ;">Description<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font class="FrameItemFont">GrouperNaming
      <br>
      </font></td>
      <td style="vertical-align: top;">Specification of the Naming
Interface, which governs privileges for group creation and naming
authority.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">GrouperAccess<br>
      </td>
      <td style="vertical-align: top;">Specification of the Access
Interface, which governs access privileges to extant groups.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">GrouperSubject<br>
      </td>
      <td style="vertical-align: top;">Specification of the Subject
Interface, which provides a translation service between "memberIDs" and
"presentationIDs" assigned to subjects.<br>
      </td>
    </tr>
  </tbody>
</table>
<div style="text-align: center;">Table
6: Grouper phase 1 interfaces<br>
</div>
<p><font class="FrameItemFont" style="color: rgb(0, 0, 153);">Grouper.
Each API instance has a single Grouper object. This object is used to
construct GrouperSession objects for each new subject having an API
session. It also provides methods to enable API clients to read
elements of the configuration file and the logical structure of the
Groups Registry as expressed in the grouper_types, grouper_typeDefs,
and grouper_fields tables.<br>
</font></p>
<p><font class="FrameItemFont" style="color: rgb(0, 0, 153);">GrouperSession.
A GrouperSession object is constructed at the start of each API client
session. A subject using the session must be specified - this subject's
naming and access privileges constrain what the API will do during this
API session. A JDBC connection to the Grouper Registry is opened for
each session. The session object provides methods to grant, revoke, and
review naming &amp; access privileges of any subject. <br>
</font></p>
<p><font class="FrameItemFont" style="color: rgb(0, 0, 153);">GrouperGroup.
To work with a
group, a GrouperGroup object must be constructed that references a
GrouperSession. The access privileges to this group that are assigned
to the session's subject are cached in the GrouperGroup object to
optimize access
control performance, and&nbsp; the object provides a method to express
those privileges in terms of field-level access the session's subject
enjoys with respect to this group. Methods provide read/write access to
all group fields, to determine immediate or effective membership of the
group, and to create or destroy the group.<br>
</font></p>
<font class="FrameItemFont">GrouperMember.
This represents an object that can be either an individual subject or a
group. Its methods provide means of listing the object's immediate and
effective memberships, the object's <a href="#via_set">via set</a>,
and whether it represents a group or an individual subject.<br>
<br>
whoAmI method. Several classes
implement a whoAmI method that returns an identifier for the object
that can be used in other Grouper API methods. This helps to maintain
the distinction between Grouper's internal groupID identifier and the
group name and helps to enable API clients to specify groups by
reference to their names.<br>
<br>
addValue, removeValue, and
getMembership polymorphism. Together with getMetadata(), these
methods provide comprehensive read/write access to a group's fields.
The simplest form refers to the "members" field by default,
anticipating that the largest number of API operations will be to
manage group membership lists. Other forms allow list fields other than
"members" or a metadata field to be specified. The getMembership method
by default lists all effective memberships, whether applied to a group
to list its members or applied to a member object to list its
memberships. It can also be invoked in a form specifying that only
immediate memberships should be listed.<br>
<br>
</font><font class="FrameItemFont">GrouperAccess.
This interface specifies methods for granting and revoking an access
privilege to a group for a subject, and several forms of determining
existing access privileges. By its use of GrouperMember objects, the
interface supports assignment of access privileges to groups as well as
to
individual subjects. <br>
<br>
</font><font class="FrameItemFont">GrouperNaming.
This interface specifies methods for granting and revoking a naming
privilege to a stem for a subject, and several forms of determining
existing naming privileges. By its use of GrouperMember objects, the
interface supports assignment of naming privileges to groups as well as
to
individual subjects. <br>
<br>
GrouperSubject. This interface
specifies the single, polymorphic, lookup() method, which is used to
translate between memberIDs and an alternate means of identifying
individual subjects. This enables a site to specify membership using a
system of identifiers distinct from other systems that may be in common
use. The main example is of a site that uses opaque and persistent
identifiers for specifying membership that are unknown to most users of
the Grouper UI. The GrouperSubject interface permits translation of a
well-known identifier, such as a username, to its memberID equivalent. <br>
</font>
<p>Exceptions still need to be detailed.<br>
</p>
<ol>
</ol>
<ol>
</ol>
<h4><a name="heading_10_logging"></a>10.  Logging specifications</h4>
<p>TBD<br>
Thoughts from a mace-dir-groups
conf call on the subject:<br style="color: rgb(0, 0, 153);">
</p>
<ol>
</ol>
<ul>
  <li style="color: rgb(0, 0, 153);">session start/end records:
who (UI user, loader, etc) is using grouper when</li>
  <li style="color: rgb(0, 0, 153);">registry changes for
interactive sessions</li>
  <li style="color: rgb(0, 0, 153);">registry changes for batch
sessions, with different log level</li>
  <li style="color: rgb(0, 0, 153);">distinguish between debug
logging and audit logging</li>
  <li style="color: rgb(0, 0, 153);">"sensitive" groups -
differential logging detail depending on the group being managed.</li>
  <li>how much can we rely on
logging on the underlying database?<br>
    </li>
</ul>
<ol>
</ol>
<h4><a name="heading_11_membersTable"></a>11.
Members table maintenance program<br>
</h4>
<p>TBD<br>
</p>
<h4><a name="heading_12_config"></a>12. Configurable
options<br>
</h4>
Under construction. These are just reminders for us to not forget to
detail later on.<br>
<ul>
  <li>do personal groups?</li>
  <li>personal stem, e.g., personal-tbarton:blah</li>
  <li>do hierarchical stemming?</li>
  <li>stem hierarchy delimiter</li>
  <li>stem hierarchy depth</li>
  <li>where's the registry?</li>
  <li>empty viewers list default semantics: "nobody" or "everyone"</li>
  <li>empty readers list default semantics: "nobody" or "everyone"</li>
</ul>
<h4><a
 name="heading_13_DBdetails"></a>13.
Database
creation script details</h4>
Under construction. These are just reminders for us to not forget to
detail later on.<br>
<ul>
  <li>principal for API</li>
  <li>principal for members table maintenance program</li>
  <li>specify column width &amp; syntax, indices, linkages</li>
</ul>
<h4><a name="heading_14_refs"></a>14.
References</h4>
<p>[1] "Grouper Roadmap", Tom Barton, editor<br>
http://home.uchicago.edu/~tbarton/draft-barton-grouper-roadmap-03.html<br>
</p>
<p>[2] "Group Tools Architecture", Tom Barton, editor<br>
http://middleware.internet2.edu/dir/groups/docs/draft-barton-grouptools-arch-02.html<br>
</p>
<h4><a name="heading_15_acks"></a>15.
Acknowledgments</h4>
Thanks are due to the participants in the Internet2/MACE Directories
working group, who support and substantially
contribute to this effort.<br>
<br>
Development of this document was supported with funding from the
University of Chicago, Internet2, and the NSF Middleware Initiative
(Cooperative Agreement No. ANI-0123937).<br>
<br>
<p></p>
</body>
</html>
