package edu.internet2.middleware.grouperClient.jdbc.tableSync;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.logging.Log;

import edu.internet2.middleware.grouperClient.jdbc.GcDbAccess;
import edu.internet2.middleware.grouperClient.jdbc.GcDbVersionable;
import edu.internet2.middleware.grouperClient.jdbc.GcPersist;
import edu.internet2.middleware.grouperClient.jdbc.GcPersistableClass;
import edu.internet2.middleware.grouperClient.jdbc.GcPersistableField;
import edu.internet2.middleware.grouperClient.jdbc.GcPersistableHelper;
import edu.internet2.middleware.grouperClient.jdbc.GcSqlAssignPrimaryKey;
import edu.internet2.middleware.grouperClient.util.GrouperClientUtils;

/**
 * tracks group dependencies on another group for provisioning roles in a group
 * @author mchyzer
 *
 */
@GcPersistableClass(tableName="grouper_sync_dep_group_group", defaultFieldPersist=GcPersist.doPersist)
public class GcGrouperSyncDependencyGroupGroup implements GcSqlAssignPrimaryKey, GcDbVersionable {

  /**
   * table name
   */
  public static final String TABLE_GROUPER_SYNC_DEP_GROUP_GROUP = "grouper_sync_dep_group_group";

  /** save the state when retrieving from DB */
  @GcPersistableField(persist = GcPersist.dontPersist)
  private GcGrouperSyncDependencyGroupGroup dbVersion = null;

  /**
   * take a snapshot of the data since this is what is in the db
   */
  @Override
  public void dbVersionReset() {
    //lets get the state from the db so we know what has changed
    this.dbVersion = this.clone();
  }

  /**
   * if we need to update this object
   * @return if needs to update this object
   */
  @Override
  public boolean dbVersionDifferent() {
    return !this.equalsDeep(this.dbVersion);
  }

  /**
   * db version
   */
  @Override
  public void dbVersionDelete() {
    this.dbVersion = null;
  }

  /**
   * deep clone the fields in this object
   */
  @Override
  public GcGrouperSyncDependencyGroupGroup clone() {

    GcGrouperSyncDependencyGroupGroup gcGrouperSyncLog = new GcGrouperSyncDependencyGroupGroup();
    //connectionName  DONT CLONE
  
    //dbVersion  DONT CLONE
  
    gcGrouperSyncLog.fieldId = this.fieldId;
    //grouperSyncGroup  DONT CLONE
  
    gcGrouperSyncLog.grouperSyncId = this.grouperSyncId;
    //grouperSyncJob  DONT CLONE
  
    gcGrouperSyncLog.groupId = this.groupId;
    gcGrouperSyncLog.idIndex = this.idIndex;
    gcGrouperSyncLog.provisionableGroupId = this.provisionableGroupId;
  
    return gcGrouperSyncLog;
  }

  /**
   *
   */
  public boolean equalsDeep(Object obj) {
    if (this==obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof GcGrouperSyncDependencyGroupGroup)) {
      return false;
    }
    GcGrouperSyncDependencyGroupGroup other = (GcGrouperSyncDependencyGroupGroup) obj;

    return new EqualsBuilder()


      //connectionName  DONT EQUALS

      //dbVersion  DONT EQUALS

      .append(this.fieldId, other.fieldId)
      //grouperSyncGroup  DONT EQUALS

      .append(this.grouperSyncId, other.grouperSyncId)
      .append(this.groupId, other.groupId)
      .append(this.idIndex, other.idIndex)
      .append(this.provisionableGroupId, other.provisionableGroupId)
      //lastUpdated  DONT EQUALS

        .isEquals();

  }
  //########## END GENERATED BY GcDbVersionableGenerate.java ###########

  /**
   * primary key
   */
  @GcPersistableField(primaryKey=true, primaryKeyManuallyAssigned=false)
  private Long idIndex;

  /**
   * if inserting and not wanting an assigned id
   */
  @GcPersistableField(persist = GcPersist.dontPersist)
  private Long idIndexForInsert;
  
  /**
   * if getting id index in bulk and putting in object
   * @param theIdIndex
   * @return
   */
  public GcGrouperSyncDependencyGroupGroup assignIdIndexForInsert(Long theIdIndex) {
    this.idIndexForInsert = theIdIndex;
    return this;
  }

  /**
   * group uuid of the role group
   */
  private String groupId;
  
  /**
   * field uuid of the role field (members or a group priv)
   */
  private String fieldId;
  
  /**
   * group uuid of the provisionable group which has the role
   */
  private String provisionableGroupId;
  
  
  
  
  /**
   * primary key
   * @return
   */
  public Long getIdIndex() {
    return idIndex;
  }

  /**
   * primary key
   * @param idIndex
   */
  public void setIdIndex(Long idIndex) {
    this.idIndex = idIndex;
  }

  /**
   * group uuid of the role group
   * @return
   */
  public String getGroupId() {
    return groupId;
  }

  /**
   * group uuid of the role group
   * @param groupId
   */
  public void setGroupId(String groupId) {
    this.groupId = groupId;
  }

  /**
   * field uuid of the role field (members or a group priv)
   * @return
   */
  public String getFieldId() {
    return fieldId;
  }

  /**
   * field uuid of the role field (members or a group priv)
   * @param fieldId
   */
  public void setFieldId(String fieldId) {
    this.fieldId = fieldId;
  }

  /**
   * group uuid of the provisionable group which has the role
   * @return
   */
  public String getProvisionableGroupId() {
    return provisionableGroupId;
  }

  /**
   * group uuid of the provisionable group which has the role
   * @param provisionableGroupId
   */
  public void setProvisionableGroupId(String provisionableGroupId) {
    this.provisionableGroupId = provisionableGroupId;
  }

  /**
   * delete all data if table is here
   */
  public static void reset() {
    
    new GcDbAccess().connectionName("grouper").sql("delete from " + GcPersistableHelper.tableName(GcGrouperSyncDependencyGroupGroup.class)).executeSql();
  }

  /**
   * 
   */
  public GcGrouperSyncDependencyGroupGroup() {
  }

  /**
   * foreign key to grouper_sync_group table
   */
  private String grouperSyncId;


  /**
   * foreign key to grouper_sync_group table
   * @return group id
   */
  public String getGrouperSyncId() {
    return this.grouperSyncId;
  }

  /**
   * foreign key to grouper_sync_group table
   * @param grouperSyncId1
   */
  public void setGrouperSyncId(String grouperSyncId1) {
    this.grouperSyncId = grouperSyncId1;
    if (this.grouperSync == null || !GrouperClientUtils.equals(grouperSyncId1, this.grouperSync.getId())) {
      this.grouperSync = null;
    }
  }
  
  
  
  /**
   * connection name or null for default
   */
  @GcPersistableField(persist=GcPersist.dontPersist)
  private String connectionName;

  /**
   * 
   */
  private static Log LOG = GrouperClientUtils.retrieveLog(GcGrouperSyncDependencyGroupGroup.class);

  /**
   * connection name or null for default
   * @return connection name
   */
  public String getConnectionName() {
    return this.connectionName;
  }

  /**
   * connection name or null for default
   * @param connectionName1
   */
  public void setConnectionName(String connectionName1) {
    this.connectionName = connectionName1;
  }
  
  /**
   * 
   */
  @Override
  public boolean gcSqlAssignNewPrimaryKeyForInsert() {
    if (this.idIndex != null) {
      return false;
    }
    if (this.idIndexForInsert != null) {
      this.idIndex = this.idIndexForInsert;
    } else {
      throw new RuntimeException("Set the id index for insert!");
    }
    return true;
  }

  /**
   * prepare to store
   */
  public void storePrepare() {

    this.connectionName = GcGrouperSync.defaultConnectionName(this.connectionName);
  }

  /**
   * 
   */
  @Override
  public String toString() {
    return GrouperClientUtils.toStringReflection(this);
  }

  /**
   * 
   */
  @GcPersistableField(persist=GcPersist.dontPersist)
  private GcGrouperSync grouperSync;
  
  /**
   * 
   * @return gc grouper sync
   */
  public GcGrouperSync getGrouperSync() {
    return this.grouperSync;
  }
  
  /**
   * 
   * @param gcGrouperSync
   */
  public void setGrouperSync(GcGrouperSync gcGrouperSync) {
    this.grouperSync = gcGrouperSync;
    this.grouperSyncId = gcGrouperSync == null ? null : gcGrouperSync.getId();
    this.connectionName = gcGrouperSync == null ? this.connectionName : gcGrouperSync.getConnectionName();

  }

}
