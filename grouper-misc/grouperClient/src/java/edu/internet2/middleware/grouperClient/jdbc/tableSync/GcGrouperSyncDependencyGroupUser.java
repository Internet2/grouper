package edu.internet2.middleware.grouperClient.jdbc.tableSync;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.logging.Log;

import edu.internet2.middleware.grouperClient.jdbc.GcDbAccess;
import edu.internet2.middleware.grouperClient.jdbc.GcDbVersionable;
import edu.internet2.middleware.grouperClient.jdbc.GcPersist;
import edu.internet2.middleware.grouperClient.jdbc.GcPersistableClass;
import edu.internet2.middleware.grouperClient.jdbc.GcPersistableField;
import edu.internet2.middleware.grouperClient.jdbc.GcPersistableHelper;
import edu.internet2.middleware.grouperClient.jdbc.GcSqlAssignPrimaryKey;
import edu.internet2.middleware.grouperClient.util.GrouperClientUtils;

/**
 * tracks user dependencies on another group for provisioning attributes of a user
 * @author mchyzer
 *
 */
@GcPersistableClass(tableName="grouper_sync_dep_group_user", defaultFieldPersist=GcPersist.doPersist)
public class GcGrouperSyncDependencyGroupUser implements GcSqlAssignPrimaryKey, GcDbVersionable {

  /**
   * table name
   */
  public static final String TABLE_GROUPER_SYNC_DEP_GROUP_USER = "grouper_sync_dep_group_user";


  /** save the state when retrieving from DB */
  @GcPersistableField(persist = GcPersist.dontPersist)
  private GcGrouperSyncDependencyGroupUser dbVersion = null;

  /**
   * take a snapshot of the data since this is what is in the db
   */
  @Override
  public void dbVersionReset() {
    //lets get the state from the db so we know what has changed
    this.dbVersion = this.clone();
  }

  /**
   * if we need to update this object
   * @return if needs to update this object
   */
  @Override
  public boolean dbVersionDifferent() {
    return !this.equalsDeep(this.dbVersion);
  }

  /**
   * db version
   */
  @Override
  public void dbVersionDelete() {
    this.dbVersion = null;
  }

  /**
   * deep clone the fields in this object
   */
  @Override
  public GcGrouperSyncDependencyGroupUser clone() {

    GcGrouperSyncDependencyGroupUser gcGrouperSyncLog = new GcGrouperSyncDependencyGroupUser();
    //connectionName  DONT CLONE
  
    //dbVersion  DONT CLONE
  
    gcGrouperSyncLog.fieldId = this.fieldId;
    //grouperSyncGroup  DONT CLONE
  
    gcGrouperSyncLog.grouperSyncId = this.grouperSyncId;
    //grouperSyncJob  DONT CLONE
  
    gcGrouperSyncLog.groupId = this.groupId;
    gcGrouperSyncLog.idIndex = this.idIndex;
  
    return gcGrouperSyncLog;
  }

  /**
   *
   */
  public boolean equalsDeep(Object obj) {
    if (this==obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof GcGrouperSyncDependencyGroupUser)) {
      return false;
    }
    GcGrouperSyncDependencyGroupUser other = (GcGrouperSyncDependencyGroupUser) obj;

    return new EqualsBuilder()


      //connectionName  DONT EQUALS

      //dbVersion  DONT EQUALS

      .append(this.fieldId, other.fieldId)
      //grouperSyncGroup  DONT EQUALS

      .append(this.grouperSyncId, other.grouperSyncId)
      .append(this.groupId, other.groupId)
      .append(this.idIndex, other.idIndex)
      //lastUpdated  DONT EQUALS

        .isEquals();

  }
  //########## END GENERATED BY GcDbVersionableGenerate.java ###########

  /**
   * primary key
   */
  @GcPersistableField(primaryKey=true, primaryKeyManuallyAssigned=false)
  private Long idIndex;

  /**
   * if inserting and not wanting an assigned id
   */
  @GcPersistableField(persist = GcPersist.dontPersist)
  private Long idIndexForInsert;
  
  /**
   * if getting id index in bulk and putting in object
   * @param theIdIndex
   * @return
   */
  public GcGrouperSyncDependencyGroupUser assignIdIndexForInsert(Long theIdIndex) {
    this.idIndexForInsert = theIdIndex;
    return this;
  }

  /**
   * group uuid of the role group
   */
  private String groupId;
  
  /**
   * field uuid of the role field (members or a group priv)
   */
  private String fieldId;
  
  
  
  
  /**
   * primary key
   * @return
   */
  public Long getIdIndex() {
    return idIndex;
  }

  /**
   * primary key
   * @param idIndex
   */
  public void setIdIndex(Long idIndex) {
    this.idIndex = idIndex;
  }

  /**
   * group uuid of the role group
   * @return
   */
  public String getGroupId() {
    return groupId;
  }

  /**
   * group uuid of the role group
   * @param groupId
   */
  public void setGroupId(String groupId) {
    this.groupId = groupId;
  }

  /**
   * field uuid of the role field (members or a group priv)
   * @return
   */
  public String getFieldId() {
    return fieldId;
  }

  /**
   * field uuid of the role field (members or a group priv)
   * @param fieldId
   */
  public void setFieldId(String fieldId) {
    this.fieldId = fieldId;
  }

  /**
   * delete all data if table is here
   */
  public static void reset() {
    
    new GcDbAccess().connectionName("grouper").sql("delete from " + GcPersistableHelper.tableName(GcGrouperSyncDependencyGroupUser.class)).executeSql();
  }

  /**
   * 
   */
  public GcGrouperSyncDependencyGroupUser() {
  }

  /**
   * foreign key to grouper_sync_group table
   */
  private String grouperSyncId;


  /**
   * foreign key to grouper_sync_group table
   * @return group id
   */
  public String getGrouperSyncId() {
    return this.grouperSyncId;
  }

  /**
   * foreign key to grouper_sync_group table
   * @param grouperSyncId1
   */
  public void setGrouperSyncId(String grouperSyncId1) {
    this.grouperSyncId = grouperSyncId1;
    if (this.grouperSync == null || !GrouperClientUtils.equals(grouperSyncId1, this.grouperSync.getId())) {
      this.grouperSync = null;
    }
  }
  
  
  
  /**
   * connection name or null for default
   */
  @GcPersistableField(persist=GcPersist.dontPersist)
  private String connectionName;

  /**
   * 
   */
  private static Log LOG = GrouperClientUtils.retrieveLog(GcGrouperSyncDependencyGroupUser.class);

  /**
   * connection name or null for default
   * @return connection name
   */
  public String getConnectionName() {
    return this.connectionName;
  }

  /**
   * connection name or null for default
   * @param connectionName1
   */
  public void setConnectionName(String connectionName1) {
    this.connectionName = connectionName1;
  }
  
  /**
   * 
   */
  @Override
  public boolean gcSqlAssignNewPrimaryKeyForInsert() {
    if (this.idIndex != null) {
      return false;
    }
    if (this.idIndexForInsert != null) {
      this.idIndex = this.idIndexForInsert;
    } else {
      throw new RuntimeException("Set the id index for insert!");
    }
    return true;
  }

  /**
   * prepare to store
   */
  public void storePrepare() {
    GcGrouperSyncDependencyGroupUserDao.internalTestingStoreCount++;
    this.connectionName = GcGrouperSync.defaultConnectionName(this.connectionName);
  }

  /**
   * 
   */
  @Override
  public String toString() {
    return GrouperClientUtils.toStringReflection(this);
  }

  /**
   * 
   */
  @GcPersistableField(persist=GcPersist.dontPersist)
  private GcGrouperSync grouperSync;
  
  /**
   * 
   * @return gc grouper sync
   */
  public GcGrouperSync getGrouperSync() {
    return this.grouperSync;
  }
  
  /**
   * 
   * @param gcGrouperSync
   */
  public void setGrouperSync(GcGrouperSync gcGrouperSync) {
    this.grouperSync = gcGrouperSync;
    this.grouperSyncId = gcGrouperSync == null ? null : gcGrouperSync.getId();
    this.connectionName = gcGrouperSync == null ? this.connectionName : gcGrouperSync.getConnectionName();

  }

}
